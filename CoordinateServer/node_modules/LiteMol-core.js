var __liteMolCore = (function () {
    "use strict";
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        Core.VERSION = { number: "2.1.3", date: "Apr 6 2016" };
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Formats;
        (function (Formats) {
            "use strict";
            var ParserError = (function () {
                function ParserError(message, line) {
                    this.message = message;
                    this.line = line;
                }
                ParserError.prototype.toString = function () {
                    if (this.line >= 0) {
                        return "[Line " + this.line + "] " + this.message;
                    }
                    return this.message;
                };
                return ParserError;
            }());
            Formats.ParserError = ParserError;
            /**
             * A generic parser result.
             */
            var ParserResult = (function () {
                function ParserResult(error, warnings, result) {
                    this.error = error;
                    this.warnings = warnings;
                    this.result = result;
                }
                ParserResult.error = function (message, line) {
                    if (line === void 0) { line = -1; }
                    return new ParserResult(new ParserError(message, line), [], undefined);
                };
                ParserResult.success = function (result, warnings) {
                    if (warnings === void 0) { warnings = []; }
                    return new ParserResult(undefined, warnings, result);
                };
                return ParserResult;
            }());
            Formats.ParserResult = ParserResult;
            /**
             * A helper class for building a typed array of token indices.
             */
            var TokenIndexBuilder = (function () {
                function TokenIndexBuilder(size) {
                    this.count = 0;
                    this.tokens = new Int32Array(size);
                    this.tokensLenMinus2 = (size - 2) | 0;
                }
                TokenIndexBuilder.prototype.resize = function () {
                    // scale the size using golden ratio, because why not.
                    var newBuffer = new Int32Array((1.61 * this.tokens.length) | 0);
                    newBuffer.set(this.tokens);
                    this.tokens = newBuffer;
                    this.tokensLenMinus2 = (newBuffer.length - 2) | 0;
                };
                TokenIndexBuilder.prototype.addToken = function (start, end) {
                    if (this.count >= this.tokensLenMinus2) {
                        this.resize();
                    }
                    this.tokens[this.count++] = start;
                    this.tokens[this.count++] = end;
                };
                return TokenIndexBuilder;
            }());
            Formats.TokenIndexBuilder = TokenIndexBuilder;
            /**
             * A helper class to store only unique strings.
             */
            var ShortStringPool = (function () {
                function ShortStringPool() {
                }
                ShortStringPool.getString = function (key) {
                    if (key.length > 6)
                        return key;
                    var value = this.strings.get(key);
                    if (value !== void 0)
                        return value;
                    this.strings.set(key, key);
                    return key;
                };
                ShortStringPool.strings = new Map();
                return ShortStringPool;
            }());
            Formats.ShortStringPool = ShortStringPool;
        })(Formats = Core.Formats || (Core.Formats = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/*
    On data representation of molecular files

    Consider an mmCIF file that stores a molecule with 100k atoms. For the sake of simplicity,
    lets ignore things like symmetry or assemblies, and assume, that the file only stores the
    _atom_site records. The atom site "table" in the standard mmCIF from PDB database currently
    has 26 columns.

    So the data looks something like this:

        loop_
        _atom_site.column1
        ....
        _atom_site.column26
        t1,1 .... t1,26
        t100000,1 .... t100000,26

    The straightforward way to represent this data in JavaScript is to have an array of objects
    with properties named "column1" ..., "column26":

        [{ column1: "t1,1", ..., column26: "t1,26" },
          ...,
         { column1: "t100000,1", ..., column26: "t100000,26" }]

    So in order to represent the atoms sites, we would need 100k objects and 2.6 million strings.
    Is this bad? well, sort of. It would not be so bad if this representation would be the only
    thing we need to keep in memory and/or the life time of the object was short. But usually
    we would need to keep the object around for the entire lifetime of the app. This alone
    adds a very non-significant overhead for the garbage collector (which increases the app's
    latency). What's worse is that we usually only need a fraction of this data, but this can
    vary application for application. For just 100k atoms, the overhead is not "that bad", but
    consider 1M atoms and suddenly we have a problem.

    The following data model shows an alternative way of storing molecular file s
    in memory that is very efficient, fast and introduces a very minimal overhead.

 */
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Formats;
        (function (Formats) {
            var Cif;
            (function (Cif) {
                "use strict";
                var ShortStringPool = Formats.ShortStringPool;
                /**
                 * Represents the input file.
                 */
                var File = (function () {
                    function File(data) {
                        this.data = data;
                        this.dataBlocks = [];
                    }
                    /**
                     * Adds a block.
                     */
                    File.prototype.addBlock = function (block) {
                        this.dataBlocks[this.dataBlocks.length] = block;
                    };
                    File.prototype.toJSON = function () {
                        return this.dataBlocks.map(function (b) { return b.toJSON(); });
                    };
                    return File;
                }());
                Cif.File = File;
                /**
                 * Represents a single data block.
                 */
                var Block = (function () {
                    function Block(file, header) {
                        this.file = file;
                        this.header = header;
                        this.data = file.data;
                        this.categoryList = [];
                        this.additionalData = {};
                        this.categoryMap = {};
                    }
                    Object.defineProperty(Block.prototype, "categories", {
                        /**
                         * Categories of the block.
                         * block.categories._atom_site / ['_atom_site']
                         */
                        get: function () {
                            return this.categoryMap;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /**
                     * Adds a category.
                     */
                    Block.prototype.addCategory = function (category) {
                        this.categoryList[this.categoryList.length] = category;
                        this.categoryMap[category.name] = category;
                    };
                    /**
                     * Gets a category by its name.
                     */
                    Block.prototype.getCategory = function (name) {
                        return this.categoryMap[name];
                    };
                    /**
                     * Determines if a given category is present.
                     */
                    Block.prototype.hasCategory = function (name) {
                        return this.categoryMap[name] !== void 0;
                    };
                    Block.prototype.toJSON = function () {
                        return {
                            id: this.header,
                            categories: this.categoryList.map(function (c) { return c.toJSON(); }),
                            additionalData: this.additionalData
                        };
                    };
                    return Block;
                }());
                Cif.Block = Block;
                /**
                 * A context for easy (but slower) querying of category data.
                 */
                var CategoryQueryRowContext = (function () {
                    function CategoryQueryRowContext(category, rowNumber) {
                        this.category = category;
                        this.rowNumber = rowNumber;
                    }
                    /**
                     * Get a string value of the row.
                     */
                    CategoryQueryRowContext.prototype.getString = function (column) {
                        return this.category.getStringValue(column, this.rowNumber);
                    };
                    /**
                     * Get an integer value of the row.
                     */
                    CategoryQueryRowContext.prototype.getInt = function (column) {
                        return this.category.getIntValue(column, this.rowNumber);
                    };
                    /**
                     * Get a float value of the row.
                     */
                    CategoryQueryRowContext.prototype.getFloat = function (column) {
                        return this.category.getFloatValue(column, this.rowNumber);
                    };
                    return CategoryQueryRowContext;
                }());
                Cif.CategoryQueryRowContext = CategoryQueryRowContext;
                /**
                 * Represents a single column of a CIF category.
                 */
                var Column = (function () {
                    function Column(category, name, index) {
                        this.category = category;
                        this.name = name;
                        this.index = index;
                    }
                    /**
                     * Returns the raw string value at given row.
                     */
                    Column.prototype.getRaw = function (row) {
                        return this.category.getRawValueFromIndex(this.index, row);
                    };
                    /**
                     * Returns the string value at given row.
                     */
                    Column.prototype.getString = function (row) {
                        return this.category.getStringValueFromIndex(this.index, row);
                    };
                    /**
                     * Returns the integer value at given row.
                     */
                    Column.prototype.getInteger = function (row) {
                        return this.category.getIntValueFromIndex(this.index, row);
                    };
                    /**
                     * Returns the float value at given row.
                     */
                    Column.prototype.getFloat = function (row) {
                        return this.category.getFloatValueFromIndex(this.index, row);
                    };
                    /**
                     * Returns true if the token has the specified string value.
                     */
                    Column.prototype.stringEquals = function (row, value) {
                        return this.category.valueEqual(this.index, row, value);
                    };
                    /**
                     * Returns true if the value is not defined (. or ? token).
                     */
                    Column.prototype.isUndefined = function (row) {
                        return this.category.isValueUndefinedFromIndex(this.index, row);
                    };
                    return Column;
                }());
                Cif.Column = Column;
                /**
                 * Represents a single CIF category.
                 */
                var Category = (function () {
                    function Category(data, name, startIndex, endIndex, columns, tokens, tokenCount) {
                        this.name = name;
                        this.columnNames = columns;
                        this.tokens = tokens;
                        this.data = data;
                        this.startIndex = startIndex;
                        this.endIndex = endIndex;
                        this.columnCount = this.columnNames.length;
                        this.rowCount = (tokenCount / this.columnNames.length) | 0; //((this.tokens.length / 2) / this.columns.length) | 0;
                        this.tokenCount = tokenCount;
                        this.columnIndices = {};
                        this.columnWrappers = {};
                        this._columnArray = [];
                        this.shortColumnWrappers = {};
                        for (var i = 0; i < this.columnNames.length; i++) {
                            this.columnIndices[this.columnNames[i]] = i;
                            var col = new Column(this, this.columnNames[i], i);
                            this.columnWrappers[this.columnNames[i]] = col;
                            this.shortColumnWrappers[this.columnNames[i].substr(name.length + 1)] = col;
                            this._columnArray[i] = col;
                        }
                    }
                    Object.defineProperty(Category.prototype, "columns", {
                        /**
                         * The column wrappers used to access the colummns.
                         * Can be accessed for example as category.columns.id.
                         */
                        get: function () {
                            return this.shortColumnWrappers;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Category.prototype, "columnArray", {
                        /**
                         * The array of column wrappers used to access the colummns.
                         */
                        get: function () {
                            return this._columnArray;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /**
                     * Compute the token index.
                     */
                    Category.prototype.getTokenIndex = function (row, columnIndex) {
                        return row * this.columnCount + columnIndex;
                    };
                    /**
                     * Get index of a columns.
                     * @returns -1 if the column isn't present, the index otherwise.
                     */
                    Category.prototype.getColumnIndex = function (name) {
                        var idx = this.columnIndices[name];
                        if (idx !== undefined)
                            return idx;
                        return -1;
                    };
                    /**
                     * Get a column object that makes accessing data easier.
                     * @returns undefined if the column isn't present, the Column object otherwise.
                     */
                    Category.prototype.getColumn = function (name) {
                        return this.columnWrappers[name];
                    };
                    /**
                     * Updates the range of the token given by the column and row.
                     */
                    Category.prototype.updateTokenRange = function (columnIndex, row, token) {
                        var offset = 2 * (row * this.columnCount + columnIndex);
                        token.start = this.tokens[offset];
                        token.end = this.tokens[offset + 1];
                    };
                    /**
                     * Updates the range of the token given by its index.
                     */
                    Category.prototype.updateTokenIndexRange = function (tokenIndex, token) {
                        token.start = this.tokens[2 * tokenIndex];
                        token.end = this.tokens[2 * tokenIndex + 1];
                    };
                    /**
                     * Determines if the token at the given index is . or ?.
                     */
                    Category.prototype.isTokenUndefined = function (index) {
                        var s = this.tokens[2 * index];
                        if (this.tokens[2 * index + 1] - s !== 1)
                            return;
                        var v = this.data.charCodeAt(s);
                        return v === 46 /* . */ || v === 63 /* ? */;
                    };
                    /**
                     * Determines if the token at the given range is . or ?.
                     */
                    Category.prototype.isTokenRangeUndefined = function (start, end) {
                        if (end - start !== 1)
                            return;
                        var v = this.data.charCodeAt(start);
                        return v === 46 /* . */ || v === 63 /* ? */;
                    };
                    /**
                     * Determines if a column value is defined (has to be present and not . nor ?).
                     */
                    Category.prototype.isValueUndefined = function (column, row) {
                        if (row === void 0) { row = 0; }
                        row = row | 0;
                        var c = this.getColumnIndex(column);
                        if (c < 0)
                            return true;
                        return this.isTokenUndefined(row * this.columnCount + c);
                    };
                    /**
                     * Determines if a column value is defined (has to be present and not . nor ?).
                     */
                    Category.prototype.isValueUndefinedFromIndex = function (columnIndex, row) {
                        row = row | 0;
                        if (columnIndex < 0)
                            return true;
                        return this.isTokenUndefined(row * this.columnCount + columnIndex);
                    };
                    /**
                     * Returns the length of the given token;
                     */
                    Category.prototype.getTokenLengthFromIndex = function (columnIndex, row) {
                        if (columnIndex < 0)
                            return 0;
                        var i = (row * this.columnCount + columnIndex) * 2;
                        return this.tokens[i + 1] - this.tokens[i];
                    };
                    /**
                     * Get a string value from a token at a given index.
                     */
                    Category.prototype.getStringValueFromToken = function (index) {
                        var s = this.tokens[2 * index], e = this.tokens[2 * index + 1];
                        if (e - s === 1) {
                            var v = this.data.charCodeAt(s);
                            if (v === 46 /* . */ || v === 63 /* ? */)
                                return null;
                        }
                        var ret = ShortStringPool.getString(this.data.substring(s, e));
                        return ret;
                    };
                    /**
                     * Returns the string value of the column.
                     * @returns null if not present or ./?.
                     */
                    Category.prototype.getStringValue = function (column, row) {
                        if (row === void 0) { row = 0; }
                        row = row | 0;
                        var col = this.getColumnIndex(column);
                        if (col < 0)
                            return null;
                        return this.getStringValueFromToken(row * this.columnCount + col);
                    };
                    /**
                     * Returns the string value of the column.
                     * @returns Default if not present or ./?.
                     */
                    Category.prototype.getStringValueOrDefault = function (column, defaultValue, row) {
                        if (defaultValue === void 0) { defaultValue = ""; }
                        if (row === void 0) { row = 0; }
                        var ret = this.getStringValue(column, row);
                        if (!ret)
                            return defaultValue;
                        return ret;
                    };
                    /**
                     * Returns the float value of the column.
                     * @returns NaN if not present or ./?.
                     */
                    Category.prototype.getFloatValue = function (column, row) {
                        if (row === void 0) { row = 0; }
                        row = row | 0;
                        var col = this.getColumnIndex(column);
                        if (col < 0)
                            return NaN;
                        var i = (row * this.columnCount + col) * 2, s = this.tokens[i], e = this.tokens[i + 1];
                        if (e - s === 1) {
                            var v = this.data.charCodeAt(s);
                            if (v === 46 /* . */ || v === 63 /* ? */)
                                return NaN;
                        }
                        return Core.Utils.FastNumberParsers.parseFloat(this.data, this.tokens[i], this.tokens[i + 1]);
                    };
                    /**
                     * Returns the float value of the column.
                     * @returns Default if not present or ./?.
                     */
                    Category.prototype.getFloatValueOrDefault = function (column, defaultValue, row) {
                        if (defaultValue === void 0) { defaultValue = 0; }
                        if (row === void 0) { row = 0; }
                        var ret = this.getFloatValue(column, row);
                        if (isNaN(ret))
                            return defaultValue;
                        return ret;
                    };
                    /**
                     * Returns the integer value of the column.
                     * @returns NaN if not present or ./?.
                     */
                    Category.prototype.getIntValue = function (column, row) {
                        if (row === void 0) { row = 0; }
                        row = row | 0;
                        var col = this.getColumnIndex(column);
                        if (col < 0)
                            return NaN;
                        var i = (row * this.columnCount + col) * 2, s = this.tokens[i], e = this.tokens[i + 1];
                        if (e - s === 1) {
                            var v = this.data.charCodeAt(s);
                            if (v === 46 /* . */ || v === 63 /* ? */)
                                return NaN;
                        }
                        return Core.Utils.FastNumberParsers.parseInt(this.data, this.tokens[i], this.tokens[i + 1]);
                    };
                    /**
                      * Returns the float value of the column.
                      * @returns Default if not present or ./?.
                      */
                    Category.prototype.getIntValueOrDefault = function (column, defaultValue, row) {
                        if (defaultValue === void 0) { defaultValue = 0; }
                        if (row === void 0) { row = 0; }
                        var ret = this.getIntValue(column, row);
                        if (isNaN(ret))
                            return defaultValue;
                        return ret;
                    };
                    /**
                     * Returns the raw value of the column (does not do null check for ./?).
                     */
                    Category.prototype.getRawValueFromIndex = function (columnIndex, row) {
                        if (columnIndex < 0)
                            return null;
                        var i = (row * this.columnCount + columnIndex) * 2;
                        return ShortStringPool.getString(this.data.substring(this.tokens[i], this.tokens[i + 1]));
                    };
                    /**
                     * Returns the string value of the column.
                     */
                    Category.prototype.getStringValueFromIndex = function (columnIndex, row) {
                        if (columnIndex < 0)
                            return null;
                        var i = (row * this.columnCount + columnIndex) * 2;
                        var ret = ShortStringPool.getString(this.data.substring(this.tokens[i], this.tokens[i + 1]));
                        if (ret === "." || ret === "?")
                            return null;
                        return ret;
                    };
                    /**
                     * Returns the integer value of the column.
                     */
                    Category.prototype.getIntValueFromIndex = function (columnIndex, row) {
                        if (columnIndex < 0)
                            return NaN;
                        var i = (row * this.columnCount + columnIndex) * 2;
                        return Core.Utils.FastNumberParsers.parseInt(this.data, this.tokens[i], this.tokens[i + 1]);
                    };
                    /**
                     * Returns the integer value of the column.
                     */
                    Category.prototype.getFloatValueFromIndex = function (columnIndex, row) {
                        if (columnIndex < 0)
                            return NaN;
                        var i = (row * this.columnCount + columnIndex) * 2;
                        return Core.Utils.FastNumberParsers.parseFloat(this.data, this.tokens[i], this.tokens[i + 1]);
                    };
                    /**
                     * Returns a matrix constructed from a given field: category.field[1..rows][1..cols]
                     */
                    Category.prototype.getMatrix = function (field, rows, cols, rowIndex) {
                        var ret = [], row;
                        for (var i = 1; i <= rows; i++) {
                            row = [];
                            for (var j = 1; j <= cols; j++) {
                                var c = field + "[" + i + "][" + j + "]";
                                if (this.isValueUndefined(c, rowIndex))
                                    return undefined;
                                row[j - 1] = this.getFloatValue(c, rowIndex);
                            }
                            ret[i - 1] = row;
                        }
                        return ret;
                    };
                    /**
                     * Returns a vector constructed from a given field: category.field[1..rows]
                     */
                    Category.prototype.getVector = function (field, rows, cols, rowIndex) {
                        var ret = [];
                        for (var i = 1; i <= rows; i++) {
                            var c = field + "[" + i + "]";
                            if (this.isValueUndefined(c, rowIndex))
                                return undefined;
                            ret[i - 1] = this.getFloatValue(c, rowIndex);
                        }
                        return ret;
                    };
                    Category.prototype.getTransform = function (row, matrix, vector) {
                        var ret = Core.Geometry.LinearAlgebra.Matrix4.identity(), i, j, c;
                        for (i = 1; i <= 3; i++) {
                            for (j = 1; j <= 3; j++) {
                                c = matrix + "[" + i + "][" + j + "]";
                                if (this.isValueUndefined(c, row))
                                    return undefined;
                                Core.Geometry.LinearAlgebra.Matrix4.setValue(ret, i - 1, j - 1, this.getFloatValue(c, row));
                            }
                            c = vector + "[" + i + "]";
                            Core.Geometry.LinearAlgebra.Matrix4.setValue(ret, i - 1, 3, this.getFloatValue(c, row));
                        }
                        return ret;
                    };
                    /**
                     * Determines if two tokens have the same string value.
                     */
                    Category.prototype.areTokensEqual = function (aIndex, bIndex) {
                        var aS = this.tokens[aIndex * 2], bS = this.tokens[bIndex * 2], len = this.tokens[aIndex * 2 + 1] - aS;
                        if (len !== this.tokens[bIndex * 2 + 1] - bS)
                            return false;
                        for (var i = 0; i < len; i++) {
                            if (this.data.charCodeAt(i + aS) !== this.data.charCodeAt(i + bS))
                                return false;
                        }
                        return true;
                    };
                    /**
                     * Determines if a token contains a given string.
                     */
                    Category.prototype.tokenEqual = function (aIndex, value) {
                        var s = this.tokens[aIndex * 2], len = value.length;
                        if (len !== this.tokens[aIndex * 2 + 1] - s)
                            return false;
                        for (var i = 0; i < len; i++) {
                            if (this.data.charCodeAt(i + s) !== value.charCodeAt(i))
                                return false;
                        }
                        return true;
                    };
                    /**
                     * Determines if a value contains a given string.
                     */
                    Category.prototype.valueEqual = function (columnIndex, row, value) {
                        var aIndex = (row * this.columnCount + columnIndex) * 2, s = this.tokens[aIndex], len = value.length;
                        if (len !== this.tokens[aIndex + 1] - s)
                            return false;
                        for (var i = 0; i < len; i++) {
                            if (this.data.charCodeAt(i + s) !== value.charCodeAt(i))
                                return false;
                        }
                        return true;
                    };
                    /**
                     * Maps the rows to an user defined representation.
                     *
                     * @example
                     *   // returns an array objects with id and type properties.
                     *   category.select(row => { id: row.getInt("_entity.id"), type: row.getString("_entity.type") })
                     */
                    Category.prototype.select = function (selector) {
                        var ret = [];
                        for (var i = 0; i < this.rowCount; i++) {
                            ret[i] = selector(new CategoryQueryRowContext(this, i));
                        }
                        return ret;
                    };
                    /**
                     * Maps the rows that satisfy a condition to an user defined representation.
                     *
                     * @example
                     *   // returns entity ids of entities with weight > 1000.
                     *   category.selectWhere(
                     *     row => row.getFloat("_entity.weight") > 1000,
                     *     row => row.getInt("_entity.id"))
                     */
                    Category.prototype.selectWhere = function (condition, selector) {
                        var ret = [];
                        for (var i = 0; i < this.rowCount; i++) {
                            var ctx = new CategoryQueryRowContext(this, i);
                            if (condition(ctx)) {
                                ret[ret.length] = selector(ctx);
                            }
                        }
                        return ret;
                    };
                    Category.prototype.toJSON = function () {
                        var rows = [], i, j, data = this.data, tokens = this.tokens;
                        for (i = 0; i < this.rowCount; i++) {
                            var item = {};
                            for (j = 0; j < this.columnCount; j++) {
                                var tk = (i * this.columnCount + j) * 2;
                                item[this.columnNames[j]] = data.substring(tokens[tk], tokens[tk + 1]);
                            }
                            rows[i] = item;
                        }
                        return { name: this.name, columns: this.columnNames.slice(0), rows: rows };
                    };
                    return Category;
                }());
                Cif.Category = Category;
            })(Cif = Formats.Cif || (Formats.Cif = {}));
        })(Formats = Core.Formats || (Core.Formats = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Formats;
        (function (Formats) {
            var Cif;
            (function (Cif) {
                "use strict";
                var mmCif = (function () {
                    function mmCif() {
                    }
                    mmCif.getModelEndRow = function (startRow, category) {
                        var size = category.rowCount, modelNumCol = category.getColumnIndex("_atom_site.pdbx_PDB_model_num"), currentOffset = 0, colCount = category.columnCount, startOffset = startRow * colCount + modelNumCol, i = 0;
                        if (modelNumCol < 0)
                            return size;
                        for (i = startRow; i < size; i++) {
                            currentOffset = i * colCount;
                            if (!category.areTokensEqual(startOffset, currentOffset + modelNumCol)) {
                                break;
                            }
                        }
                        return i;
                    };
                    mmCif.buildModelAtomTable = function (startRow, category) {
                        var endRow = mmCif.getModelEndRow(startRow, category);
                        var colCount = category.columnCount, atoms = new Core.Structure.DataTableBuilder(endRow - startRow), id = atoms.addColumn("id", function (size) { return new Int32Array(size); }), idX = category.getColumnIndex("_atom_site.id"), pX = atoms.addColumn("x", function (size) { return new Float32Array(size); }), pXX = category.getColumnIndex("_atom_site.Cartn_x"), pY = atoms.addColumn("y", function (size) { return new Float32Array(size); }), pYX = category.getColumnIndex("_atom_site.Cartn_y"), pZ = atoms.addColumn("z", function (size) { return new Float32Array(size); }), pZX = category.getColumnIndex("_atom_site.Cartn_z"), altLoc = atoms.addColumn("altLoc", function (size) { return []; }), altLocX = category.getColumnIndex("_atom_site.label_alt_id"), rowIndex = atoms.addColumn("rowIndex", function (size) { return new Int32Array(size); }), residueIndex = atoms.addColumn("residueIndex", function (size) { return new Int32Array(size); }), chainIndex = atoms.addColumn("chainIndex", function (size) { return new Int32Array(size); }), entityIndex = atoms.addColumn("entityIndex", function (size) { return new Int32Array(size); }), name = atoms.addColumn("name", function (size) { return []; }), nameX = category.getColumnIndex("_atom_site.label_atom_id"), elementSymbol = atoms.addColumn("elementSymbol", function (size) { return []; }), elementSymbolX = category.getColumnIndex("_atom_site.type_symbol"), occupancy = atoms.addColumn("occupancy", function (size) { return new Float32Array(size); }), occupancyX = category.getColumnIndex("_atom_site.occupancy"), tempFactor = atoms.addColumn("tempFactor", function (size) { return new Float32Array(size); }), tempFactorX = category.getColumnIndex("_atom_site.B_iso_or_equiv");
                        var resSeqNumberCol = category.getColumnIndex("_atom_site.label_seq_id"), asymIdCol = category.getColumnIndex("_atom_site.label_asym_id"), entityCol = category.getColumnIndex("_atom_site.label_entity_id"), insCodeCol = category.getColumnIndex("_atom_site.pdbx_PDB_ins_code"), authResSeqNumberCol = category.getColumnIndex("_atom_site.auth_seq_id"), modelNumCol = category.getColumnIndex("_atom_site.pdbx_PDB_model_num"), 
                        //authAsymIdCol = category.getColumnIndex("_atom_site.auth_asym_id"),
                        currentResidueNumberToken = resSeqNumberCol, currentAsymIdToken = asymIdCol, currentInsCodeToken = insCodeCol, currentAuthResidueNumberToken = authResSeqNumberCol, 
                        //currentAuthAsymIdToken = authAsymIdCol,
                        currentEntityToken = entityCol, currentOffset = 0, newResidue = false, newChain = false, numChains = 0, numResidues = 0, numEntities = 0;
                        for (var row = startRow; row < endRow; row++) {
                            var index = row - startRow;
                            currentOffset = row * colCount;
                            id[index] = category.getIntValueFromIndex(idX, row);
                            pX[index] = category.getFloatValueFromIndex(pXX, row);
                            pY[index] = category.getFloatValueFromIndex(pYX, row);
                            pZ[index] = category.getFloatValueFromIndex(pZX, row);
                            name[index] = category.getStringValueFromIndex(nameX, row);
                            elementSymbol[index] = category.getStringValueFromIndex(elementSymbolX, row);
                            altLoc[index] = category.getStringValueFromIndex(altLocX, row);
                            occupancy[index] = category.getFloatValueFromIndex(occupancyX, row);
                            tempFactor[index] = category.getFloatValueFromIndex(tempFactorX, row);
                            newResidue = false;
                            newChain = false;
                            if (category.isTokenUndefined(currentResidueNumberToken)) {
                                // handle HET residues
                                newResidue =
                                    !category.areTokensEqual(currentAuthResidueNumberToken, currentOffset + authResSeqNumberCol);
                            }
                            else {
                                newResidue =
                                    !category.areTokensEqual(currentResidueNumberToken, currentOffset + resSeqNumberCol)
                                        || !category.areTokensEqual(currentInsCodeToken, currentOffset + insCodeCol);
                            }
                            if (newResidue) {
                                numResidues++;
                                currentResidueNumberToken = currentOffset + resSeqNumberCol;
                                currentAuthResidueNumberToken = currentOffset + authResSeqNumberCol;
                                currentInsCodeToken = currentOffset + insCodeCol;
                            }
                            if (!category.areTokensEqual(currentAsymIdToken, currentOffset + asymIdCol)) {
                                // handle new chain
                                newChain = true;
                                numChains++;
                                currentAsymIdToken = currentOffset + asymIdCol;
                                if (!newResidue) {
                                    newResidue = true;
                                    numResidues++;
                                    currentResidueNumberToken = currentOffset + resSeqNumberCol;
                                    currentAuthResidueNumberToken = currentOffset + authResSeqNumberCol;
                                    currentInsCodeToken = currentOffset + insCodeCol;
                                }
                            }
                            if (!category.areTokensEqual(currentEntityToken, currentOffset + entityCol)) {
                                // handle new entity
                                numEntities++;
                                currentEntityToken = currentOffset + entityCol;
                                if (!newChain) {
                                    newChain = true;
                                    numChains++;
                                    currentAsymIdToken = currentOffset + asymIdCol;
                                }
                                if (!newResidue) {
                                    newResidue = true;
                                    numResidues++;
                                    currentResidueNumberToken = currentOffset + resSeqNumberCol;
                                    currentAuthResidueNumberToken = currentOffset + authResSeqNumberCol;
                                    currentInsCodeToken = currentOffset + insCodeCol;
                                }
                            }
                            rowIndex[index] = row;
                            residueIndex[index] = numResidues;
                            chainIndex[index] = numChains;
                            entityIndex[index] = numEntities;
                        }
                        var modelId = modelNumCol < 0 ? "1" : category.getStringValue("_atom_site.pdbx_PDB_model_num", startRow);
                        return {
                            atoms: atoms.seal(),
                            modelId: modelId,
                            endRow: endRow
                        };
                    };
                    mmCif.buildStructure = function (category, atoms) {
                        var count = atoms.count, residueIndexCol = atoms.residueIndex, chainIndexCol = atoms.chainIndex, entityIndexCol = atoms.entityIndex, residues = new Core.Structure.DataTableBuilder(atoms.residueIndex[atoms.count - 1] + 1), chains = new Core.Structure.DataTableBuilder(atoms.chainIndex[atoms.count - 1] + 1), entities = new Core.Structure.DataTableBuilder(atoms.entityIndex[atoms.count - 1] + 1), residueName = residues.addColumn("name", function (size) { return []; }), residueSeqNumber = residues.addColumn("seqNumber", function (size) { return new Int32Array(size); }), residueAsymId = residues.addColumn("asymId", function (size) { return []; }), residueAuthName = residues.addColumn("authName", function (size) { return []; }), residueAuthSeqNumber = residues.addColumn("authSeqNumber", function (size) { return new Int32Array(size); }), residueAuthAsymId = residues.addColumn("authAsymId", function (size) { return []; }), residueInsertionCode = residues.addColumn("insCode", function (size) { return []; }), residueEntityId = residues.addColumn("entityId", function (size) { return []; }), residueIsHet = residues.addColumn("isHet", function (size) { return new Int8Array(size); }), residueAtomStartIndex = residues.addColumn("atomStartIndex", function (size) { return new Int32Array(size); }), residueAtomEndIndex = residues.addColumn("atomEndIndex", function (size) { return new Int32Array(size); }), residueChainIndex = residues.addColumn("chainIndex", function (size) { return new Int32Array(size); }), residueEntityIndex = residues.addColumn("entityIndex", function (size) { return new Int32Array(size); }), chainAsymId = chains.addColumn("asymId", function (size) { return []; }), chainEntityId = chains.addColumn("entityId", function (size) { return []; }), chainAuthAsymId = chains.addColumn("authAsymId", function (size) { return []; }), chainAtomStartIndex = chains.addColumn("atomStartIndex", function (size) { return new Int32Array(size); }), chainAtomEndIndex = chains.addColumn("atomEndIndex", function (size) { return new Int32Array(size); }), chainResidueStartIndex = chains.addColumn("residueStartIndex", function (size) { return new Int32Array(size); }), chainResidueEndIndex = chains.addColumn("residueEndIndex", function (size) { return new Int32Array(size); }), chainEntityIndex = chains.addColumn("entityIndex", function (size) { return new Int32Array(size); }), entityId = entities.addColumn("entityId", function (size) { return []; }), entityTypeEnum = entities.addColumn("entityType", function (size) { return []; }), entityType = entities.addColumn("type", function (size) { return []; }), entityAtomStartIndex = entities.addColumn("atomStartIndex", function (size) { return new Int32Array(size); }), entityAtomEndIndex = entities.addColumn("atomEndIndex", function (size) { return new Int32Array(size); }), entityResidueStartIndex = entities.addColumn("residueStartIndex", function (size) { return new Int32Array(size); }), entityResidueEndIndex = entities.addColumn("residueEndIndex", function (size) { return new Int32Array(size); }), entityChainStartIndex = entities.addColumn("chainStartIndex", function (size) { return new Int32Array(size); }), entityChainEndIndex = entities.addColumn("chainEndIndex", function (size) { return new Int32Array(size); }), resNameCol = category.getColumnIndex("_atom_site.label_comp_id"), resSeqNumberCol = category.getColumnIndex("_atom_site.label_seq_id"), asymIdCol = category.getColumnIndex("_atom_site.label_asym_id"), authResNameCol = category.getColumnIndex("_atom_site.auth_comp_id"), authResSeqNumberCol = category.getColumnIndex("_atom_site.auth_seq_id"), authAsymIdCol = category.getColumnIndex("_atom_site.auth_asym_id"), isHetCol = category.getColumnIndex("_atom_site.group_PDB"), entityCol = category.getColumnIndex("_atom_site.label_entity_id"), insCodeCol = category.getColumnIndex("_atom_site.pdbx_PDB_ins_code"), residueStart = 0, chainStart = 0, entityStart = 0, entityChainStart = 0, entityResidueStart = 0, chainResidueStart = 0, currentResidue = 0, currentChain = 0, currentEntity = 0;
                        var i = 0;
                        for (i = 0; i < count; i++) {
                            if (residueIndexCol[i] !== residueIndexCol[residueStart]) {
                                residueName[currentResidue] = category.getStringValueFromIndex(resNameCol, residueStart);
                                residueSeqNumber[currentResidue] = category.getIntValueFromIndex(resSeqNumberCol, residueStart);
                                residueAsymId[currentResidue] = category.getStringValueFromIndex(asymIdCol, residueStart);
                                residueAuthName[currentResidue] = category.getStringValueFromIndex(authResNameCol, residueStart);
                                residueAuthSeqNumber[currentResidue] = category.getIntValueFromIndex(authResSeqNumberCol, residueStart);
                                residueAuthAsymId[currentResidue] = category.getStringValueFromIndex(authAsymIdCol, residueStart);
                                residueInsertionCode[currentResidue] = category.getStringValueFromIndex(insCodeCol, residueStart);
                                residueEntityId[currentResidue] = category.getStringValueFromIndex(entityCol, residueStart);
                                residueIsHet[currentResidue] = category.valueEqual(isHetCol, residueStart, "HETATM") ? 1 : 0;
                                residueAtomStartIndex[currentResidue] = residueStart;
                                residueAtomEndIndex[currentResidue] = i;
                                residueChainIndex[currentResidue] = currentChain;
                                residueEntityIndex[currentResidue] = currentEntity;
                                currentResidue++;
                                residueStart = i;
                            }
                            if (chainIndexCol[i] !== chainIndexCol[chainStart]) {
                                chainAsymId[currentChain] = category.getStringValueFromIndex(asymIdCol, chainStart);
                                chainAuthAsymId[currentChain] = category.getStringValueFromIndex(authAsymIdCol, chainStart);
                                chainEntityId[currentChain] = category.getStringValueFromIndex(entityCol, chainStart);
                                chainResidueStartIndex[currentChain] = chainResidueStart;
                                chainResidueEndIndex[currentChain] = currentResidue;
                                chainAtomStartIndex[currentChain] = chainStart;
                                chainAtomEndIndex[currentChain] = i;
                                chainEntityIndex[currentChain] = currentEntity;
                                currentChain++;
                                chainStart = i;
                                chainResidueStart = currentResidue;
                            }
                            if (entityIndexCol[i] !== entityIndexCol[entityStart]) {
                                entityId[currentEntity] = category.getStringValueFromIndex(entityCol, entityStart);
                                entityTypeEnum[currentEntity] = Core.Structure.EntityType.Unknown;
                                entityType[currentEntity] = 'unknown';
                                entityAtomStartIndex[currentEntity] = entityStart;
                                entityAtomEndIndex[currentEntity] = i;
                                entityResidueStartIndex[currentEntity] = entityResidueStart;
                                entityResidueEndIndex[currentEntity] = currentResidue;
                                entityChainStartIndex[currentEntity] = entityChainStart;
                                entityChainEndIndex[currentEntity] = currentChain;
                                currentEntity++;
                                entityStart = i;
                                entityChainStart = currentChain;
                                entityResidueStart = currentResidue;
                            }
                        }
                        // entity
                        entityId[currentEntity] = category.getStringValueFromIndex(entityCol, entityStart);
                        entityTypeEnum[currentEntity] = Core.Structure.EntityType.Unknown;
                        entityType[currentEntity] = 'unknown';
                        entityAtomStartIndex[currentEntity] = entityStart;
                        entityAtomEndIndex[currentEntity] = i;
                        entityResidueStartIndex[currentEntity] = entityResidueStart;
                        entityResidueEndIndex[currentEntity] = currentResidue + 1;
                        entityChainStartIndex[currentEntity] = entityChainStart;
                        entityChainEndIndex[currentEntity] = currentChain + 1;
                        // chain
                        chainAsymId[currentChain] = category.getStringValueFromIndex(asymIdCol, chainStart);
                        chainAuthAsymId[currentChain] = category.getStringValueFromIndex(authAsymIdCol, chainStart);
                        chainEntityId[currentChain] = category.getStringValueFromIndex(entityCol, chainStart);
                        chainResidueStartIndex[currentChain] = chainResidueStart;
                        chainResidueEndIndex[currentChain] = currentResidue + 1;
                        chainAtomStartIndex[currentChain] = chainStart;
                        chainAtomEndIndex[currentChain] = i;
                        chainEntityIndex[currentChain] = currentEntity;
                        // residue
                        residueName[currentResidue] = category.getStringValueFromIndex(resNameCol, residueStart);
                        residueSeqNumber[currentResidue] = category.getIntValueFromIndex(resSeqNumberCol, residueStart);
                        residueAsymId[currentResidue] = category.getStringValueFromIndex(asymIdCol, residueStart);
                        residueAuthName[currentResidue] = category.getStringValueFromIndex(authResNameCol, residueStart);
                        residueAuthSeqNumber[currentResidue] = category.getIntValueFromIndex(authResSeqNumberCol, residueStart);
                        residueAuthAsymId[currentResidue] = category.getStringValueFromIndex(authAsymIdCol, residueStart);
                        residueInsertionCode[currentResidue] = category.getStringValueFromIndex(insCodeCol, residueStart);
                        residueAtomStartIndex[currentResidue] = residueStart;
                        residueAtomEndIndex[currentResidue] = i;
                        residueChainIndex[currentResidue] = currentChain;
                        residueEntityIndex[currentResidue] = currentEntity;
                        residueIsHet[currentResidue] = category.valueEqual(isHetCol, residueStart, "HETATM") ? 1 : 0;
                        return {
                            residues: residues.seal(),
                            chains: chains.seal(),
                            entities: entities.seal()
                        };
                    };
                    mmCif.assignEntityTypes = function (category, entities) {
                        var i;
                        for (i = 0; i < entities.count; i++) {
                            entities.entityType[i] = Core.Structure.EntityType.Unknown;
                        }
                        if (!category) {
                            return;
                        }
                        var dataEnum = {}, data = {}, et;
                        for (i = 0; i < category.rowCount; i++) {
                            var t = (category.getStringValue("_entity.type", i) || "").toLowerCase();
                            switch (t) {
                                case "polymer":
                                    et = Core.Structure.EntityType.Polymer;
                                    break;
                                case "non-polymer":
                                    et = Core.Structure.EntityType.NonPolymer;
                                    break;
                                case "water":
                                    et = Core.Structure.EntityType.Water;
                                    break;
                                default:
                                    et = Core.Structure.EntityType.Unknown;
                                    break;
                            }
                            var eId = category.getStringValue("_entity.id", i);
                            dataEnum[eId] = et;
                            data[eId] = t !== "" ? t : "unknown";
                        }
                        for (i = 0; i < entities.count; i++) {
                            et = dataEnum[entities.entityId[i]];
                            if (et !== undefined) {
                                entities.entityType[i] = et;
                                entities.type[i] = data[entities.entityId[i]];
                            }
                        }
                    };
                    mmCif.residueIdfromColumns = function (cat, row, asymId, seqNum, insCode) {
                        return new Core.Structure.PolyResidueIdentifier(cat.getStringValue(asymId, row), cat.getIntValue(seqNum, row), cat.getStringValue(insCode, row));
                    };
                    mmCif.isResidueAminoSeq = function (atoms, residues, entities, index) {
                        if (entities.entityType[residues.entityIndex[index]] !== Core.Structure.EntityType.Polymer)
                            return false;
                        //if (mmCif.aminoAcidNames[residues.name[index]]) return true;
                        var ca = false, o = false, names = atoms.name, assigned = 0;
                        for (var i = residues.atomStartIndex[index], max = residues.atomEndIndex[index]; i < max; i++) {
                            var n = names[i];
                            if (!ca && n === "CA") {
                                ca = true;
                                assigned++;
                            }
                            else if (!o && n === "O") {
                                o = true;
                                assigned++;
                            }
                            if (assigned === 2)
                                break;
                        }
                        return (ca && o) || (ca && !residues.isHet[index]);
                    };
                    mmCif.isResidueNucleotide = function (atoms, residues, entities, index) {
                        if (mmCif.aminoAcidNames[residues.name[index]] || entities.entityType[residues.entityIndex[index]] !== Core.Structure.EntityType.Polymer)
                            return false;
                        var o5 = false, c3 = false, n3 = false, names = atoms.name, assigned = 0;
                        for (var i = residues.atomStartIndex[index], max = residues.atomEndIndex[index]; i < max; i++) {
                            var n = names[i];
                            if (!o5 && n === "O5'") {
                                o5 = true;
                                assigned++;
                            }
                            else if (!c3 && n === "C3'") {
                                c3 = true;
                                assigned++;
                            }
                            else if (!n3 && n === "N3") {
                                n3 = true;
                                assigned++;
                            }
                            if (assigned === 3)
                                break;
                        }
                        return o5 && c3 && n3;
                    };
                    mmCif.analyzeSecondaryStructure = function (atoms, residues, entities, start, end, elements) {
                        var asymId = residues.asymId, entityIndex = residues.entityIndex, currentType = Core.Structure.SecondaryStructureType.None, currentElementStartIndex = start, currentResidueIndex = start, residueCount = end;
                        while (currentElementStartIndex < residueCount) {
                            if (mmCif.isResidueNucleotide(atoms, residues, entities, currentElementStartIndex)) {
                                currentResidueIndex = currentElementStartIndex + 1;
                                while (currentResidueIndex < residueCount
                                    && asymId[currentElementStartIndex] === asymId[currentResidueIndex]
                                    && entityIndex[currentElementStartIndex] === entityIndex[currentResidueIndex]
                                    && mmCif.isResidueNucleotide(atoms, residues, entities, currentResidueIndex)) {
                                    currentResidueIndex++;
                                }
                                currentType = Core.Structure.SecondaryStructureType.Strand;
                            }
                            else if (mmCif.isResidueAminoSeq(atoms, residues, entities, currentElementStartIndex)) {
                                currentResidueIndex = currentElementStartIndex + 1;
                                while (currentResidueIndex < residueCount
                                    && asymId[currentElementStartIndex] === asymId[currentResidueIndex]
                                    && entityIndex[currentElementStartIndex] === entityIndex[currentResidueIndex]
                                    && mmCif.isResidueAminoSeq(atoms, residues, entities, currentResidueIndex)) {
                                    currentResidueIndex++;
                                }
                                currentType = Core.Structure.SecondaryStructureType.AminoSeq;
                            }
                            else {
                                currentResidueIndex = currentElementStartIndex + 1;
                                while (currentResidueIndex < residueCount
                                    && asymId[currentElementStartIndex] === asymId[currentResidueIndex]
                                    && entityIndex[currentElementStartIndex] === entityIndex[currentResidueIndex]
                                    && !mmCif.isResidueNucleotide(atoms, residues, entities, currentResidueIndex)
                                    && !mmCif.isResidueAminoSeq(atoms, residues, entities, currentResidueIndex)) {
                                    currentResidueIndex++;
                                }
                                currentType = Core.Structure.SecondaryStructureType.None;
                            }
                            var e = new Core.Structure.SecondaryStructureElement(currentType, new Core.Structure.PolyResidueIdentifier(residues.asymId[currentElementStartIndex], residues.seqNumber[currentElementStartIndex], residues.insCode[currentElementStartIndex]), new Core.Structure.PolyResidueIdentifier(residues.asymId[currentResidueIndex - 1], residues.seqNumber[currentResidueIndex - 1], residues.insCode[currentResidueIndex - 1]));
                            e.startResidueIndex = currentElementStartIndex;
                            e.endResidueIndex = currentResidueIndex;
                            elements[elements.length] = e;
                            currentElementStartIndex = currentResidueIndex;
                        }
                    };
                    mmCif.splitNonconsecutiveSecondaryStructure = function (residues, elements) {
                        var ret = [];
                        var authSeqNumber = residues.authSeqNumber;
                        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
                            var s = elements_1[_i];
                            var partStart = s.startResidueIndex;
                            var end = s.endResidueIndex - 1;
                            for (var i = s.startResidueIndex; i < end; i++) {
                                if (authSeqNumber[i + 1] - authSeqNumber[i] === 1)
                                    continue;
                                var e = new Core.Structure.SecondaryStructureElement(s.type, s.startResidueId, s.endResidueId, s.info);
                                e.startResidueIndex = partStart;
                                e.endResidueIndex = i + 1;
                                ret[ret.length] = e;
                                partStart = i + 1;
                            }
                            if (partStart === s.startResidueIndex) {
                                ret[ret.length] = s;
                            }
                            else {
                                var e = new Core.Structure.SecondaryStructureElement(s.type, s.startResidueId, s.endResidueId, s.info);
                                e.startResidueIndex = partStart;
                                e.endResidueIndex = s.endResidueIndex;
                                ret[ret.length] = e;
                            }
                        }
                        return ret;
                    };
                    mmCif.updateSSIndicesAndFilterEmpty = function (elements, structure, target) {
                        var residues = structure.residues, count = residues.count, asymId = residues.asymId, seqNumber = residues.seqNumber, insCode = residues.insCode, inSS = false, currentElement, endPivot, key = "", starts = {}, ends = {};
                        for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
                            var e = elements_2[_i];
                            key = e.startResidueId.asymId + " " + e.startResidueId.seqNumber;
                            if (e.startResidueId.insCode)
                                key += " " + e.startResidueId.insCode;
                            starts[key] = e;
                            key = e.endResidueId.asymId + " " + e.endResidueId.seqNumber;
                            if (e.endResidueId.insCode)
                                key += " " + e.endResidueId.insCode;
                            ends[key] = e;
                        }
                        for (var i = 0; i < count; i++) {
                            key = asymId[i] + " " + seqNumber[i];
                            if (insCode[i])
                                key += " " + insCode[i];
                            currentElement = starts[key];
                            if (currentElement)
                                currentElement.startResidueIndex = i;
                            currentElement = ends[key];
                            if (currentElement)
                                currentElement.endResidueIndex = i + 1;
                        }
                        if (currentElement) {
                            currentElement.endResidueIndex = count;
                        }
                        for (var _a = 0, elements_3 = elements; _a < elements_3.length; _a++) {
                            var e = elements_3[_a];
                            if (e.type === Core.Structure.SecondaryStructureType.Sheet && e.length < 3)
                                continue;
                            if (e.endResidueIndex >= 0 && e.startResidueIndex >= 0)
                                target[target.length] = e;
                        }
                        // fix the "overlaps"
                        for (var i = 0; i < target.length - 1; i++) {
                            if (target[i + 1].startResidueIndex - target[i].endResidueIndex === -1) {
                                target[i + 1].startResidueIndex++;
                            }
                        }
                    };
                    mmCif.getSecondaryStructureInfo = function (data, atoms, structure) {
                        var input = [], secondary = [], elements = [];
                        var _struct_conf = data.getCategory("_struct_conf"), _struct_sheet_range = data.getCategory("_struct_sheet_range"), i;
                        if (_struct_conf) {
                            var type_id_col = _struct_conf.getColumn("_struct_conf.conf_type_id");
                            if (type_id_col) {
                                for (i = 0; i < _struct_conf.rowCount; i++) {
                                    var type = void 0;
                                    switch (type_id_col.getString(i).toUpperCase()) {
                                        case "HELX_P":
                                            type = Core.Structure.SecondaryStructureType.Helix;
                                            break;
                                        case "TURN_P":
                                            type = Core.Structure.SecondaryStructureType.Turn;
                                            break;
                                    }
                                    if (!type)
                                        continue;
                                    input[input.length] = new Core.Structure.SecondaryStructureElement(type, mmCif.residueIdfromColumns(_struct_conf, i, "_struct_conf.beg_label_asym_id", "_struct_conf.beg_label_seq_id", "_struct_conf.pdbx_beg_PDB_ins_code"), mmCif.residueIdfromColumns(_struct_conf, i, "_struct_conf.end_label_asym_id", "_struct_conf.end_label_seq_id", "_struct_conf.pdbx_end_PDB_ins_code"), {
                                        helixClass: _struct_conf.getStringValue("_struct_conf.pdbx_PDB_helix_class", i)
                                    });
                                }
                            }
                        }
                        if (_struct_sheet_range) {
                            for (i = 0; i < _struct_sheet_range.rowCount; i++) {
                                input[input.length] = new Core.Structure.SecondaryStructureElement(Core.Structure.SecondaryStructureType.Sheet, mmCif.residueIdfromColumns(_struct_sheet_range, i, "_struct_sheet_range.beg_label_asym_id", "_struct_sheet_range.beg_label_seq_id", "_struct_sheet_range.pdbx_beg_PDB_ins_code"), mmCif.residueIdfromColumns(_struct_sheet_range, i, "_struct_sheet_range.end_label_asym_id", "_struct_sheet_range.end_label_seq_id", "_struct_sheet_range.pdbx_end_PDB_ins_code"), {
                                    symmetry: _struct_sheet_range.getStringValue("_struct_sheet_range.symmetry", i),
                                    sheetId: _struct_sheet_range.getStringValue("_struct_sheet_range.sheet_id", i),
                                    id: _struct_sheet_range.getStringValue("_struct_sheet_range.id", i)
                                });
                            }
                        }
                        if (input.length > 0)
                            mmCif.updateSSIndicesAndFilterEmpty(input, structure, secondary);
                        secondary.sort(function (a, b) { return a.startResidueIndex - b.startResidueIndex; });
                        var residues = structure.residues, residueCount = residues.count;
                        if (secondary.length === 0) {
                            mmCif.analyzeSecondaryStructure(atoms, residues, structure.entities, 0, residueCount, elements);
                            return mmCif.splitNonconsecutiveSecondaryStructure(residues, elements);
                        }
                        var _max = secondary.length - 1;
                        if (secondary[0].startResidueIndex > 0) {
                            mmCif.analyzeSecondaryStructure(atoms, residues, structure.entities, 0, secondary[0].startResidueIndex, elements);
                        }
                        for (i = 0; i < _max; i++) {
                            elements[elements.length] = secondary[i];
                            if (secondary[i + 1].startResidueIndex - secondary[i].endResidueIndex > 0) {
                                mmCif.analyzeSecondaryStructure(atoms, residues, structure.entities, secondary[i].endResidueIndex, secondary[i + 1].startResidueIndex, elements);
                            }
                        }
                        elements[elements.length] = secondary[_max];
                        if (secondary[_max].endResidueIndex < residueCount) {
                            mmCif.analyzeSecondaryStructure(atoms, residues, structure.entities, secondary[_max].endResidueIndex, residueCount, elements);
                        }
                        return mmCif.splitNonconsecutiveSecondaryStructure(residues, elements);
                    };
                    mmCif.parseOperatorList = function (value) {
                        // '(X0)(1-5)' becomes [['X0']['1', '2', '3', '4', '5']]
                        // kudos to Glen van Ginkel.
                        var oeRegex = /\(?([^\(\)]+)\)?]*/g, g, groups = [], ret = [];
                        while (g = oeRegex.exec(value))
                            groups[groups.length] = g[1];
                        groups.forEach(function (g) {
                            var group = [];
                            g.split(",").forEach(function (e) {
                                var dashIndex = e.indexOf("-");
                                if (dashIndex > 0) {
                                    var from = parseInt(e.substring(0, dashIndex)), to = parseInt(e.substr(dashIndex + 1));
                                    for (var i = from; i <= to; i++)
                                        group[group.length] = i.toString();
                                }
                                else {
                                    group[group.length] = e.trim();
                                }
                            });
                            ret[ret.length] = group;
                        });
                        return ret;
                    };
                    mmCif.getAssemblyInfo = function (data) {
                        var _info = data.getCategory("_pdbx_struct_assembly"), _gen = data.getCategory("_pdbx_struct_assembly_gen"), _opers = data.getCategory("_pdbx_struct_oper_list");
                        if (!_info || !_gen || !_opers) {
                            return null;
                        }
                        var i, opers = {}, gens = [];
                        for (i = 0; i < _gen.rowCount; i++) {
                            gens[gens.length] = new Core.Structure.AssemblyGen(_gen.getStringValue("_pdbx_struct_assembly_gen.assembly_id", i), this.parseOperatorList(_gen.getStringValue("_pdbx_struct_assembly_gen.oper_expression", i)), _gen.getStringValue("_pdbx_struct_assembly_gen.asym_id_list", i).split(","));
                        }
                        for (i = 0; i < _opers.rowCount; i++) {
                            var oper = _opers.getTransform(i, "_pdbx_struct_oper_list.matrix", "_pdbx_struct_oper_list.vector");
                            if (!oper) {
                                return null;
                            }
                            var op = new Core.Structure.AssemblyOperator(_opers.getStringValue("_pdbx_struct_oper_list.id", i), _opers.getStringValue("_pdbx_struct_oper_list.name", i), oper);
                            opers[op.id] = op;
                        }
                        return new Core.Structure.AssemblyInfo(opers, gens);
                    };
                    mmCif.getSymmetryInfo = function (data) {
                        var _cell = data.getCategory("_cell"), _symmetry = data.getCategory("_symmetry"), _atom_sites = data.getCategory("_atom_sites");
                        var spacegroupName = "", cellSize = [1.0, 1.0, 1.0], cellAngles = [90.0, 90.0, 90.0], toFracTransform = Core.Geometry.LinearAlgebra.Matrix4.identity(), isNonStandardCrytalFrame = false;
                        if (!_cell || !_symmetry) {
                            return null;
                        }
                        spacegroupName = _symmetry.getStringValue("_symmetry.space_group_name_H-M");
                        cellSize = [_cell.getFloatValue("_cell.length_a"), _cell.getFloatValue("_cell.length_b"), _cell.getFloatValue("_cell.length_c")];
                        cellAngles = [_cell.getFloatValue("_cell.angle_alpha"), _cell.getFloatValue("_cell.angle_beta"), _cell.getFloatValue("_cell.angle_gamma")];
                        if (_symmetry.isValueUndefined("_symmetry.space_group_name_H-M")
                            || _cell.isValueUndefined("_cell.length_a") || _cell.isValueUndefined("_cell.length_b") || _cell.isValueUndefined("_cell.length_c")
                            || _cell.isValueUndefined("_cell.angle_alpha") || _cell.isValueUndefined("_cell.angle_beta") || _cell.isValueUndefined("_cell.angle_gamma")) {
                            return null;
                        }
                        var sq = function (x) { return x * x; };
                        var toRadians = function (degs) { return degs * Math.PI / 180.0; };
                        var la = cellSize[0], lb = cellSize[1], lc = cellSize[2], aa = toRadians(cellAngles[0]), ab = toRadians(cellAngles[1]), ac = toRadians(cellAngles[2]), v = la * lb * lc * Math.sqrt(1.0 - sq(Math.cos(aa)) - sq(Math.cos(ab)) - sq(Math.cos(ac)) + 2.0 * Math.cos(aa) * Math.cos(ab) * Math.cos(ac));
                        var fromFrac = Core.Geometry.LinearAlgebra.Matrix4.ofRows([
                            [la, lb * Math.cos(ac), lc * Math.cos(ab), 0.0],
                            [0.0, lb * Math.sin(ac), lc * (Math.cos(aa) - Math.cos(ab) * Math.cos(ac)) / Math.sin(ac), 0.0],
                            [0.0, 0.0, v / (la * lb * Math.sin(ac)), 0.0],
                            [0.0, 0.0, 0.0, 1.0]]);
                        var toFracComputed = Core.Geometry.LinearAlgebra.Matrix4.identity();
                        Core.Geometry.LinearAlgebra.Matrix4.invert(toFracComputed, fromFrac);
                        if (_atom_sites) {
                            var transform = _atom_sites.getTransform(0, "_atom_sites.fract_transf_matrix", "_atom_sites.fract_transf_vector");
                            //console.log("CIF", JSON.stringify(Array.prototype.slice.call(transform, 0).map((x: any) => x.toFixed(6))));
                            //console.log("COMP", JSON.stringify(Array.prototype.slice.call(toFracComputed, 0).map((x: any) => x.toFixed(6))));
                            //console.log("COMP", JSON.stringify(Array.prototype.slice.call(fromFrac, 0).map((x: any) => x.toFixed(6))));
                            if (transform) {
                                toFracTransform = transform;
                                if (!Core.Geometry.LinearAlgebra.Matrix4.areEqual(toFracComputed, transform, 0.0001)) {
                                    isNonStandardCrytalFrame = true;
                                }
                            }
                        }
                        else {
                            toFracTransform = toFracComputed;
                        }
                        return new Core.Structure.SymmetryInfo(spacegroupName, cellSize, cellAngles, toFracTransform, isNonStandardCrytalFrame);
                    };
                    mmCif.getComponentBonds = function (category) {
                        if (!category || !category.rowCount)
                            return undefined;
                        var info = new Core.Structure.ComponentBondInfo();
                        var idCol = category.getColumnIndex("_chem_comp_bond.comp_id"), nameACol = category.getColumnIndex("_chem_comp_bond.atom_id_1"), nameBCol = category.getColumnIndex("_chem_comp_bond.atom_id_2"), orderCol = category.getColumnIndex("_chem_comp_bond.value_order"), count = category.rowCount;
                        var entry = info.newEntry(category.getStringValueFromIndex(idCol, 0));
                        for (var i = 0; i < count; i++) {
                            var id = category.getStringValueFromIndex(idCol, i), nameA = category.getStringValueFromIndex(nameACol, i), nameB = category.getStringValueFromIndex(nameBCol, i), order = category.getStringValueFromIndex(orderCol, i);
                            if (entry.id !== id) {
                                entry = info.newEntry(id);
                            }
                            var t = void 0;
                            switch (order.toLowerCase()) {
                                case "sing":
                                    t = Core.Structure.BondOrder.Single;
                                    break;
                                case "doub":
                                case "delo":
                                    t = Core.Structure.BondOrder.Double;
                                    break;
                                case "trip":
                                    t = Core.Structure.BondOrder.Triple;
                                    break;
                                case "quad":
                                    t = Core.Structure.BondOrder.Quadruple;
                                    break;
                                default:
                                    t = Core.Structure.BondOrder.Single;
                                    break;
                            }
                            entry.add(nameA, nameB, t);
                        }
                        return info;
                    };
                    mmCif.getModel = function (startRow, data) {
                        var _a = mmCif.buildModelAtomTable(startRow, data.getCategory("_atom_site")), atoms = _a.atoms, modelId = _a.modelId, endRow = _a.endRow, structure = mmCif.buildStructure(data.getCategory("_atom_site"), atoms), entry = data.getCategory("_entry"), id;
                        if (entry && entry.getColumnIndex("_entry.id") >= 0)
                            id = entry.getStringValue("_entry.id");
                        else
                            id = data.header;
                        mmCif.assignEntityTypes(data.getCategory("_entity"), structure.entities);
                        return {
                            model: new Core.Structure.MoleculeModel(id, modelId, atoms, structure.residues, structure.chains, structure.entities, mmCif.getComponentBonds(data.getCategory("_chem_comp_bond")), mmCif.getSecondaryStructureInfo(data, atoms, structure), mmCif.getSymmetryInfo(data), mmCif.getAssemblyInfo(data), undefined, Core.Structure.MoleculeModelSource.File),
                            endRow: endRow
                        };
                    };
                    mmCif.ofDataBlock = function (data) {
                        var models = [], atomSite = data.getCategory("_atom_site"), startRow = 0;
                        var entry = data.getCategory("_entry"), id;
                        if (entry && entry.getColumnIndex("_entry.id") >= 0)
                            id = entry.getStringValue("_entry.id");
                        else
                            id = data.header;
                        while (startRow < atomSite.rowCount) {
                            var _a = mmCif.getModel(startRow, data), model = _a.model, endRow = _a.endRow;
                            models.push(model);
                            startRow = endRow;
                        }
                        return new Core.Structure.Molecule(id, models);
                    };
                    mmCif.aminoAcidNames = { "ALA": true, "ARG": true, "ASP": true, "CYS": true, "GLN": true, "GLU": true, "GLY": true, "HIS": true, "ILE": true, "LEU": true, "LYS": true, "MET": true, "PHE": true, "PRO": true, "SER": true, "THR": true, "TRP": true, "TYR": true, "VAL": true, "ASN": true, "PYL": true, "SEC": true };
                    return mmCif;
                }());
                Cif.mmCif = mmCif;
            })(Cif = Formats.Cif || (Formats.Cif = {}));
        })(Formats = Core.Formats || (Core.Formats = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/// <reference path="Dictionary.ts" />
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Formats;
        (function (Formats) {
            var Cif;
            (function (Cif) {
                "use strict";
                /**
                 * Cif tokenizer .. d'oh.
                 */
                var CifTokenizer = (function () {
                    function CifTokenizer(data) {
                        this.data = data;
                        this.length = data.length;
                        this.position = 0;
                        this.currentTokenStart = 0;
                        this.currentTokenEnd = 0;
                        this.currentTokenType = 6 /* End */;
                        this.currentLineNumber = 1;
                        this.isEscaped = false;
                    }
                    /**
                     * Eat everything until a whitespace/newline occurs.
                     */
                    CifTokenizer.prototype.eatValue = function () {
                        while (this.position < this.length) {
                            switch (this.data.charCodeAt(this.position)) {
                                case 9: // \t
                                case 10: // \n
                                case 13: // \r
                                case 32:
                                    this.currentTokenEnd = this.position;
                                    return;
                                default:
                                    ++this.position;
                                    break;
                            }
                        }
                        this.currentTokenEnd = this.position;
                    };
                    /**
                     * Eats an escaped values. Handles the "degenerate" cases as well.
                     *
                     * "Degenerate" cases:
                     * - 'xx'x' => xx'x
                     * - 'xxxNEWLINE => 'xxx
                     *
                     */
                    CifTokenizer.prototype.eatEscaped = function (esc) {
                        var next, c;
                        while (this.position < this.length) {
                            c = this.data.charCodeAt(this.position);
                            if (c === esc) {
                                next = this.data.charCodeAt(this.position + 1);
                                switch (next) {
                                    case 9: // \t
                                    case 10: // \n
                                    case 13: // \r
                                    case 32:
                                        // get rid of the quotes.
                                        this.currentTokenStart++;
                                        this.currentTokenEnd = this.position;
                                        this.isEscaped = true;
                                        ++this.position;
                                        return;
                                    default:
                                        if (next === void 0) {
                                            // get rid of the quotes.
                                            this.currentTokenStart++;
                                            this.currentTokenEnd = this.position;
                                            this.isEscaped = true;
                                            ++this.position;
                                            return;
                                        }
                                        ++this.position;
                                        break;
                                }
                            }
                            else {
                                // handle 'xxxNEWLINE => 'xxx
                                if (c === 10 || c === 13) {
                                    this.currentTokenEnd = this.position;
                                    return;
                                }
                                ++this.position;
                            }
                        }
                        this.currentTokenEnd = this.position;
                    };
                    /**
                     * Eats a multiline token of the form NL;....NL;
                     */
                    CifTokenizer.prototype.eatMultiline = function () {
                        var prev = 59, pos = this.position, c;
                        while (pos < this.length) {
                            c = this.data.charCodeAt(pos);
                            if (c === 59 && (prev === 10 || prev === 13)) {
                                this.position = pos + 1;
                                // get rid of the ;
                                this.currentTokenStart++;
                                // remove trailing newlines
                                pos--;
                                c = this.data.charCodeAt(pos);
                                while (c === 10 || c === 13) {
                                    pos--;
                                    c = this.data.charCodeAt(pos);
                                }
                                this.currentTokenEnd = pos + 1;
                                this.isEscaped = true;
                                return;
                            }
                            else {
                                // handle line numbers
                                if (c === 13) {
                                    this.currentLineNumber++;
                                }
                                else if (c === 10 && prev !== 13) {
                                    this.currentLineNumber++;
                                }
                                prev = c;
                                ++pos;
                            }
                        }
                        this.position = pos;
                        return prev;
                    };
                    /**
                     * Skips until \n or \r occurs -- therefore the newlines get handled by the "skipWhitespace" function.
                     */
                    CifTokenizer.prototype.skipCommentLine = function () {
                        while (this.position < this.length) {
                            var c = this.data.charCodeAt(this.position);
                            if (c === 10 || c === 13) {
                                return;
                            }
                            ++this.position;
                        }
                    };
                    /**
                     * Skips all the whitespace - space, tab, newline, CR
                     * Handles incrementing line count.
                     */
                    CifTokenizer.prototype.skipWhitespace = function () {
                        var prev = 10;
                        while (this.position < this.length) {
                            var c = this.data.charCodeAt(this.position);
                            switch (c) {
                                case 9: // '\t'
                                case 32:
                                    prev = c;
                                    ++this.position;
                                    break;
                                case 10:
                                    // handle \r\n
                                    if (prev !== 13) {
                                        ++this.currentLineNumber;
                                    }
                                    prev = c;
                                    ++this.position;
                                    break;
                                case 13:
                                    prev = c;
                                    ++this.position;
                                    ++this.currentLineNumber;
                                    break;
                                default:
                                    return prev;
                            }
                        }
                        return prev;
                    };
                    CifTokenizer.prototype.isData = function () {
                        // here we already assume the 5th char is _ and that the length >= 5
                        // d/D
                        var c = this.data.charCodeAt(this.currentTokenStart);
                        if (c !== 68 && c !== 100)
                            return false;
                        // a/A
                        c = this.data.charCodeAt(this.currentTokenStart + 1);
                        if (c !== 65 && c !== 97)
                            return false;
                        // t/t
                        c = this.data.charCodeAt(this.currentTokenStart + 2);
                        if (c !== 84 && c !== 116)
                            return false;
                        // a/A
                        c = this.data.charCodeAt(this.currentTokenStart + 3);
                        if (c !== 65 && c !== 97)
                            return false;
                        return true;
                    };
                    CifTokenizer.prototype.isSave = function () {
                        // here we already assume the 5th char is _ and that the length >= 5
                        // s/S
                        var c = this.data.charCodeAt(this.currentTokenStart);
                        if (c !== 83 && c !== 115)
                            return false;
                        // a/A
                        c = this.data.charCodeAt(this.currentTokenStart + 1);
                        if (c !== 65 && c !== 97)
                            return false;
                        // v/V
                        c = this.data.charCodeAt(this.currentTokenStart + 2);
                        if (c !== 86 && c !== 118)
                            return false;
                        // e/E
                        c = this.data.charCodeAt(this.currentTokenStart + 3);
                        if (c !== 69 && c !== 101)
                            return false;
                        return true;
                    };
                    CifTokenizer.prototype.isLoop = function () {
                        // here we already assume the 5th char is _ and that the length >= 5
                        if (this.currentTokenEnd - this.currentTokenStart !== 5)
                            return false;
                        // l/L
                        var c = this.data.charCodeAt(this.currentTokenStart);
                        if (c !== 76 && c !== 108)
                            return false;
                        // o/O
                        c = this.data.charCodeAt(this.currentTokenStart + 1);
                        if (c !== 79 && c !== 111)
                            return false;
                        // o/O
                        c = this.data.charCodeAt(this.currentTokenStart + 2);
                        if (c !== 79 && c !== 111)
                            return false;
                        // p/P
                        c = this.data.charCodeAt(this.currentTokenStart + 3);
                        if (c !== 80 && c !== 112)
                            return false;
                        return true;
                    };
                    /**
                     * Checks if the current token shares the namespace with string at <start,end).
                     */
                    CifTokenizer.prototype.isNamespace = function (start, end) {
                        var i, nsLen = end - start, offset = this.currentTokenStart - start, tokenLen = this.currentTokenEnd - this.currentTokenStart;
                        if (tokenLen < nsLen)
                            return false;
                        for (i = start; i < end; ++i) {
                            if (this.data.charCodeAt(i) !== this.data.charCodeAt(i + offset))
                                return false;
                        }
                        if (nsLen === tokenLen)
                            return true;
                        if (this.data.charCodeAt(i + offset) === 46) {
                            return true;
                        }
                        return false;
                    };
                    /**
                     * Returns the index of '.' in the current token. If no '.' is present, returns currentTokenEnd.
                     */
                    CifTokenizer.prototype.getNamespaceEnd = function () {
                        for (var i = this.currentTokenStart; i < this.currentTokenEnd; ++i) {
                            if (this.data.charCodeAt(i) === 46)
                                return i;
                        }
                        return i;
                    };
                    /**
                     * Get the namespace string. endIndex is obtained by the getNamespaceEnd() function.
                     */
                    CifTokenizer.prototype.getNamespace = function (endIndex) {
                        return this.data.substring(this.currentTokenStart, endIndex);
                    };
                    /**
                     * String representation of the current token.
                     */
                    CifTokenizer.prototype.getTokenString = function () {
                        return this.data.substring(this.currentTokenStart, this.currentTokenEnd);
                    };
                    /**
                     * Move to the next token.
                     */
                    CifTokenizer.prototype.moveNextInternal = function () {
                        var prev = this.skipWhitespace(), c;
                        if (this.position >= this.length) {
                            this.currentTokenType = 6 /* End */;
                            return;
                        }
                        this.currentTokenStart = this.position;
                        this.currentTokenEnd = this.position;
                        this.isEscaped = false;
                        c = this.data.charCodeAt(this.position);
                        switch (c) {
                            case 35:
                                this.skipCommentLine();
                                this.currentTokenType = 5 /* Comment */;
                                break;
                            case 34: // ", escaped value
                            case 39:
                                this.eatEscaped(c);
                                this.currentTokenType = 3 /* Value */;
                                break;
                            case 59:
                                // multiline value must start at the beginning of the line.
                                if (prev === 10 || prev === 13) {
                                    this.eatMultiline();
                                }
                                else {
                                    this.eatValue();
                                }
                                this.currentTokenType = 3 /* Value */;
                                break;
                            default:
                                this.eatValue();
                                // escaped is always Value
                                if (this.isEscaped) {
                                    this.currentTokenType = 3 /* Value */;
                                }
                                else if (this.data.charCodeAt(this.currentTokenStart) === 95) {
                                    this.currentTokenType = 4 /* ColumnName */;
                                }
                                else if (this.currentTokenEnd - this.currentTokenStart >= 5 && this.data.charCodeAt(this.currentTokenStart + 4) === 95) {
                                    if (this.isData())
                                        this.currentTokenType = 0 /* Data */;
                                    else if (this.isSave())
                                        this.currentTokenType = 1 /* Save */;
                                    else if (this.isLoop())
                                        this.currentTokenType = 2 /* Loop */;
                                    else
                                        this.currentTokenType = 3 /* Value */;
                                }
                                else {
                                    this.currentTokenType = 3 /* Value */;
                                }
                                break;
                        }
                    };
                    /**
                     * Moves to the next non-comment token.
                     */
                    CifTokenizer.prototype.moveNext = function () {
                        this.moveNextInternal();
                        while (this.currentTokenType === 5 /* Comment */)
                            this.moveNextInternal();
                    };
                    return CifTokenizer;
                }());
                /**
                 * mmCIF parser.
                 *
                 * Trying to be as close to the specification http://www.iucr.org/resources/cif/spec/version1.1/cifsyntax
                 *
                 * Differences I'm aware of:
                 * - Except keywords (data_, loop_, save_) everything is case sensitive.
                 * - The tokens . and ? are treated the same as the values '.' and '?'.
                 * - Ignores \ in the multiline values:
                 *     ;abc\
                 *     efg
                 *     ;
                 *   should have the value 'abcefg' but will have the value 'abc\\nefg' instead.
                 *   Post processing of this is left to the consumer of the data.
                 * - Similarly, things like punctuation (\', ..) are left to be processed by the user if needed.
                 *
                 */
                var Parser = (function () {
                    function Parser() {
                    }
                    /**
                     * Reads a category containing a single row.
                     */
                    Parser.handleSingle = function (tokenizer, block) {
                        var nsStart = tokenizer.currentTokenStart, nsEnd = tokenizer.getNamespaceEnd(), name = tokenizer.getNamespace(nsEnd), column, columns = [], tokens = new Formats.TokenIndexBuilder(512), tokenCount = 0;
                        while (tokenizer.currentTokenType === 4 /* ColumnName */ && tokenizer.isNamespace(nsStart, nsEnd)) {
                            column = tokenizer.getTokenString();
                            tokenizer.moveNext();
                            if (tokenizer.currentTokenType !== 3 /* Value */) {
                                return {
                                    hasError: true,
                                    errorLine: tokenizer.currentLineNumber,
                                    errorMessage: "Expected value."
                                };
                            }
                            columns[columns.length] = column;
                            tokens.addToken(tokenizer.currentTokenStart, tokenizer.currentTokenEnd);
                            tokenCount++;
                            tokenizer.moveNext();
                        }
                        block.addCategory(new Cif.Category(block.data, name, nsStart, tokenizer.currentTokenStart, columns, tokens.tokens, tokenCount));
                        return {
                            hasError: false,
                            errorLine: 0,
                            errorMessage: ""
                        };
                    };
                    /**
                     * Reads a loop.
                     */
                    Parser.handleLoop = function (tokenizer, block) {
                        var start = tokenizer.currentTokenStart, loopLine = tokenizer.currentLineNumber;
                        tokenizer.moveNext();
                        var name = tokenizer.getNamespace(tokenizer.getNamespaceEnd()), columns = [], tokens = new Formats.TokenIndexBuilder(name === "_atom_site" ? (block.data.length / 1.85) | 0 : 1024), tokenCount = 0;
                        while (tokenizer.currentTokenType === 4 /* ColumnName */) {
                            columns[columns.length] = tokenizer.getTokenString();
                            tokenizer.moveNext();
                        }
                        while (tokenizer.currentTokenType === 3 /* Value */) {
                            tokens.addToken(tokenizer.currentTokenStart, tokenizer.currentTokenEnd);
                            tokenCount++;
                            tokenizer.moveNext();
                        }
                        if (tokenCount % columns.length !== 0) {
                            return {
                                hasError: true,
                                errorLine: tokenizer.currentLineNumber,
                                errorMessage: "The number of values for loop starting at line " + loopLine + " is not a multiple of the number of columns."
                            };
                        }
                        block.addCategory(new Cif.Category(block.data, name, start, tokenizer.currentTokenStart, columns, tokens.tokens, tokenCount));
                        return {
                            hasError: false,
                            errorLine: 0,
                            errorMessage: ""
                        };
                    };
                    /**
                     * Creates an error result.
                     */
                    Parser.error = function (line, message) {
                        return Formats.ParserResult.error(message, line);
                    };
                    /**
                     * Creates a data result.
                     */
                    Parser.result = function (data) {
                        return Formats.ParserResult.success(data);
                    };
                    /**
                     * Parses an mmCIF file.
                     *
                     * @returns CifParserResult wrapper of the result.
                     */
                    Parser.parse = function (data) {
                        var tokenizer = new CifTokenizer(data), cat, id, file = new Cif.File(data), block = new Cif.Block(file, "default"), saveFrame = new Cif.Block(file, "empty"), inSaveFrame = false, blockSaveFrames;
                        tokenizer.moveNext();
                        while (tokenizer.currentTokenType !== 6 /* End */) {
                            var token = tokenizer.currentTokenType;
                            // Data block
                            if (token === 0 /* Data */) {
                                if (inSaveFrame) {
                                    return Parser.error(tokenizer.currentLineNumber, "Unexpected data block inside a save frame.");
                                }
                                if (block.categoryList.length > 0) {
                                    file.addBlock(block);
                                }
                                block = new Cif.Block(file, data.substring(tokenizer.currentTokenStart + 5, tokenizer.currentTokenEnd));
                                tokenizer.moveNext();
                            }
                            else if (token === 1 /* Save */) {
                                id = data.substring(tokenizer.currentTokenStart + 5, tokenizer.currentTokenEnd);
                                if (id.length === 0) {
                                    if (saveFrame.categoryList.length > 0) {
                                        blockSaveFrames = block.additionalData["saveFrames"];
                                        if (!blockSaveFrames) {
                                            blockSaveFrames = [];
                                            block.additionalData["saveFrames"] = blockSaveFrames;
                                        }
                                        blockSaveFrames[blockSaveFrames.length] = saveFrame;
                                    }
                                    inSaveFrame = false;
                                }
                                else {
                                    if (inSaveFrame) {
                                        return Parser.error(tokenizer.currentLineNumber, "Save frames cannot be nested.");
                                    }
                                    inSaveFrame = true;
                                    saveFrame = new Cif.Block(file, id);
                                }
                                tokenizer.moveNext();
                            }
                            else if (token === 2 /* Loop */) {
                                cat = Parser.handleLoop(tokenizer, inSaveFrame ? saveFrame : block);
                                if (cat.hasError) {
                                    return Parser.error(cat.errorLine, cat.errorMessage);
                                }
                            }
                            else if (token === 4 /* ColumnName */) {
                                cat = Parser.handleSingle(tokenizer, inSaveFrame ? saveFrame : block);
                                if (cat.hasError) {
                                    return Parser.error(cat.errorLine, cat.errorMessage);
                                }
                            }
                            else {
                                return Parser.error(tokenizer.currentLineNumber, "Unexpected token. Expected data_, loop_, or data name.");
                            }
                        }
                        // Check if the latest save frame was closed.
                        if (inSaveFrame) {
                            return Parser.error(tokenizer.currentLineNumber, "Unfinished save frame (`" + saveFrame.header + "`).");
                        }
                        if (block.categoryList.length > 0) {
                            file.addBlock(block);
                        }
                        return Parser.result(file);
                    };
                    return Parser;
                }());
                Cif.Parser = Parser;
                function parse(data) {
                    return Parser.parse(data);
                }
                Cif.parse = parse;
            })(Cif = Formats.Cif || (Formats.Cif = {}));
        })(Formats = Core.Formats || (Core.Formats = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Formats;
        (function (Formats) {
            var PDB;
            (function (PDB) {
                "use strict";
                var MoleculeData = (function () {
                    function MoleculeData(header, crystInfo, models, data) {
                        this.header = header;
                        this.crystInfo = crystInfo;
                        this.models = models;
                        this.data = data;
                    }
                    MoleculeData.prototype.makeEntities = function () {
                        var data = [
                            "data_ent",
                            "loop_",
                            "_entity.id",
                            "_entity.type",
                            "_entity.src_method",
                            "_entity.pdbx_description",
                            "_entity.formula_weight",
                            "_entity.pdbx_number_of_molecules",
                            "_entity.details",
                            "_entity.pdbx_mutation",
                            "_entity.pdbx_fragment",
                            "_entity.pdbx_ec",
                            "1 polymer man polymer 0.0 0 ? ? ? ?",
                            "2 non-polymer syn non-polymer 0.0 0 ? ? ? ?",
                            "3 water nat water 0.0 0 ? ? ? ?"
                        ].join('\n');
                        return Formats.Cif.parse(data).result.dataBlocks[0].getCategory('_entity');
                    };
                    MoleculeData.prototype.toCifFile = function () {
                        var helpers = {
                            dot: PDB.Parser.getDotRange(this.data.length),
                            question: PDB.Parser.getQuestionmarkRange(this.data.length),
                            numberTokens: PDB.Parser.getNumberRanges(this.data.length),
                            data: this.data
                        };
                        var file = new Formats.Cif.File(this.data);
                        var block = new Formats.Cif.Block(file, this.header.id);
                        file.dataBlocks.push(block);
                        block.addCategory(this.makeEntities());
                        if (this.crystInfo) {
                            var _a = this.crystInfo.toCifCategory(this.header.id), cell = _a.cell, symm = _a.symm;
                            block.addCategory(cell);
                            block.addCategory(symm);
                        }
                        block.addCategory(this.models.toCifCategory(block, helpers));
                        return file;
                    };
                    return MoleculeData;
                }());
                PDB.MoleculeData = MoleculeData;
                var Header = (function () {
                    function Header(id) {
                        this.id = id;
                    }
                    return Header;
                }());
                PDB.Header = Header;
                var CrystStructureInfo = (function () {
                    function CrystStructureInfo(record) {
                        this.record = record;
                    }
                    CrystStructureInfo.prototype.toCifCategory = function (id) {
                        //COLUMNS       DATA TYPE      CONTENTS
                        //--------------------------------------------------------------------------------
                        //    1 - 6       Record name    "CRYST1"
                        //7 - 15       Real(9.3)      a (Angstroms)
                        //16 - 24       Real(9.3)      b (Angstroms)
                        //25 - 33       Real(9.3)      c (Angstroms)
                        //34 - 40       Real(7.2)      alpha (degrees)
                        //41 - 47       Real(7.2)      beta (degrees)
                        //48 - 54       Real(7.2)      gamma (degrees)
                        //56 - 66       LString        Space group       
                        //67 - 70       Integer        Z value           
                        var data = [
                            ("_cell.entry_id           '" + id + "'"),
                            ("_cell.length_a           " + this.record.substr(6, 9).trim()),
                            ("_cell.length_b           " + this.record.substr(15, 9).trim()),
                            ("_cell.length_c           " + this.record.substr(24, 9).trim()),
                            ("_cell.angle_alpha        " + this.record.substr(33, 7).trim()),
                            ("_cell.angle_beta         " + this.record.substr(40, 7).trim()),
                            ("_cell.angle_gamma        " + this.record.substr(48, 7).trim()),
                            ("_cell.Z_PDB              " + this.record.substr(66, 4).trim()),
                            "_cell.pdbx_unique_axis   ?",
                            ("_symmetry.entry_id                         '" + id + "'"),
                            ("_symmetry.space_group_name_H-M             '" + this.record.substr(55, 11).trim() + "'"),
                            "_symmetry.pdbx_full_space_group_name_H-M   ?",
                            "_symmetry.cell_setting                     ?",
                            "_symmetry.Int_Tables_number                ?",
                            "_symmetry.space_group_name_Hall            ?"
                        ].join('\n');
                        var cif = Formats.Cif.parse(data).result.dataBlocks[0];
                        return {
                            cell: cif.getCategory('_cell'),
                            symm: cif.getCategory('_symmetry')
                        };
                    };
                    return CrystStructureInfo;
                }());
                PDB.CrystStructureInfo = CrystStructureInfo;
                var SecondaryStructure = (function () {
                    function SecondaryStructure(helixTokens, sheetTokens) {
                        this.helixTokens = helixTokens;
                        this.sheetTokens = sheetTokens;
                    }
                    SecondaryStructure.prototype.toCifCategory = function (data) {
                        return null;
                    };
                    return SecondaryStructure;
                }());
                PDB.SecondaryStructure = SecondaryStructure;
                var ModelData = (function () {
                    function ModelData(idToken, atomTokens, atomCount) {
                        this.idToken = idToken;
                        this.atomTokens = atomTokens;
                        this.atomCount = atomCount;
                    }
                    ModelData.prototype.writeToken = function (index, cifTokens) {
                        cifTokens.add2(this.atomTokens[2 * index], this.atomTokens[2 * index + 1]);
                    };
                    ModelData.prototype.writeTokenCond = function (index, cifTokens, dot) {
                        var s = this.atomTokens[2 * index];
                        var e = this.atomTokens[2 * index + 1];
                        if (s === e)
                            cifTokens.add2(dot.start, dot.end);
                        else
                            cifTokens.add2(s, e);
                    };
                    ModelData.prototype.writeRange = function (range, cifTokens) {
                        cifTokens.add2(range.start, range.end);
                    };
                    ModelData.prototype.tokenEquals = function (start, end, value, data) {
                        var len = value.length;
                        if (len !== end - start)
                            return false;
                        for (var i = value.length - 1; i >= 0; i--) {
                            if (data.charCodeAt(i + start) !== value.charCodeAt(i)) {
                                return false;
                            }
                        }
                        return true;
                    };
                    ModelData.prototype.getEntityType = function (row, data) {
                        var o = row * 14;
                        if (this.tokenEquals(this.atomTokens[2 * o], this.atomTokens[2 * o + 1], "HETATM", data)) {
                            var s = this.atomTokens[2 * (o + 4)], e = this.atomTokens[2 * (o + 4) + 1];
                            if (this.tokenEquals(s, e, "HOH", data) || this.tokenEquals(s, e, "WTR", data) || this.tokenEquals(s, e, "SOL", data)) {
                                return 3; // water
                            }
                            return 2; // non-polymer
                        }
                        else {
                            return 1; // polymer
                        }
                    };
                    ModelData.prototype.writeCifTokens = function (modelToken, cifTokens, helpers) {
                        var columnIndices = {
                            //COLUMNS        DATA TYPE       CONTENTS                            
                            //--------------------------------------------------------------------------------
                            // 1 -  6        Record name     "ATOM  "                                          
                            RECORD: 0,
                            // 7 - 11        Integer         Atom serial number.                   
                            SERIAL: 1,
                            //13 - 16        Atom            Atom name.          
                            ATOM_NAME: 2,
                            //17             Character       Alternate location indicator. 
                            ALT_LOC: 3,
                            //18 - 20        Residue name    Residue name.       
                            RES_NAME: 4,
                            //22             Character       Chain identifier.         
                            CHAIN_ID: 5,
                            //23 - 26        Integer         Residue sequence number.              
                            RES_SEQN: 6,
                            //27             AChar           Code for insertion of residues.       
                            INS_CODE: 7,
                            //31 - 38        Real(8.3)       Orthogonal coordinates for X in Angstroms.   
                            X: 8,
                            //39 - 46        Real(8.3)       Orthogonal coordinates for Y in Angstroms.                            
                            Y: 9,
                            //47 - 54        Real(8.3)       Orthogonal coordinates for Z in Angstroms.        
                            Z: 10,
                            //55 - 60        Real(6.2)       Occupancy.       
                            OCCUPANCY: 11,
                            //61 - 66        Real(6.2)       Temperature factor (Default = 0.0).                   
                            TEMP_FACTOR: 12,
                            //73 - 76        LString(4)      Segment identifier, left-justified.   
                            // ignored
                            //77 - 78        LString(2)      Element symbol, right-justified.   
                            ELEMENT: 13
                        };
                        var columnCount = 14;
                        for (var i = 0; i < this.atomCount; i++) {
                            var o = i * columnCount;
                            //_atom_site.group_PDB
                            this.writeToken(o + columnIndices.RECORD, cifTokens);
                            //_atom_site.id
                            this.writeToken(o + columnIndices.SERIAL, cifTokens);
                            //_atom_site.type_symbol
                            this.writeToken(o + columnIndices.ELEMENT, cifTokens);
                            //_atom_site.label_atom_id
                            this.writeToken(o + columnIndices.ATOM_NAME, cifTokens);
                            //_atom_site.label_alt_id
                            this.writeTokenCond(o + columnIndices.ALT_LOC, cifTokens, helpers.dot);
                            //_atom_site.label_comp_id
                            this.writeToken(o + columnIndices.RES_NAME, cifTokens);
                            //_atom_site.label_asym_id
                            this.writeToken(o + columnIndices.CHAIN_ID, cifTokens);
                            //_atom_site.label_entity_id
                            this.writeRange(helpers.numberTokens.get(this.getEntityType(i, helpers.data)), cifTokens);
                            //_atom_site.label_seq_id
                            this.writeToken(o + columnIndices.RES_SEQN, cifTokens);
                            //_atom_site.pdbx_PDB_ins_code
                            this.writeTokenCond(o + columnIndices.INS_CODE, cifTokens, helpers.dot);
                            //_atom_site.Cartn_x
                            this.writeToken(o + columnIndices.X, cifTokens);
                            //_atom_site.Cartn_y
                            this.writeToken(o + columnIndices.Y, cifTokens);
                            //_atom_site.Cartn_z
                            this.writeToken(o + columnIndices.Z, cifTokens);
                            //_atom_site.occupancy
                            this.writeToken(o + columnIndices.OCCUPANCY, cifTokens);
                            //_atom_site.B_iso_or_equiv
                            this.writeToken(o + columnIndices.TEMP_FACTOR, cifTokens);
                            //_atom_site.Cartn_x_esd
                            this.writeRange(helpers.question, cifTokens);
                            //_atom_site.Cartn_y_esd
                            this.writeRange(helpers.question, cifTokens);
                            //_atom_site.Cartn_z_esd
                            this.writeRange(helpers.question, cifTokens);
                            //_atom_site.occupancy_esd
                            this.writeRange(helpers.question, cifTokens);
                            //_atom_site.B_iso_or_equiv_esd
                            this.writeRange(helpers.question, cifTokens);
                            //_atom_site.pdbx_formal_charge
                            this.writeRange(helpers.question, cifTokens);
                            //_atom_site.auth_seq_id
                            this.writeToken(o + columnIndices.RES_SEQN, cifTokens);
                            //_atom_site.auth_comp_id
                            this.writeToken(o + columnIndices.RES_NAME, cifTokens);
                            //_atom_site.auth_asym_id
                            this.writeToken(o + columnIndices.CHAIN_ID, cifTokens);
                            //_atom_site.auth_atom_id
                            this.writeToken(o + columnIndices.ATOM_NAME, cifTokens);
                            //_atom_site.pdbx_PDB_model_num 
                            this.writeRange(modelToken, cifTokens);
                        }
                    };
                    ModelData.COLUMNS = [
                        "_atom_site.group_PDB",
                        "_atom_site.id",
                        "_atom_site.type_symbol",
                        "_atom_site.label_atom_id",
                        "_atom_site.label_alt_id",
                        "_atom_site.label_comp_id",
                        "_atom_site.label_asym_id",
                        "_atom_site.label_entity_id",
                        "_atom_site.label_seq_id",
                        "_atom_site.pdbx_PDB_ins_code",
                        "_atom_site.Cartn_x",
                        "_atom_site.Cartn_y",
                        "_atom_site.Cartn_z",
                        "_atom_site.occupancy",
                        "_atom_site.B_iso_or_equiv",
                        "_atom_site.Cartn_x_esd",
                        "_atom_site.Cartn_y_esd",
                        "_atom_site.Cartn_z_esd",
                        "_atom_site.occupancy_esd",
                        "_atom_site.B_iso_or_equiv_esd",
                        "_atom_site.pdbx_formal_charge",
                        "_atom_site.auth_seq_id",
                        "_atom_site.auth_comp_id",
                        "_atom_site.auth_asym_id",
                        "_atom_site.auth_atom_id",
                        "_atom_site.pdbx_PDB_model_num"
                    ];
                    return ModelData;
                }());
                PDB.ModelData = ModelData;
                var ModelsData = (function () {
                    function ModelsData(models) {
                        this.models = models;
                    }
                    ModelsData.prototype.toCifCategory = function (block, helpers) {
                        var atomCount = 0;
                        for (var _i = 0, _a = this.models; _i < _a.length; _i++) {
                            var m = _a[_i];
                            atomCount += m.atomCount;
                        }
                        var colCount = 26;
                        var tokens = Core.Utils.ArrayBuilder.forTokenIndices(atomCount * 26);
                        for (var _b = 0, _c = this.models; _b < _c.length; _b++) {
                            var m = _c[_b];
                            m.writeCifTokens(m.idToken, tokens, helpers);
                        }
                        return new Formats.Cif.Category(block.data, "_atom_site", 0, 0, ModelData.COLUMNS, tokens.array, atomCount * 26);
                    };
                    return ModelsData;
                }());
                PDB.ModelsData = ModelsData;
            })(PDB = Formats.PDB || (Formats.PDB = {}));
        })(Formats = Core.Formats || (Core.Formats = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Formats;
        (function (Formats) {
            var PDB;
            (function (PDB) {
                "use strict";
                var Tokenizer = (function () {
                    function Tokenizer(data) {
                        this.data = data;
                        this.trimmedToken = { start: 0, end: 0 };
                        this.line = 0;
                        this.position = 0;
                        this.length = data.length;
                    }
                    Tokenizer.prototype.moveToNextLine = function () {
                        while (this.position < this.length && this.data.charCodeAt(this.position) !== 10) {
                            this.position++;
                        }
                        this.position++;
                        this.line++;
                        return this.position;
                    };
                    Tokenizer.prototype.moveToEndOfLine = function () {
                        while (this.position < this.length) {
                            var c = this.data.charCodeAt(this.position);
                            if (c === 10 || c === 13) {
                                return this.position;
                            }
                            this.position++;
                        }
                        return this.position;
                    };
                    Tokenizer.prototype.startsWith = function (start, value) {
                        for (var i = value.length - 1; i >= 0; i--) {
                            if (this.data.charCodeAt(i + start) !== value.charCodeAt(i)) {
                                return false;
                            }
                        }
                        return true;
                    };
                    Tokenizer.prototype.trim = function (start, end) {
                        while (start < end && this.data.charCodeAt(start) === 32)
                            start++;
                        while (end > start && this.data.charCodeAt(end - 1) === 32)
                            end--;
                        this.trimmedToken.start = start;
                        this.trimmedToken.end = end;
                    };
                    Tokenizer.prototype.tokenizeAtomRecord = function (tokens) {
                        var startPos = this.position;
                        var start = this.position;
                        var end = this.moveToEndOfLine();
                        var length = end - start;
                        // invalid atom record
                        if (length < 66)
                            return false;
                        //COLUMNS        DATA TYPE       CONTENTS                            
                        //--------------------------------------------------------------------------------
                        // 1 -  6        Record name     "ATOM  "                                            
                        this.trim(start, start + 6);
                        tokens.addToken(this.trimmedToken.start, this.trimmedToken.end);
                        // 7 - 11        Integer         Atom serial number.                   
                        start = startPos + 6;
                        this.trim(start, start + 5);
                        tokens.addToken(this.trimmedToken.start, this.trimmedToken.end);
                        //13 - 16        Atom            Atom name.          
                        start = startPos + 12;
                        this.trim(start, start + 4);
                        tokens.addToken(this.trimmedToken.start, this.trimmedToken.end);
                        //17             Character       Alternate location indicator. 
                        if (this.data.charCodeAt(startPos + 16) === 32) {
                            tokens.addToken(0, 0);
                        }
                        else {
                            tokens.addToken(startPos + 16, startPos + 17);
                        }
                        //18 - 20        Residue name    Residue name.       
                        start = startPos + 17;
                        this.trim(start, start + 3);
                        tokens.addToken(this.trimmedToken.start, this.trimmedToken.end);
                        //22             Character       Chain identifier.         
                        tokens.addToken(startPos + 21, startPos + 22);
                        //23 - 26        Integer         Residue sequence number.              
                        start = startPos + 22;
                        this.trim(start, start + 3);
                        tokens.addToken(this.trimmedToken.start, this.trimmedToken.end);
                        //27             AChar           Code for insertion of residues.      
                        if (this.data.charCodeAt(startPos + 26) === 32) {
                            tokens.addToken(0, 0);
                        }
                        else {
                            tokens.addToken(startPos + 26, startPos + 27);
                        }
                        //31 - 38        Real(8.3)       Orthogonal coordinates for X in Angstroms.   
                        start = startPos + 30;
                        this.trim(start, start + 8);
                        tokens.addToken(this.trimmedToken.start, this.trimmedToken.end);
                        //39 - 46        Real(8.3)       Orthogonal coordinates for Y in Angstroms.                            
                        start = startPos + 38;
                        this.trim(start, start + 8);
                        tokens.addToken(this.trimmedToken.start, this.trimmedToken.end);
                        //47 - 54        Real(8.3)       Orthogonal coordinates for Z in Angstroms.        
                        start = startPos + 46;
                        this.trim(start, start + 8);
                        tokens.addToken(this.trimmedToken.start, this.trimmedToken.end);
                        //55 - 60        Real(6.2)       Occupancy.       
                        start = startPos + 54;
                        this.trim(start, start + 6);
                        tokens.addToken(this.trimmedToken.start, this.trimmedToken.end);
                        //61 - 66        Real(6.2)       Temperature factor (Default = 0.0).                   
                        start = startPos + 60;
                        this.trim(start, start + 6);
                        tokens.addToken(this.trimmedToken.start, this.trimmedToken.end);
                        //73 - 76        LString(4)      Segment identifier, left-justified.   
                        // ignored
                        //77 - 78        LString(2)      Element symbol, right-justified.   
                        if (length >= 78) {
                            start = startPos + 76;
                            this.trim(start, start + 2);
                            if (this.trimmedToken.start < this.trimmedToken.end) {
                                tokens.addToken(this.trimmedToken.start, this.trimmedToken.end);
                            }
                            else {
                                tokens.addToken(startPos + 12, startPos + 13);
                            }
                        }
                        //79 - 80        LString(2)      Charge on the atom.      
                        // ignored
                        return true;
                    };
                    return Tokenizer;
                }());
                var Parser = (function () {
                    function Parser(id, data) {
                        this.id = id;
                        this.data = data;
                    }
                    Parser.tokenizeAtom = function (tokens, tokenizer) {
                        if (tokenizer.tokenizeAtomRecord(tokens)) {
                            return undefined;
                        }
                        return new Formats.ParserError("Invalid ATOM/HETATM record.", tokenizer.line);
                    };
                    Parser.tokenize = function (id, data) {
                        var tokenizer = new Tokenizer(data);
                        var length = data.length;
                        var modelAtomTokens = new Formats.TokenIndexBuilder(4096); //2 * 14 * this.data.length / 78);
                        var atomCount = 0;
                        var models = [];
                        var cryst = undefined;
                        var modelIdToken = { start: 0, end: 0 };
                        while (tokenizer.position < length) {
                            var cont = true;
                            switch (data.charCodeAt(tokenizer.position)) {
                                case 65:
                                    if (tokenizer.startsWith(tokenizer.position, "ATOM")) {
                                        var err = Parser.tokenizeAtom(modelAtomTokens, tokenizer);
                                        atomCount++;
                                        if (err)
                                            return err;
                                    }
                                    break;
                                case 67:
                                    if (tokenizer.startsWith(tokenizer.position, "CRYST1")) {
                                        var start = tokenizer.position;
                                        var end = tokenizer.moveToEndOfLine();
                                        cryst = new PDB.CrystStructureInfo(data.substring(start, end));
                                    }
                                    break;
                                case 69:
                                    if (tokenizer.startsWith(tokenizer.position, "ENDMDL") && atomCount > 0) {
                                        if (models.length === 0) {
                                            modelIdToken = { start: data.length + 3, end: data.length + 4 };
                                        }
                                        models.push(new PDB.ModelData(modelIdToken, modelAtomTokens.tokens, atomCount));
                                        atomCount = 0;
                                        modelAtomTokens = null;
                                    }
                                    else if (tokenizer.startsWith(tokenizer.position, "END")) {
                                        var start = tokenizer.position;
                                        var end = tokenizer.moveToEndOfLine();
                                        tokenizer.trim(start, end);
                                        if (tokenizer.trimmedToken.end - tokenizer.trimmedToken.start === 3) {
                                            cont = false;
                                        }
                                    }
                                    break;
                                case 72:
                                    if (tokenizer.startsWith(tokenizer.position, "HETATM")) {
                                        var err = Parser.tokenizeAtom(modelAtomTokens, tokenizer);
                                        atomCount++;
                                        if (err)
                                            return err;
                                    }
                                    break;
                                case 77:
                                    if (tokenizer.startsWith(tokenizer.position, "MODEL")) {
                                        if (atomCount > 0) {
                                            if (models.length === 0) {
                                                modelIdToken = { start: data.length + 3, end: data.length + 4 };
                                            }
                                            models.push(new PDB.ModelData(modelIdToken, modelAtomTokens.tokens, atomCount));
                                        }
                                        var start = tokenizer.position + 6;
                                        var end = tokenizer.moveToEndOfLine();
                                        tokenizer.trim(start, end);
                                        modelIdToken = { start: tokenizer.trimmedToken.start, end: tokenizer.trimmedToken.end };
                                        if (atomCount > 0 || !modelAtomTokens) {
                                            modelAtomTokens = new Formats.TokenIndexBuilder(4096);
                                        }
                                        atomCount = 0;
                                    }
                                    break;
                            }
                            tokenizer.moveToNextLine();
                            if (!cont)
                                break;
                        }
                        var fakeCifData = data + ".?0123";
                        if (atomCount > 0) {
                            if (models.length === 0) {
                                modelIdToken = { start: data.length + 3, end: data.length + 4 };
                            }
                            models.push(new PDB.ModelData(modelIdToken, modelAtomTokens.tokens, atomCount));
                        }
                        return new PDB.MoleculeData(new PDB.Header(id), cryst, new PDB.ModelsData(models), fakeCifData);
                    };
                    Parser.getDotRange = function (length) {
                        return { start: length - 6, end: length - 5 };
                    };
                    Parser.getNumberRanges = function (length) {
                        var ret = new Map();
                        for (var i = 0; i < 4; i++) {
                            ret.set(i, { start: length - 4 + i, end: length - 3 + i });
                        }
                        return ret;
                    };
                    Parser.getQuestionmarkRange = function (length) {
                        return { start: length - 5, end: length - 4 };
                    };
                    Parser.parse = function (id, data) {
                        var ret = Parser.tokenize(id, data);
                        if (ret instanceof Formats.ParserError) {
                            return Formats.ParserResult.error(ret.message, ret.line);
                        }
                        else {
                            return Formats.ParserResult.success(ret.toCifFile());
                        }
                    };
                    return Parser;
                }());
                PDB.Parser = Parser;
                function parse(id, data) {
                    return Parser.parse(id, data);
                }
                PDB.parse = parse;
            })(PDB = Formats.PDB || (Formats.PDB = {}));
        })(Formats = Core.Formats || (Core.Formats = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Formats;
        (function (Formats) {
            var CCP4;
            (function (CCP4) {
                /**
                 * Represents electron density data from the CCP4 format.
                 */
                var ElectronDensityData = (function () {
                    function ElectronDensityData(cellSize, cellAngles, origin, hasSkewMatrix, skewMatrix, data, dataDimensions, basis, startOffset, valuesInfo) {
                        this.cellSize = cellSize;
                        this.cellAngles = cellAngles;
                        this.origin = origin;
                        this.hasSkewMatrix = hasSkewMatrix;
                        this.skewMatrix = skewMatrix;
                        this.data = data;
                        this.basis = basis;
                        this.startOffset = startOffset;
                        this.dataDimensions = dataDimensions;
                        this.valuesInfo = valuesInfo;
                    }
                    return ElectronDensityData;
                }());
                CCP4.ElectronDensityData = ElectronDensityData;
                var ParserResult = (function () {
                    function ParserResult(hasError, errorMessage, errorLine, warnings, result) {
                        this.hasError = hasError;
                        this.errorMessage = errorMessage;
                        this.errorLine = errorLine;
                        this.warnings = warnings;
                        this.result = result;
                    }
                    ParserResult.error = function (message, line) {
                        if (line === void 0) { line = -1; }
                        return new ParserResult(true, message, line, [], undefined);
                    };
                    ParserResult.success = function (result, warnings) {
                        if (warnings === void 0) { warnings = []; }
                        return new ParserResult(false, "", -1, warnings, result);
                    };
                    return ParserResult;
                }());
                CCP4.ParserResult = ParserResult;
                /**
                 * Parses CCP4 files.
                 */
                var Parser = (function () {
                    function Parser() {
                    }
                    Parser.getArray = function (r, offset, count) {
                        var ret = [];
                        for (var i = 0; i < count; i++) {
                            ret[i] = r(offset + i);
                        }
                        return ret;
                    };
                    /**
                     * Parse CCP4 file according to spec at http://www.ccp4.ac.uk/html/maplib.html
                     * Inspired by PyMOL implementation of the parser.
                     */
                    Parser.parse = function (buffer, options) {
                        if (options === void 0) { options = { normalize: true }; }
                        var headerSize = 1024, endian = false, headerView = new DataView(buffer, 0, headerSize), warnings = [];
                        var mode = headerView.getInt32(3 * 4, false);
                        if (mode !== 2) {
                            endian = true;
                            mode = headerView.getInt32(3 * 4, true);
                            if (mode !== 2) {
                                return ParserResult.error("Only CCP4 modes 0 and 2 are supported.");
                            }
                        }
                        var readInt = function (o) { return headerView.getInt32(o * 4, endian); }, readFloat = function (o) { return headerView.getFloat32(o * 4, endian); };
                        var header = {
                            extent: Parser.getArray(readInt, 0, 3),
                            mode: mode,
                            nxyzStart: Parser.getArray(readInt, 4, 3),
                            grid: Parser.getArray(readInt, 7, 3),
                            cellDimensions: Parser.getArray(readFloat, 10, 3),
                            cellAngles: Parser.getArray(readFloat, 13, 3),
                            crs2xyz: Parser.getArray(readInt, 16, 3),
                            min: readFloat(19),
                            max: readFloat(20),
                            mean: readFloat(21),
                            symBytes: readInt(23),
                            skewFlag: readInt(24),
                            skewMatrix: Parser.getArray(readFloat, 25, 9),
                            skewTranslation: Parser.getArray(readFloat, 34, 3),
                            origin2k: Parser.getArray(readFloat, 49, 3)
                        };
                        var dataOffset = buffer.byteLength - 4 * header.extent[0] * header.extent[1] * header.extent[2];
                        if (dataOffset !== headerSize + header.symBytes) {
                            if (dataOffset === headerSize) {
                                warnings.push("File contains bogus symmetry record.");
                            }
                            else if (dataOffset < headerSize) {
                                return ParserResult.error("File appears truncated and doesn't match header.");
                            }
                            else if ((dataOffset > headerSize) && (dataOffset < (1024 * 1024))) {
                                // Fix for loading SPIDER files which are larger than usual
                                // In this specific case, we must absolutely trust the symBytes record
                                dataOffset = headerSize + header.symBytes;
                                warnings.push("File is larger than expected and doesn't match header. Continuing file load, good luck!");
                            }
                            else {
                                return ParserResult.error("File is MUCH larger than expected and doesn't match header.");
                            }
                        }
                        //let mapp = readInt(52);
                        //let mapStr = String.fromCharCode((mapp & 0xFF)) + String.fromCharCode(((mapp >> 8) & 0xFF)) + String.fromCharCode(((mapp >> 16) & 0xFF)) + String.fromCharCode(((mapp >> 24) & 0xFF));
                        // pretend we've checked the MAP string at offset 52
                        // pretend we've read the symmetry data
                        if (header.grid[0] === 0 && header.extent[0] > 0) {
                            header.grid[0] = header.extent[0] - 1;
                            warnings.push("Fixed X interval count.");
                        }
                        if (header.grid[1] === 0 && header.extent[1] > 0) {
                            header.grid[1] = header.extent[1] - 1;
                            warnings.push("Fixed Y interval count.");
                        }
                        if (header.grid[2] === 0 && header.extent[2] > 0) {
                            header.grid[2] = header.extent[2] - 1;
                            warnings.push("Fixed Z interval count.");
                        }
                        if (header.crs2xyz[0] === 0 && header.crs2xyz[1] === 0 && header.crs2xyz[2] === 0) {
                            warnings.push("All crs2xyz records are zero. Setting crs2xyz to 1, 2, 3.");
                            header.crs2xyz = [1, 2, 3];
                        }
                        if (header.cellDimensions[0] === 0.0 &&
                            header.cellDimensions[1] === 0.0 &&
                            header.cellDimensions[2] === 0.0) {
                            warnings.push("Cell dimensions are all zero. Setting to 1.0, 1.0, 1.0. Map file will not align with other structures.");
                            header.cellDimensions[0] = 1.0;
                            header.cellDimensions[1] = 1.0;
                            header.cellDimensions[2] = 1.0;
                        }
                        var alpha = (Math.PI / 180.0) * header.cellAngles[0], beta = (Math.PI / 180.0) * header.cellAngles[1], gamma = (Math.PI / 180.0) * header.cellAngles[2];
                        var xScale = header.cellDimensions[0] / header.grid[0], yScale = header.cellDimensions[1] / header.grid[1], zScale = header.cellDimensions[2] / header.grid[2];
                        var z1 = Math.cos(beta), z2 = (Math.cos(alpha) - Math.cos(beta) * Math.cos(gamma)) / Math.sin(gamma), z3 = Math.sqrt(1.0 - z1 * z1 - z2 * z2);
                        var xAxis = [xScale, 0.0, 0.0], yAxis = [Math.cos(gamma) * yScale, Math.sin(gamma) * yScale, 0.0], zAxis = [z1 * zScale, z2 * zScale, z3 * zScale];
                        var indices = [0, 0, 0];
                        indices[header.crs2xyz[0] - 1] = 0;
                        indices[header.crs2xyz[1] - 1] = 1;
                        indices[header.crs2xyz[2] - 1] = 2;
                        var origin;
                        if (header.origin2k[0] === 0.0 && header.origin2k[1] === 0.0 && header.origin2k[2] === 0.0) {
                            origin = [
                                xAxis[0] * header.nxyzStart[indices[0]] + yAxis[0] * header.nxyzStart[indices[1]] + zAxis[0] * header.nxyzStart[indices[2]],
                                yAxis[1] * header.nxyzStart[indices[1]] + zAxis[1] * header.nxyzStart[indices[2]],
                                zAxis[2] * header.nxyzStart[indices[2]]
                            ];
                        }
                        else {
                            // Use ORIGIN records rather than old n[xyz]start records
                            //   http://www2.mrc-lmb.cam.ac.uk/image2000.html
                            // XXX the ORIGIN field is only used by the EM community, and
                            //     has undefined meaning for non-orthogonal maps and/or
                            //     non-cubic voxels, etc.
                            origin = [header.origin2k[indices[0]], header.origin2k[indices[1]], header.origin2k[indices[2]]];
                        }
                        var extent = [header.extent[indices[0]], header.extent[indices[1]], header.extent[indices[2]]];
                        var skewMatrix = new Float32Array(16), i, j;
                        for (i = 0; i < 3; i++) {
                            for (j = 0; j < 3; j++) {
                                skewMatrix[4 * j + i] = header.skewMatrix[3 * i + j];
                            }
                            skewMatrix[12 + i] = header.skewTranslation[i];
                        }
                        var nativeEndian = new Uint16Array(new Uint8Array([0x12, 0x34]).buffer)[0] === 0x3412;
                        var rawData = endian === nativeEndian
                            ? Parser.readRawData1(new Float32Array(buffer, headerSize + header.symBytes, extent[0] * extent[1] * extent[2]), endian, extent, header.extent, indices, header.mean)
                            : Parser.readRawData(new DataView(buffer, headerSize + header.symBytes), endian, extent, header.extent, indices, header.mean);
                        var bounds = !options.normalize
                            ? { min: header.min, max: header.max }
                            : Parser.normalizeData(rawData.data, header.mean, rawData.sigma);
                        var data = new ElectronDensityData(header.cellDimensions, header.cellAngles, origin, header.skewFlag !== 0, skewMatrix, rawData.data, extent, { x: xAxis, y: yAxis, z: zAxis }, [header.nxyzStart[indices[0]], header.nxyzStart[indices[1]], header.nxyzStart[indices[2]]], { min: bounds.min, max: bounds.max, mean: header.mean, sigma: rawData.sigma });
                        return ParserResult.success(data, warnings);
                    };
                    Parser.normalizeData = function (data, mean, stddev) {
                        var min = Number.POSITIVE_INFINITY, max = Number.NEGATIVE_INFINITY;
                        for (var i = 0, _l = data.length; i < _l; i++) {
                            var v = (data[i] - mean) / stddev;
                            data[i] = v;
                            if (v < min)
                                min = v;
                            if (v > max)
                                max = v;
                        }
                        return { min: min, max: max };
                    };
                    Parser.readRawData1 = function (view, endian, extent, headerExtent, indices, mean) {
                        var data = new Float32Array(extent[0] * extent[1] * extent[2]), coord = [0, 0, 0], mX, mY, mZ, cX, cY, cZ, xSize, xySize, offset = 0, v = 0.1, sigma = 0.0, t = 0.1, iX = indices[0], iY = indices[1], iZ = indices[2];
                        //mX = extent[indices[0]];
                        //mY = extent[indices[1]];  
                        //mZ = extent[indices[2]];
                        mX = headerExtent[0];
                        mY = headerExtent[1];
                        mZ = headerExtent[2];
                        xSize = extent[0];
                        xySize = extent[0] * extent[1];
                        for (cZ = 0; cZ < mZ; cZ++) {
                            coord[2] = cZ;
                            for (cY = 0; cY < mY; cY++) {
                                coord[1] = cY;
                                for (cX = 0; cX < mX; cX++) {
                                    coord[0] = cX;
                                    v = view[offset];
                                    t = v - mean;
                                    sigma += t * t,
                                        data[coord[iX] + coord[iY] * xSize + coord[iZ] * xySize] = v;
                                    offset += 1;
                                }
                            }
                        }
                        sigma /= mX * mY * mZ;
                        sigma = Math.sqrt(sigma);
                        return {
                            data: data,
                            sigma: sigma
                        };
                    };
                    Parser.readRawData = function (view, endian, extent, headerExtent, indices, mean) {
                        var data = new Float32Array(extent[0] * extent[1] * extent[2]), coord = [0, 0, 0], mX, mY, mZ, cX, cY, cZ, xSize, xySize, offset = 0, v = 0.1, sigma = 0.0, t = 0.1, iX = indices[0], iY = indices[1], iZ = indices[2];
                        mX = headerExtent[0];
                        mY = headerExtent[1];
                        mZ = headerExtent[2];
                        xSize = extent[0];
                        xySize = extent[0] * extent[1];
                        for (cZ = 0; cZ < mZ; cZ++) {
                            coord[2] = cZ;
                            for (cY = 0; cY < mY; cY++) {
                                coord[1] = cY;
                                for (cX = 0; cX < mX; cX++) {
                                    coord[0] = cX;
                                    v = view.getFloat32(offset, endian);
                                    t = v - mean;
                                    sigma += t * t,
                                        data[coord[iX] + coord[iY] * xSize + coord[iZ] * xySize] = v;
                                    offset += 4;
                                }
                            }
                        }
                        sigma /= mX * mY * mZ;
                        sigma = Math.sqrt(sigma);
                        return {
                            data: data,
                            sigma: sigma
                        };
                    };
                    return Parser;
                }());
                CCP4.Parser = Parser;
            })(CCP4 = Formats.CCP4 || (Formats.CCP4 = {}));
        })(Formats = Core.Formats || (Core.Formats = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Geometry;
        (function (Geometry) {
            var LinearAlgebra;
            (function (LinearAlgebra) {
                /*
                 * This code has been modified from https://github.com/toji/gl-matrix/,
                 * copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.
                 *
                 * Permission is hereby granted, free of charge, to any person obtaining a copy
                 * of this software and associated documentation files (the "Software"), to deal
                 * in the Software without restriction, including without limitation the rights
                 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                 * copies of the Software, and to permit persons to whom the Software is
                 * furnished to do so, subject to the following conditions:
                 */
                var makeArray = (typeof Float64Array !== 'undefined')
                    ? function (size) { return (new Float64Array(size)); }
                    : function (size) { return []; };
                /**
                 * Stores a 4x4 matrix in a column major (j * 4 + i indexing) format.
                 */
                var Matrix4 = (function () {
                    function Matrix4() {
                    }
                    Matrix4.empty = function () {
                        return makeArray(16);
                    };
                    Matrix4.identity = function () {
                        var out = makeArray(16);
                        out[0] = 1;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 0;
                        out[4] = 0;
                        out[5] = 1;
                        out[6] = 0;
                        out[7] = 0;
                        out[8] = 0;
                        out[9] = 0;
                        out[10] = 1;
                        out[11] = 0;
                        out[12] = 0;
                        out[13] = 0;
                        out[14] = 0;
                        out[15] = 1;
                        return out;
                    };
                    Matrix4.ofRows = function (rows) {
                        var out = makeArray(16), i, j, r;
                        for (i = 0; i < 4; i++) {
                            r = rows[i];
                            for (j = 0; j < 4; j++) {
                                out[4 * j + i] = r[j];
                            }
                        }
                        return out;
                    };
                    Matrix4.areEqual = function (a, b, eps) {
                        for (var i = 0; i < 16; i++) {
                            if (Math.abs(a[i] - b[i]) > eps) {
                                return false;
                            }
                        }
                        return true;
                    };
                    Matrix4.setValue = function (a, i, j, value) {
                        a[4 * j + i] = value;
                    };
                    Matrix4.copy = function (out, a) {
                        out[0] = a[0];
                        out[1] = a[1];
                        out[2] = a[2];
                        out[3] = a[3];
                        out[4] = a[4];
                        out[5] = a[5];
                        out[6] = a[6];
                        out[7] = a[7];
                        out[8] = a[8];
                        out[9] = a[9];
                        out[10] = a[10];
                        out[11] = a[11];
                        out[12] = a[12];
                        out[13] = a[13];
                        out[14] = a[14];
                        out[15] = a[15];
                        return out;
                    };
                    Matrix4.clone = function (a) {
                        return Matrix4.copy(Matrix4.empty(), a);
                    };
                    Matrix4.invert = function (out, a) {
                        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, 
                        // Calculate the determinant
                        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                        if (!det) {
                            return null;
                        }
                        det = 1.0 / det;
                        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                        out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                        out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                        out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                        out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                        out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                        out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                        out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                        out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                        out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                        out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                        out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                        out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                        out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                        out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                        out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
                        return out;
                    };
                    Matrix4.mul = function (out, a, b) {
                        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                        // Cache only the current line of the second matrix
                        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                        out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                        out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                        out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                        out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                        b0 = b[4];
                        b1 = b[5];
                        b2 = b[6];
                        b3 = b[7];
                        out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                        out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                        out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                        out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                        b0 = b[8];
                        b1 = b[9];
                        b2 = b[10];
                        b3 = b[11];
                        out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                        out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                        out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                        out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                        b0 = b[12];
                        b1 = b[13];
                        b2 = b[14];
                        b3 = b[15];
                        out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                        out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                        out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                        out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                        return out;
                    };
                    Matrix4.translate = function (out, a, v) {
                        var x = v[0], y = v[1], z = v[2], a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
                        if (a === out) {
                            out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                            out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                            out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                            out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                        }
                        else {
                            a00 = a[0];
                            a01 = a[1];
                            a02 = a[2];
                            a03 = a[3];
                            a10 = a[4];
                            a11 = a[5];
                            a12 = a[6];
                            a13 = a[7];
                            a20 = a[8];
                            a21 = a[9];
                            a22 = a[10];
                            a23 = a[11];
                            out[0] = a00;
                            out[1] = a01;
                            out[2] = a02;
                            out[3] = a03;
                            out[4] = a10;
                            out[5] = a11;
                            out[6] = a12;
                            out[7] = a13;
                            out[8] = a20;
                            out[9] = a21;
                            out[10] = a22;
                            out[11] = a23;
                            out[12] = a00 * x + a10 * y + a20 * z + a[12];
                            out[13] = a01 * x + a11 * y + a21 * z + a[13];
                            out[14] = a02 * x + a12 * y + a22 * z + a[14];
                            out[15] = a03 * x + a13 * y + a23 * z + a[15];
                        }
                        return out;
                    };
                    Matrix4.fromTranslation = function (out, v) {
                        out[0] = 1;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 0;
                        out[4] = 0;
                        out[5] = 1;
                        out[6] = 0;
                        out[7] = 0;
                        out[8] = 0;
                        out[9] = 0;
                        out[10] = 1;
                        out[11] = 0;
                        out[12] = v[0];
                        out[13] = v[1];
                        out[14] = v[2];
                        out[15] = 1;
                        return out;
                    };
                    Matrix4.transformVector3 = function (out, a, m) {
                        var x = a.x, y = a.y, z = a.z;
                        out.x = m[0] * x + m[4] * y + m[8] * z + m[12];
                        out.y = m[1] * x + m[5] * y + m[9] * z + m[13];
                        out.z = m[2] * x + m[6] * y + m[10] * z + m[14];
                        //out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
                        return out;
                    };
                    Matrix4.makeTable = function (m) {
                        var ret = '';
                        for (var i = 0; i < 4; i++) {
                            for (var j = 0; j < 4; j++) {
                                ret += m[4 * j + i].toString();
                                if (j < 3)
                                    ret += ' ';
                            }
                            if (i < 3)
                                ret += '\n';
                        }
                        return ret;
                    };
                    Matrix4.determinant = function (a) {
                        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;
                        // Calculate the determinant
                        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                    };
                    return Matrix4;
                }());
                LinearAlgebra.Matrix4 = Matrix4;
                var Vector4 = (function () {
                    function Vector4() {
                    }
                    Vector4.create = function () {
                        var out = makeArray(4);
                        out[0] = 0;
                        out[1] = 0;
                        out[2] = 0;
                        out[3] = 0;
                        return out;
                    };
                    Vector4.clone = function (a) {
                        var out = makeArray(4);
                        out[0] = a[0];
                        out[1] = a[1];
                        out[2] = a[2];
                        out[3] = a[3];
                        return out;
                    };
                    Vector4.fromValues = function (x, y, z, w) {
                        var out = makeArray(4);
                        out[0] = x;
                        out[1] = y;
                        out[2] = z;
                        out[3] = w;
                        return out;
                    };
                    Vector4.set = function (out, x, y, z, w) {
                        out[0] = x;
                        out[1] = y;
                        out[2] = z;
                        out[3] = w;
                        return out;
                    };
                    Vector4.distance = function (a, b) {
                        var x = b[0] - a[0], y = b[1] - a[1], z = b[2] - a[2], w = b[3] - a[3];
                        return Math.sqrt(x * x + y * y + z * z + w * w);
                    };
                    Vector4.squaredDistance = function (a, b) {
                        var x = b[0] - a[0], y = b[1] - a[1], z = b[2] - a[2], w = b[3] - a[3];
                        return x * x + y * y + z * z + w * w;
                    };
                    Vector4.norm = function (a) {
                        var x = a[0], y = a[1], z = a[2], w = a[3];
                        return Math.sqrt(x * x + y * y + z * z + w * w);
                    };
                    Vector4.squaredNorm = function (a) {
                        var x = a[0], y = a[1], z = a[2], w = a[3];
                        return x * x + y * y + z * z + w * w;
                    };
                    Vector4.transform = function (out, a, m) {
                        var x = a[0], y = a[1], z = a[2], w = a[3];
                        out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
                        out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
                        out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
                        out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
                        return out;
                    };
                    return Vector4;
                }());
                LinearAlgebra.Vector4 = Vector4;
            })(LinearAlgebra = Geometry.LinearAlgebra || (Geometry.LinearAlgebra = {}));
        })(Geometry = Core.Geometry || (Core.Geometry = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Geometry;
        (function (Geometry) {
            /**
             * A buffer that only remembers the values.
             */
            var SubdivisionTree3DResultIndexBuffer = (function () {
                function SubdivisionTree3DResultIndexBuffer(initialCapacity) {
                    if (initialCapacity < 1)
                        initialCapacity = 1;
                    this.indices = new Int32Array(initialCapacity);
                    this.count = 0;
                    this.capacity = initialCapacity;
                    this.hasPriorities = false;
                    this.priorities = undefined;
                }
                SubdivisionTree3DResultIndexBuffer.prototype.ensureCapacity = function () {
                    var newCapacity = this.capacity * 2 + 1, newIdx = new Int32Array(newCapacity), i;
                    if (this.count < 32) {
                        for (i = 0; i < this.count; i++) {
                            newIdx[i] = this.indices[i];
                        }
                    }
                    else {
                        newIdx.set(this.indices);
                    }
                    this.indices = newIdx;
                    this.capacity = newCapacity;
                };
                SubdivisionTree3DResultIndexBuffer.prototype.add = function (distSq, index) {
                    if (this.count + 1 >= this.capacity)
                        this.ensureCapacity();
                    this.indices[this.count++] = index;
                };
                SubdivisionTree3DResultIndexBuffer.prototype.reset = function () {
                    this.count = 0;
                };
                return SubdivisionTree3DResultIndexBuffer;
            }());
            Geometry.SubdivisionTree3DResultIndexBuffer = SubdivisionTree3DResultIndexBuffer;
            /**
             * A buffer that remembers values and priorities.
             */
            var SubdivisionTree3DResultPriorityBuffer = (function () {
                function SubdivisionTree3DResultPriorityBuffer(initialCapacity) {
                    if (initialCapacity < 1)
                        initialCapacity = 1;
                    this.indices = new Int32Array(initialCapacity);
                    this.count = 0;
                    this.capacity = initialCapacity;
                    this.hasPriorities = true;
                    this.priorities = new Float32Array(initialCapacity);
                }
                SubdivisionTree3DResultPriorityBuffer.prototype.ensureCapacity = function () {
                    var newCapacity = this.capacity * 2 + 1, newIdx = new Int32Array(newCapacity), newPrio = new Float32Array(newCapacity), i;
                    if (this.count < 32) {
                        for (i = 0; i < this.count; i++) {
                            newIdx[i] = this.indices[i];
                            newPrio[i] = this.priorities[i];
                        }
                    }
                    else {
                        newIdx.set(this.indices);
                        newPrio.set(this.priorities);
                    }
                    this.indices = newIdx;
                    this.priorities = newPrio;
                    this.capacity = newCapacity;
                };
                SubdivisionTree3DResultPriorityBuffer.prototype.add = function (distSq, index) {
                    if (this.count + 1 >= this.capacity)
                        this.ensureCapacity();
                    this.priorities[this.count] = distSq;
                    this.indices[this.count++] = index;
                };
                SubdivisionTree3DResultPriorityBuffer.prototype.reset = function () {
                    this.count = 0;
                };
                return SubdivisionTree3DResultPriorityBuffer;
            }());
            Geometry.SubdivisionTree3DResultPriorityBuffer = SubdivisionTree3DResultPriorityBuffer;
            /**
             * Query context. Handles the actual querying.
             */
            var SubdivisionTree3DQueryContext = (function () {
                function SubdivisionTree3DQueryContext(tree, buffer) {
                    this.tree = tree;
                    this.indices = tree.indices;
                    this.positions = tree.positions;
                    this.buffer = buffer;
                    this.pivot = [0.1, 0.1, 0.1];
                    this.radius = 1.1;
                    this.radiusSq = 1.1 * 1.1;
                }
                /**
                 * Query the tree and store the result to this.buffer. Overwrites the old result.
                 */
                SubdivisionTree3DQueryContext.prototype.nearest = function (x, y, z, radius) {
                    this.pivot[0] = x;
                    this.pivot[1] = y;
                    this.pivot[2] = z;
                    this.radius = radius;
                    this.radiusSq = radius * radius;
                    this.buffer.reset();
                    this.tree.root.nearest(this, 0);
                };
                /**
                 * Query the tree and use the position of the i-th element as pivot.
                 * Store the result to this.buffer. Overwrites the old result.
                 */
                SubdivisionTree3DQueryContext.prototype.nearestIndex = function (index, radius) {
                    this.pivot[0] = this.positions[3 * index];
                    this.pivot[1] = this.positions[3 * index + 1];
                    this.pivot[2] = this.positions[3 * index + 2];
                    this.radius = radius;
                    this.radiusSq = radius * radius;
                    this.buffer.reset();
                    this.tree.root.nearest(this, 0);
                };
                return SubdivisionTree3DQueryContext;
            }());
            Geometry.SubdivisionTree3DQueryContext = SubdivisionTree3DQueryContext;
            /**
             * A kd-like tree to query 3D data.
             */
            var SubdivisionTree3D = (function () {
                /**
                 * Takes data and a function that calls SubdivisionTree3DPositionBuilder.add(x, y, z) on each data element.
                 */
                function SubdivisionTree3D(data, f, leafSize) {
                    if (leafSize === void 0) { leafSize = 32; }
                    var builder = new SubdivisionTree3DBuilder(data, f, leafSize);
                    this.data = data;
                    this.root = builder.build();
                    this.indices = builder.indices;
                    this.positions = builder.positions;
                }
                /**
                 * Create a context used for querying the data.
                 */
                SubdivisionTree3D.prototype.createContextRadius = function (radiusEstimate, includePriorities) {
                    if (includePriorities === void 0) { includePriorities = false; }
                    return new SubdivisionTree3DQueryContext(this, includePriorities
                        ? new SubdivisionTree3DResultPriorityBuffer(Math.max((radiusEstimate * radiusEstimate) | 0, 8))
                        : new SubdivisionTree3DResultIndexBuffer(Math.max((radiusEstimate * radiusEstimate) | 0, 8)));
                };
                return SubdivisionTree3D;
            }());
            Geometry.SubdivisionTree3D = SubdivisionTree3D;
            /**
             * A builder for position array.
             */
            var SubdivisionTree3DPositionBuilder = (function () {
                function SubdivisionTree3DPositionBuilder(count) {
                    this.count = 0;
                    this.data = new Float32Array((count * 3) | 0);
                    this.bounds = new Box3D();
                    this.boundsMin = this.bounds.min;
                    this.boundsMax = this.bounds.max;
                }
                SubdivisionTree3DPositionBuilder.prototype.add = function (x, y, z) {
                    this.data[this.count++] = x;
                    this.data[this.count++] = y;
                    this.data[this.count++] = z;
                    this.boundsMin[0] = Math.min(x, this.boundsMin[0]);
                    this.boundsMin[1] = Math.min(y, this.boundsMin[1]);
                    this.boundsMin[2] = Math.min(z, this.boundsMin[2]);
                    this.boundsMax[0] = Math.max(x, this.boundsMax[0]);
                    this.boundsMax[1] = Math.max(y, this.boundsMax[1]);
                    this.boundsMax[2] = Math.max(z, this.boundsMax[2]);
                };
                return SubdivisionTree3DPositionBuilder;
            }());
            Geometry.SubdivisionTree3DPositionBuilder = SubdivisionTree3DPositionBuilder;
            /**
             * A tree node.
             */
            var SubdivisionTree3DNode = (function () {
                function SubdivisionTree3DNode(splitValue, startIndex, endIndex, left, right) {
                    this.splitValue = splitValue;
                    this.startIndex = startIndex;
                    this.endIndex = endIndex;
                    this.left = left;
                    this.right = right;
                }
                SubdivisionTree3DNode.prototype.nearestLeaf = function (ctx) {
                    var pivot = ctx.pivot, indices = ctx.indices, positions = ctx.positions, rSq = ctx.radiusSq, dx, dy, dz, o, m, i;
                    for (i = this.startIndex; i < this.endIndex; i++) {
                        o = 3 * indices[i];
                        dx = pivot[0] - positions[o];
                        dy = pivot[1] - positions[o + 1];
                        dz = pivot[2] - positions[o + 2];
                        m = dx * dx + dy * dy + dz * dz;
                        if (m <= rSq)
                            ctx.buffer.add(m, indices[i]);
                    }
                };
                SubdivisionTree3DNode.prototype.nearestNode = function (ctx, dim) {
                    var pivot = ctx.pivot[dim], left = pivot < this.splitValue;
                    if (left ? pivot + ctx.radius > this.splitValue : pivot - ctx.radius < this.splitValue) {
                        this.left.nearest(ctx, (dim + 1) % 3);
                        this.right.nearest(ctx, (dim + 1) % 3);
                    }
                    else if (left) {
                        this.left.nearest(ctx, (dim + 1) % 3);
                    }
                    else {
                        this.right.nearest(ctx, (dim + 1) % 3);
                    }
                };
                SubdivisionTree3DNode.prototype.nearest = function (ctx, dim) {
                    // check for empty.
                    if (this.startIndex === this.endIndex)
                        return;
                    // is leaf?
                    if (isNaN(this.splitValue))
                        this.nearestLeaf(ctx);
                    else
                        this.nearestNode(ctx, dim);
                };
                return SubdivisionTree3DNode;
            }());
            Geometry.SubdivisionTree3DNode = SubdivisionTree3DNode;
            /**
             * A helper to store boundary box.
             */
            var Box3D = (function () {
                function Box3D() {
                    this.min = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE];
                    this.max = [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE];
                }
                return Box3D;
            }());
            Geometry.Box3D = Box3D;
            /**
             * A helper class to build the tree.
             */
            var SubdivisionTree3DBuilder = (function () {
                function SubdivisionTree3DBuilder(data, f, leafSize) {
                    var positions = new SubdivisionTree3DPositionBuilder(data.length), indices = new Int32Array(data.length), i;
                    for (i = 0; i < data.length; i++) {
                        indices[i] = i;
                        f(data[i], positions);
                    }
                    this.leafSize = leafSize;
                    this.positions = positions.data;
                    this.indices = indices;
                    this.emptyNode = new SubdivisionTree3DNode(NaN, -1, -1, null, null);
                    this.bounds = positions.bounds;
                }
                SubdivisionTree3DBuilder.prototype.split = function (startIndex, endIndex, coord) {
                    var delta = endIndex - startIndex + 1;
                    if (delta <= 0) {
                        return this.emptyNode;
                    }
                    else if (delta <= this.leafSize) {
                        return new SubdivisionTree3DNode(NaN, startIndex, endIndex + 1, this.emptyNode, this.emptyNode);
                    }
                    var min = this.bounds.min[coord], max = this.bounds.max[coord], median = 0.5 * (min + max), midIndex = 0, l = startIndex, r = endIndex, t, left, right;
                    while (l < r) {
                        t = this.indices[r];
                        this.indices[r] = this.indices[l];
                        this.indices[l] = t;
                        while (l <= endIndex && this.positions[3 * this.indices[l] + coord] <= median)
                            l++;
                        while (r >= startIndex && this.positions[3 * this.indices[r] + coord] > median)
                            r--;
                    }
                    midIndex = l - 1;
                    this.bounds.max[coord] = median;
                    left = this.split(startIndex, midIndex, (coord + 1) % 3);
                    this.bounds.max[coord] = max;
                    this.bounds.min[coord] = median;
                    right = this.split(midIndex + 1, endIndex, (coord + 1) % 3);
                    this.bounds.min[coord] = min;
                    return new SubdivisionTree3DNode(median, startIndex, endIndex + 1, left, right);
                };
                SubdivisionTree3DBuilder.prototype.build = function () {
                    return this.split(0, this.indices.length - 1, 0);
                };
                return SubdivisionTree3DBuilder;
            }());
        })(Geometry = Core.Geometry || (Core.Geometry = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Geometry;
        (function (Geometry) {
            var MarchingCubes;
            (function (MarchingCubes) {
                "use strict";
                function computeCubes(parameters) {
                    var params = Core.Utils.extend({}, parameters, {});
                    if (!params.bottomLeft)
                        params.bottomLeft = [0, 0, 0];
                    if (!params.topRight)
                        params.topRight = params.dimenstions;
                    var state = new MarchingCubesState(params), minX = params.bottomLeft[0], minY = params.bottomLeft[1], minZ = params.bottomLeft[2], maxX = params.topRight[0] - 1, maxY = params.topRight[1] - 1, maxZ = params.topRight[2] - 1, i = 0, j = 0, k = 0, vertices, normals, triangles, annotations;
                    for (k = minZ; k < maxZ; k++) {
                        for (j = minY; j < maxY; j++) {
                            for (i = minX; i < maxX; i++) {
                                state.processCell(i, j, k);
                            }
                        }
                    }
                    vertices = state.vertexBuffer.compact();
                    triangles = state.triangleBuffer.compact();
                    state.vertexBuffer = null;
                    state.verticesOnEdges = null;
                    return new MarchingCubesResult(vertices, triangles, state.annotate ? state.annotationBuffer.compact() : null);
                }
                MarchingCubes.computeCubes = computeCubes;
                var MarchingCubesResult = (function () {
                    function MarchingCubesResult(vertices, triangleIndices, annotation) {
                        this.__normals = new Float32Array(0);
                        this.vertexCount = (vertices.length / 3) | 0;
                        this.triangleCount = (triangleIndices.length / 3) | 0;
                        this.vertices = vertices;
                        this.triangleIndices = triangleIndices;
                        this.annotation = annotation;
                    }
                    Object.defineProperty(MarchingCubesResult.prototype, "normals", {
                        /**
                         * Array of size 3 * vertexCount. Layout [x1, y1, z1, ...., xn, yn, zn]
                         *
                         * Computed on demand.
                         */
                        get: function () {
                            if (this.__normals.length > 0)
                                return this.__normals;
                            this.computeVertexNormals();
                            return this.__normals;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    MarchingCubesResult.prototype.computeVertexNormals = function () {
                        var normals = new Float32Array(this.vertices.length), v = this.vertices, triangles = this.triangleIndices, len = triangles.length, f, i;
                        for (i = 0; i < triangles.length; i += 3) {
                            var a = 3 * triangles[i], b = 3 * triangles[i + 1], c = 3 * triangles[i + 2];
                            var nx = v[a + 2] * (v[b + 1] - v[c + 1]) + v[b + 2] * v[c + 1] - v[b + 1] * v[c + 2] + v[a + 1] * (-v[b + 2] + v[c + 2]), ny = -(v[b + 2] * v[c]) + v[a + 2] * (-v[b] + v[c]) + v[a] * (v[b + 2] - v[c + 2]) + v[b] * v[c + 2], nz = v[a + 1] * (v[b] - v[c]) + v[b + 1] * v[c] - v[b] * v[c + 1] + v[a] * (-v[b + 1] + v[b + 1]);
                            normals[a] += nx;
                            normals[a + 1] += ny;
                            normals[a + 2] += nz;
                            normals[b] += nx;
                            normals[b + 1] += ny;
                            normals[b + 2] += nz;
                            normals[c] += nx;
                            normals[c + 1] += ny;
                            normals[c + 2] += nz;
                        }
                        for (i = 0; i < normals.length; i += 3) {
                            nx = normals[i];
                            ny = normals[i + 1];
                            nz = normals[i + 2];
                            f = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);
                            normals[i] *= f;
                            normals[i + 1] *= f;
                            normals[i + 2] *= f;
                        }
                        this.__normals = normals;
                    };
                    MarchingCubesResult.addVertex = function (src, i, dst, j) {
                        dst[3 * j] += src[3 * i];
                        dst[3 * j + 1] += src[3 * i + 1];
                        dst[3 * j + 2] += src[3 * i + 2];
                    };
                    MarchingCubesResult.prototype.laplacianSmoothIter = function (counts, vs) {
                        var triCount = this.triangleIndices.length, src = this.vertices;
                        for (var i = 0; i < triCount; i += 3) {
                            var a = this.triangleIndices[i], b = this.triangleIndices[i + 1], c = this.triangleIndices[i + 2];
                            MarchingCubesResult.addVertex(src, b, vs, a);
                            MarchingCubesResult.addVertex(src, c, vs, a);
                            MarchingCubesResult.addVertex(src, a, vs, b);
                            MarchingCubesResult.addVertex(src, c, vs, b);
                            MarchingCubesResult.addVertex(src, a, vs, c);
                            MarchingCubesResult.addVertex(src, b, vs, c);
                        }
                        for (var i = 0; i < this.vertexCount; i++) {
                            var n = counts[i] + 2;
                            vs[3 * i] = (vs[3 * i] + 2 * src[3 * i]) / n;
                            vs[3 * i + 1] = (vs[3 * i + 1] + 2 * src[3 * i + 1]) / n;
                            vs[3 * i + 2] = (vs[3 * i + 2] + 2 * src[3 * i + 2]) / n;
                        }
                    };
                    /*
                     * Smooths the vertices by averaging the neighborhood.
                     *
                     * Resets normals. Might replace vertex array.
                     */
                    MarchingCubesResult.prototype.laplacianSmooth = function (iterCount) {
                        if (iterCount === void 0) { iterCount = 1; }
                        if (iterCount < 1)
                            iterCount = 1;
                        var counts = new Int32Array(this.vertexCount), triCount = this.triangleIndices.length;
                        for (var i = 0; i < triCount; i++) {
                            counts[this.triangleIndices[i]] += 2;
                        }
                        var vs = new Float32Array(this.vertices.length);
                        for (var i = 0; i < iterCount; i++) {
                            if (i > 0) {
                                for (var j = 0, _b = vs.length; j < _b; j++)
                                    vs[j] = 0;
                            }
                            this.laplacianSmoothIter(counts, vs);
                            var t = this.vertices;
                            this.vertices = vs;
                            vs = t;
                        }
                        this.__normals = new Float32Array(0);
                    };
                    return MarchingCubesResult;
                }());
                MarchingCubes.MarchingCubesResult = MarchingCubesResult;
                var MarchingCubesState = (function () {
                    function MarchingCubesState(params) {
                        this.vertList = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                        this.i = 0;
                        this.j = 0;
                        this.k = 0;
                        this.nX = params.dimenstions[0];
                        this.nY = params.dimenstions[1];
                        this.nZ = params.dimenstions[2];
                        this.isoLevel = params.isoLevel;
                        this.scalarField = params.scalarField;
                        this.annotationField = params.annotationField;
                        var dX = params.topRight[0] - params.bottomLeft[0], dY = params.topRight[1] - params.bottomLeft[1], dZ = params.topRight[2] - params.bottomLeft[2], vertexBufferSize = Math.min(262144, Math.max(dX * dY * dZ / 16, 1024) | 0), triangleBufferSize = Math.min(1 << 16, vertexBufferSize * 4);
                        this.vertexBuffer = Core.Utils.ChunkedArrayBuilder.forVertex3D(vertexBufferSize);
                        this.triangleBuffer = new Core.Utils.ChunkedArrayBuilder(function (size) { return new Uint32Array(size); }, triangleBufferSize, 3);
                        this.annotate = !!params.annotationField;
                        if (this.annotate)
                            this.annotationBuffer = Core.Utils.ChunkedArrayBuilder.forInt32(vertexBufferSize);
                        this.verticesOnEdges = new Int32Array(3 * this.nX * this.nY * this.nZ);
                    }
                    MarchingCubesState.prototype.getAnnotation = function () {
                        return this.annotationField[this.nX * (this.k * this.nY + this.j) + this.i];
                    };
                    MarchingCubesState.prototype.getFieldFromIndices = function (i, j, k) {
                        return this.scalarField[this.nX * (k * this.nY + j) + i];
                    };
                    MarchingCubesState.prototype.get3dOffsetFromEdgeInfo = function (index) {
                        return (this.nX * ((this.k + index.k) * this.nY + this.j + index.j) + this.i + index.i) | 0;
                    };
                    MarchingCubesState.prototype.interpolate = function (edgeNum) {
                        var info = MarchingCubes.EdgeIdInfo[edgeNum], edgeId = 3 * this.get3dOffsetFromEdgeInfo(info) + info.e;
                        var ret = this.verticesOnEdges[edgeId];
                        if (ret > 0)
                            return (ret - 1) | 0;
                        var edge = MarchingCubes.CubeEdges[edgeNum];
                        var a = edge.a, b = edge.b, li = a.i + this.i, lj = a.j + this.j, lk = a.k + this.k, hi = b.i + this.i, hj = b.j + this.j, hk = b.k + this.k, v0 = this.getFieldFromIndices(li, lj, lk), v1 = this.getFieldFromIndices(hi, hj, hk), t = (this.isoLevel - v0) / (v0 - v1);
                        var id = this.vertexBuffer.add3(li + t * (li - hi), lj + t * (lj - hj), lk + t * (lk - hk)) | 0;
                        this.verticesOnEdges[edgeId] = id + 1;
                        if (this.annotate) {
                            this.annotationBuffer.add(this.getAnnotation());
                        }
                        return id;
                    };
                    MarchingCubesState.prototype.processCell = function (i, j, k) {
                        var tableIndex = 0;
                        if (this.getFieldFromIndices(i, j, k) < this.isoLevel)
                            tableIndex |= 1;
                        if (this.getFieldFromIndices(i + 1, j, k) < this.isoLevel)
                            tableIndex |= 2;
                        if (this.getFieldFromIndices(i + 1, j + 1, k) < this.isoLevel)
                            tableIndex |= 4;
                        if (this.getFieldFromIndices(i, j + 1, k) < this.isoLevel)
                            tableIndex |= 8;
                        if (this.getFieldFromIndices(i, j, k + 1) < this.isoLevel)
                            tableIndex |= 16;
                        if (this.getFieldFromIndices(i + 1, j, k + 1) < this.isoLevel)
                            tableIndex |= 32;
                        if (this.getFieldFromIndices(i + 1, j + 1, k + 1) < this.isoLevel)
                            tableIndex |= 64;
                        if (this.getFieldFromIndices(i, j + 1, k + 1) < this.isoLevel)
                            tableIndex |= 128;
                        if (tableIndex === 0 || tableIndex === 255)
                            return;
                        this.i = i;
                        this.j = j;
                        this.k = k;
                        var edgeInfo = MarchingCubes.EdgeTable[tableIndex];
                        if ((edgeInfo & 1) > 0)
                            this.vertList[0] = this.interpolate(0); // 0 1
                        if ((edgeInfo & 2) > 0)
                            this.vertList[1] = this.interpolate(1); // 1 2
                        if ((edgeInfo & 4) > 0)
                            this.vertList[2] = this.interpolate(2); // 2 3
                        if ((edgeInfo & 8) > 0)
                            this.vertList[3] = this.interpolate(3); // 0 3
                        if ((edgeInfo & 16) > 0)
                            this.vertList[4] = this.interpolate(4); // 4 5
                        if ((edgeInfo & 32) > 0)
                            this.vertList[5] = this.interpolate(5); // 5 6
                        if ((edgeInfo & 64) > 0)
                            this.vertList[6] = this.interpolate(6); // 6 7
                        if ((edgeInfo & 128) > 0)
                            this.vertList[7] = this.interpolate(7); // 4 7
                        if ((edgeInfo & 256) > 0)
                            this.vertList[8] = this.interpolate(8); // 0 4
                        if ((edgeInfo & 512) > 0)
                            this.vertList[9] = this.interpolate(9); // 1 5
                        if ((edgeInfo & 1024) > 0)
                            this.vertList[10] = this.interpolate(10); // 2 6
                        if ((edgeInfo & 2048) > 0)
                            this.vertList[11] = this.interpolate(11); // 3 7
                        var triInfo = MarchingCubes.TriTable[tableIndex];
                        for (var t = 0; t < triInfo.length; t += 3) {
                            this.triangleBuffer.add3(this.vertList[triInfo[t]], this.vertList[triInfo[t + 1]], this.vertList[triInfo[t + 2]]);
                        }
                    };
                    return MarchingCubesState;
                }());
            })(MarchingCubes = Geometry.MarchingCubes || (Geometry.MarchingCubes = {}));
        })(Geometry = Core.Geometry || (Core.Geometry = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Geometry;
        (function (Geometry) {
            var MarchingCubes;
            (function (MarchingCubes) {
                "use strict";
                function computeSquares3D(params) {
                    var state = new MarchingSquares3DState(params), minX = params.bottomLeft[0], minY = params.bottomLeft[1], minZ = params.bottomLeft[2], maxX = params.topRight[0] - 1, maxY = params.topRight[1] - 1, maxZ = params.topRight[2] - 1, 
                    //nX = params.dimenstions[0] - 1, nY = params.dimenstions[1] - 1, nZ = params.dimenstions[2] - 1,
                    i = 0, j = 0, k = 0, vertices, edges;
                    for (k = minZ; k < maxZ; k++) {
                        for (j = minY; j < maxY; j++) {
                            for (i = minX; i < maxX; i++) {
                                state.processCell(i, j, k);
                            }
                        }
                    }
                    for (i = minX; i < maxX; i++) {
                        state.processCellYZMax(i, maxY, maxZ);
                        for (j = minY; j < maxY; j++) {
                            state.processCellZMax(i, j, maxZ);
                        }
                    }
                    for (i = minX; i < maxX; i++) {
                        for (k = minZ; k < maxZ; k++) {
                            state.processCellYMax(i, maxY, k);
                        }
                    }
                    for (j = minY; j < maxY; j++) {
                        state.processCellXZMax(maxX, j, maxZ);
                        for (k = minZ; k < maxZ; k++) {
                            state.processCellXMax(maxX, j, k);
                        }
                    }
                    for (k = minZ; k < maxZ; k++) {
                        state.processCellXYMax(maxX, maxY, k);
                    }
                    for (k = minZ; k < maxZ; k++) {
                        for (j = minY; j < maxY; j++) {
                            for (i = minX; i < maxX; i++) {
                                state.marchXY(i, j, k);
                                state.marchXZ(i, j, k);
                                state.marchYZ(i, j, k);
                            }
                        }
                    }
                    vertices = state.vertexBuffer.compact();
                    edges = state.edgeBuffer.compact();
                    state.vertexBuffer = null;
                    state.verticesOnEdges = null;
                    return new MarchingSquares3DResult(vertices, edges);
                }
                MarchingCubes.computeSquares3D = computeSquares3D;
                var MarchingSquares3DResult = (function () {
                    function MarchingSquares3DResult(vertices, edgeIndices) {
                        this.vertexCount = (vertices.length / 3) | 0;
                        this.vertices = vertices;
                        this.edgeIndices = edgeIndices;
                    }
                    return MarchingSquares3DResult;
                }());
                MarchingCubes.MarchingSquares3DResult = MarchingSquares3DResult;
                var MarchingSquares3DState = (function () {
                    function MarchingSquares3DState(params) {
                        this.verticesOnEdges = new Map();
                        this.edgeId = 0;
                        this.vertexId = 0;
                        this.i = 0;
                        this.j = 0;
                        this.k = 0;
                        this.nX = params.dimenstions[0], this.nY = params.dimenstions[1], this.nZ = params.dimenstions[2],
                            this.isoLevel = params.isoLevel, this.scalarField = params.scalarField;
                        var dX = params.topRight[0] - params.bottomLeft[0], dY = params.topRight[1] - params.bottomLeft[1], dZ = params.topRight[2] - params.bottomLeft[2], vertexBufferSize = Math.min(262144, Math.max(dX * dY * dZ / 16, 1024) | 0), edgeBufferSize = Math.min(1 << 16, vertexBufferSize * 4);
                        this.vertexBuffer = Core.Utils.ChunkedArrayBuilder.forVertex3D(vertexBufferSize);
                        this.edgeBuffer = new Core.Utils.ChunkedArrayBuilder(function (size) { return new Uint16Array(size); }, edgeBufferSize, 2);
                    }
                    MarchingSquares3DState.prototype.getFieldFromIndices = function (i, j, k) {
                        return this.scalarField[this.nX * (k * this.nY + j) + i];
                    };
                    MarchingSquares3DState.prototype.get3dOffsetFromEdgeInfo = function (index) {
                        return (this.nX * ((this.k + index.k) * this.nY + this.j + index.j) + this.i + index.i) | 0;
                    };
                    MarchingSquares3DState.prototype.getEdgeOffset = function (nEdgeNo) {
                        var info = MarchingCubes.EdgeIdInfo[nEdgeNo], vId = this.get3dOffsetFromEdgeInfo(info);
                        return (3 * vId + info.e) | 0;
                    };
                    MarchingSquares3DState.prototype.setEdgeInfo = function (nEdgeNo) {
                        var info = MarchingCubes.EdgeIdInfo[nEdgeNo], vId = this.get3dOffsetFromEdgeInfo(info);
                        this.edgeId = (3 * vId + info.e) | 0;
                        this.vertexId = vId;
                    };
                    MarchingSquares3DState.prototype.interpolate = function (edgeNum) {
                        this.setEdgeInfo(edgeNum);
                        var ret = this.verticesOnEdges.get(this.edgeId);
                        if (ret !== void 0)
                            return ret | 0;
                        var edge = MarchingCubes.CubeEdges[edgeNum];
                        var a = edge.a, b = edge.b, li = a.i + this.i, lj = a.j + this.j, lk = a.k + this.k, hi = b.i + this.i, hj = b.j + this.j, hk = b.k + this.k, v0 = this.getFieldFromIndices(li, lj, lk), v1 = this.getFieldFromIndices(hi, hj, hk), t = (this.isoLevel - v0) / (v0 - v1);
                        var id = this.vertexBuffer.add3(li + t * (li - hi), lj + t * (lj - hj), lk + t * (lk - hk)) | 0;
                        this.verticesOnEdges.set(this.edgeId, id);
                        return id;
                    };
                    MarchingSquares3DState.prototype.processCell = function (i, j, k) {
                        this.i = i;
                        this.j = j;
                        this.k = k;
                        var pivot = this.getFieldFromIndices(i, j, k) < this.isoLevel, v = false;
                        v = this.getFieldFromIndices(i + 1, j, k) < this.isoLevel;
                        if (pivot !== v)
                            this.interpolate(0);
                        v = this.getFieldFromIndices(i, j + 1, k) < this.isoLevel;
                        if (pivot !== v)
                            this.interpolate(3);
                        v = this.getFieldFromIndices(i, j, k + 1) < this.isoLevel;
                        if (pivot !== v)
                            this.interpolate(8);
                    };
                    MarchingSquares3DState.prototype.processCellXMax = function (i, j, k) {
                        this.i = i;
                        this.j = j;
                        this.k = k;
                        var pivot = this.getFieldFromIndices(i, j, k) < this.isoLevel, v = false;
                        v = this.getFieldFromIndices(i, j + 1, k) < this.isoLevel;
                        if (pivot !== v)
                            this.interpolate(3);
                        v = this.getFieldFromIndices(i, j, k + 1) < this.isoLevel;
                        if (pivot !== v)
                            this.interpolate(8);
                    };
                    MarchingSquares3DState.prototype.processCellYMax = function (i, j, k) {
                        this.i = i;
                        this.j = j;
                        this.k = k;
                        var pivot = this.getFieldFromIndices(i, j, k) < this.isoLevel, v = false;
                        v = this.getFieldFromIndices(i + 1, j, k) < this.isoLevel;
                        if (pivot !== v)
                            this.interpolate(0);
                        v = this.getFieldFromIndices(i, j, k + 1) < this.isoLevel;
                        if (pivot !== v)
                            this.interpolate(8);
                    };
                    MarchingSquares3DState.prototype.processCellZMax = function (i, j, k) {
                        this.i = i;
                        this.j = j;
                        this.k = k;
                        var pivot = this.getFieldFromIndices(i, j, k) < this.isoLevel, v = false;
                        v = this.getFieldFromIndices(i + 1, j, k) < this.isoLevel;
                        if (pivot !== v)
                            this.interpolate(0);
                        v = this.getFieldFromIndices(i, j + 1, k) < this.isoLevel;
                        if (pivot !== v)
                            this.interpolate(3);
                    };
                    MarchingSquares3DState.prototype.processCellXYMax = function (i, j, k) {
                        this.i = i;
                        this.j = j;
                        this.k = k;
                        var pivot = this.getFieldFromIndices(i, j, k) < this.isoLevel, v = false;
                        v = this.getFieldFromIndices(i, j, k + 1) < this.isoLevel;
                        if (pivot !== v)
                            this.interpolate(8);
                    };
                    MarchingSquares3DState.prototype.processCellXZMax = function (i, j, k) {
                        this.i = i;
                        this.j = j;
                        this.k = k;
                        var pivot = this.getFieldFromIndices(i, j, k) < this.isoLevel, v = false;
                        v = this.getFieldFromIndices(i, j + 1, k) < this.isoLevel;
                        if (pivot !== v)
                            this.interpolate(3);
                    };
                    MarchingSquares3DState.prototype.processCellYZMax = function (i, j, k) {
                        this.i = i;
                        this.j = j;
                        this.k = k;
                        var pivot = this.getFieldFromIndices(i, j, k) < this.isoLevel, v = false;
                        v = this.getFieldFromIndices(i + 1, j, k) < this.isoLevel;
                        if (pivot !== v)
                            this.interpolate(0);
                    };
                    MarchingSquares3DState.prototype.addEdges = function (edges) {
                        for (var i = 0; i < edges.length; i += 2) {
                            this.edgeBuffer.add2(this.verticesOnEdges.get(this.getEdgeOffset(edges[i])), this.verticesOnEdges.get(this.getEdgeOffset(edges[i + 1])));
                        }
                    };
                    MarchingSquares3DState.prototype.marchXY = function (i, j, k) {
                        var mask = 0;
                        this.i = i;
                        this.j = j;
                        this.k = k;
                        if (this.getFieldFromIndices(i, j, k) < this.isoLevel)
                            mask |= 1;
                        if (this.getFieldFromIndices(i + 1, j, k) < this.isoLevel)
                            mask |= 2;
                        if (this.getFieldFromIndices(i + 1, j + 1, k) < this.isoLevel)
                            mask |= 4;
                        if (this.getFieldFromIndices(i, j + 1, k) < this.isoLevel)
                            mask |= 8;
                        this.addEdges(MarchingCubes.EdgesXY[mask]);
                    };
                    MarchingSquares3DState.prototype.marchXZ = function (i, j, k) {
                        var mask = 0;
                        this.i = i;
                        this.j = j;
                        this.k = k;
                        if (this.getFieldFromIndices(i, j, k) < this.isoLevel)
                            mask |= 1;
                        if (this.getFieldFromIndices(i + 1, j, k) < this.isoLevel)
                            mask |= 2;
                        if (this.getFieldFromIndices(i + 1, j, k + 1) < this.isoLevel)
                            mask |= 4;
                        if (this.getFieldFromIndices(i, j, k + 1) < this.isoLevel)
                            mask |= 8;
                        this.addEdges(MarchingCubes.EdgesXZ[mask]);
                    };
                    MarchingSquares3DState.prototype.marchYZ = function (i, j, k) {
                        var mask = 0;
                        this.i = i;
                        this.j = j;
                        this.k = k;
                        if (this.getFieldFromIndices(i, j, k) < this.isoLevel)
                            mask |= 1;
                        if (this.getFieldFromIndices(i, j + 1, k) < this.isoLevel)
                            mask |= 2;
                        if (this.getFieldFromIndices(i, j + 1, k + 1) < this.isoLevel)
                            mask |= 4;
                        if (this.getFieldFromIndices(i, j, k + 1) < this.isoLevel)
                            mask |= 8;
                        this.addEdges(MarchingCubes.EdgesYZ[mask]);
                    };
                    return MarchingSquares3DState;
                }());
            })(MarchingCubes = Geometry.MarchingCubes || (Geometry.MarchingCubes = {}));
        })(Geometry = Core.Geometry || (Core.Geometry = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Geometry;
        (function (Geometry) {
            var MarchingCubes;
            (function (MarchingCubes) {
                var Index = (function () {
                    function Index(i, j, k) {
                        this.i = i | 0;
                        this.j = j | 0;
                        this.k = k | 0;
                    }
                    return Index;
                }());
                MarchingCubes.Index = Index;
                var IndexPair = (function () {
                    function IndexPair(a, b) {
                        this.a = a;
                        this.b = b;
                    }
                    return IndexPair;
                }());
                MarchingCubes.IndexPair = IndexPair;
                MarchingCubes.EdgesXY = [
                    [],
                    [0, 3],
                    [0, 1],
                    [1, 3],
                    [1, 2],
                    [0, 1, 1, 2, 2, 3, 0, 3],
                    [0, 2],
                    [2, 3],
                    [2, 3],
                    [0, 2],
                    [0, 1, 1, 2, 2, 3, 0, 3],
                    [1, 2],
                    [1, 3],
                    [0, 1],
                    [0, 3],
                    []
                ];
                MarchingCubes.EdgesXZ = [
                    [],
                    [0, 8],
                    [0, 9],
                    [9, 8],
                    [9, 4],
                    [0, 9, 9, 4, 4, 8, 0, 8],
                    [0, 4],
                    [4, 8],
                    [4, 8],
                    [0, 4],
                    [0, 9, 9, 4, 4, 8, 0, 8],
                    [9, 4],
                    [9, 8],
                    [0, 9],
                    [0, 8],
                    []
                ];
                MarchingCubes.EdgesYZ = [
                    [],
                    [3, 8],
                    [3, 11],
                    [11, 8],
                    [11, 7],
                    [3, 11, 11, 7, 7, 8, 3, 8],
                    [3, 7],
                    [7, 8],
                    [7, 8],
                    [3, 7],
                    [3, 11, 11, 7, 7, 8, 3, 8],
                    [11, 7],
                    [11, 8],
                    [3, 11],
                    [3, 8],
                    []
                ];
                MarchingCubes.CubeVertices = [
                    new Index(0, 0, 0),
                    new Index(1, 0, 0),
                    new Index(1, 1, 0),
                    new Index(0, 1, 0),
                    new Index(0, 0, 1),
                    new Index(1, 0, 1),
                    new Index(1, 1, 1),
                    new Index(0, 1, 1),
                ];
                MarchingCubes.CubeEdges = [
                    new IndexPair(MarchingCubes.CubeVertices[0], MarchingCubes.CubeVertices[1]),
                    new IndexPair(MarchingCubes.CubeVertices[1], MarchingCubes.CubeVertices[2]),
                    new IndexPair(MarchingCubes.CubeVertices[2], MarchingCubes.CubeVertices[3]),
                    new IndexPair(MarchingCubes.CubeVertices[3], MarchingCubes.CubeVertices[0]),
                    new IndexPair(MarchingCubes.CubeVertices[4], MarchingCubes.CubeVertices[5]),
                    new IndexPair(MarchingCubes.CubeVertices[5], MarchingCubes.CubeVertices[6]),
                    new IndexPair(MarchingCubes.CubeVertices[6], MarchingCubes.CubeVertices[7]),
                    new IndexPair(MarchingCubes.CubeVertices[7], MarchingCubes.CubeVertices[4]),
                    new IndexPair(MarchingCubes.CubeVertices[0], MarchingCubes.CubeVertices[4]),
                    new IndexPair(MarchingCubes.CubeVertices[1], MarchingCubes.CubeVertices[5]),
                    new IndexPair(MarchingCubes.CubeVertices[2], MarchingCubes.CubeVertices[6]),
                    new IndexPair(MarchingCubes.CubeVertices[3], MarchingCubes.CubeVertices[7]),
                ];
                MarchingCubes.EdgeIdInfo = [
                    { i: 0, j: 0, k: 0, e: 0 },
                    { i: 1, j: 0, k: 0, e: 1 },
                    { i: 0, j: 1, k: 0, e: 0 },
                    { i: 0, j: 0, k: 0, e: 1 },
                    { i: 0, j: 0, k: 1, e: 0 },
                    { i: 1, j: 0, k: 1, e: 1 },
                    { i: 0, j: 1, k: 1, e: 0 },
                    { i: 0, j: 0, k: 1, e: 1 },
                    { i: 0, j: 0, k: 0, e: 2 },
                    { i: 1, j: 0, k: 0, e: 2 },
                    { i: 1, j: 1, k: 0, e: 2 },
                    { i: 0, j: 1, k: 0, e: 2 }
                ];
                // Tables EdgeTable and TriTable taken from http://paulbourke.net/geometry/polygonise/
                MarchingCubes.EdgeTable = [
                    0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
                    0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
                    0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
                    0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
                    0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,
                    0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
                    0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,
                    0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
                    0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,
                    0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
                    0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,
                    0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
                    0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,
                    0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
                    0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,
                    0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
                    0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
                    0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
                    0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
                    0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
                    0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
                    0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
                    0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
                    0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,
                    0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
                    0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,
                    0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
                    0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,
                    0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
                    0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,
                    0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
                    0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
                ];
                MarchingCubes.TriTable = [
                    [],
                    [0, 8, 3],
                    [0, 1, 9],
                    [1, 8, 3, 9, 8, 1],
                    [1, 2, 10],
                    [0, 8, 3, 1, 2, 10],
                    [9, 2, 10, 0, 2, 9],
                    [2, 8, 3, 2, 10, 8, 10, 9, 8],
                    [3, 11, 2],
                    [0, 11, 2, 8, 11, 0],
                    [1, 9, 0, 2, 3, 11],
                    [1, 11, 2, 1, 9, 11, 9, 8, 11],
                    [3, 10, 1, 11, 10, 3],
                    [0, 10, 1, 0, 8, 10, 8, 11, 10],
                    [3, 9, 0, 3, 11, 9, 11, 10, 9],
                    [9, 8, 10, 10, 8, 11],
                    [4, 7, 8],
                    [4, 3, 0, 7, 3, 4],
                    [0, 1, 9, 8, 4, 7],
                    [4, 1, 9, 4, 7, 1, 7, 3, 1],
                    [1, 2, 10, 8, 4, 7],
                    [3, 4, 7, 3, 0, 4, 1, 2, 10],
                    [9, 2, 10, 9, 0, 2, 8, 4, 7],
                    [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4],
                    [8, 4, 7, 3, 11, 2],
                    [11, 4, 7, 11, 2, 4, 2, 0, 4],
                    [9, 0, 1, 8, 4, 7, 2, 3, 11],
                    [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1],
                    [3, 10, 1, 3, 11, 10, 7, 8, 4],
                    [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4],
                    [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3],
                    [4, 7, 11, 4, 11, 9, 9, 11, 10],
                    [9, 5, 4],
                    [9, 5, 4, 0, 8, 3],
                    [0, 5, 4, 1, 5, 0],
                    [8, 5, 4, 8, 3, 5, 3, 1, 5],
                    [1, 2, 10, 9, 5, 4],
                    [3, 0, 8, 1, 2, 10, 4, 9, 5],
                    [5, 2, 10, 5, 4, 2, 4, 0, 2],
                    [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8],
                    [9, 5, 4, 2, 3, 11],
                    [0, 11, 2, 0, 8, 11, 4, 9, 5],
                    [0, 5, 4, 0, 1, 5, 2, 3, 11],
                    [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5],
                    [10, 3, 11, 10, 1, 3, 9, 5, 4],
                    [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10],
                    [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3],
                    [5, 4, 8, 5, 8, 10, 10, 8, 11],
                    [9, 7, 8, 5, 7, 9],
                    [9, 3, 0, 9, 5, 3, 5, 7, 3],
                    [0, 7, 8, 0, 1, 7, 1, 5, 7],
                    [1, 5, 3, 3, 5, 7],
                    [9, 7, 8, 9, 5, 7, 10, 1, 2],
                    [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3],
                    [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2],
                    [2, 10, 5, 2, 5, 3, 3, 5, 7],
                    [7, 9, 5, 7, 8, 9, 3, 11, 2],
                    [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11],
                    [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7],
                    [11, 2, 1, 11, 1, 7, 7, 1, 5],
                    [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11],
                    [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0],
                    [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0],
                    [11, 10, 5, 7, 11, 5],
                    [10, 6, 5],
                    [0, 8, 3, 5, 10, 6],
                    [9, 0, 1, 5, 10, 6],
                    [1, 8, 3, 1, 9, 8, 5, 10, 6],
                    [1, 6, 5, 2, 6, 1],
                    [1, 6, 5, 1, 2, 6, 3, 0, 8],
                    [9, 6, 5, 9, 0, 6, 0, 2, 6],
                    [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8],
                    [2, 3, 11, 10, 6, 5],
                    [11, 0, 8, 11, 2, 0, 10, 6, 5],
                    [0, 1, 9, 2, 3, 11, 5, 10, 6],
                    [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11],
                    [6, 3, 11, 6, 5, 3, 5, 1, 3],
                    [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6],
                    [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9],
                    [6, 5, 9, 6, 9, 11, 11, 9, 8],
                    [5, 10, 6, 4, 7, 8],
                    [4, 3, 0, 4, 7, 3, 6, 5, 10],
                    [1, 9, 0, 5, 10, 6, 8, 4, 7],
                    [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4],
                    [6, 1, 2, 6, 5, 1, 4, 7, 8],
                    [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7],
                    [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6],
                    [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9],
                    [3, 11, 2, 7, 8, 4, 10, 6, 5],
                    [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11],
                    [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6],
                    [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6],
                    [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6],
                    [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11],
                    [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7],
                    [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9],
                    [10, 4, 9, 6, 4, 10],
                    [4, 10, 6, 4, 9, 10, 0, 8, 3],
                    [10, 0, 1, 10, 6, 0, 6, 4, 0],
                    [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10],
                    [1, 4, 9, 1, 2, 4, 2, 6, 4],
                    [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4],
                    [0, 2, 4, 4, 2, 6],
                    [8, 3, 2, 8, 2, 4, 4, 2, 6],
                    [10, 4, 9, 10, 6, 4, 11, 2, 3],
                    [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6],
                    [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10],
                    [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1],
                    [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3],
                    [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1],
                    [3, 11, 6, 3, 6, 0, 0, 6, 4],
                    [6, 4, 8, 11, 6, 8],
                    [7, 10, 6, 7, 8, 10, 8, 9, 10],
                    [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10],
                    [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0],
                    [10, 6, 7, 10, 7, 1, 1, 7, 3],
                    [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7],
                    [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9],
                    [7, 8, 0, 7, 0, 6, 6, 0, 2],
                    [7, 3, 2, 6, 7, 2],
                    [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7],
                    [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7],
                    [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11],
                    [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1],
                    [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6],
                    [0, 9, 1, 11, 6, 7],
                    [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0],
                    [7, 11, 6],
                    [7, 6, 11],
                    [3, 0, 8, 11, 7, 6],
                    [0, 1, 9, 11, 7, 6],
                    [8, 1, 9, 8, 3, 1, 11, 7, 6],
                    [10, 1, 2, 6, 11, 7],
                    [1, 2, 10, 3, 0, 8, 6, 11, 7],
                    [2, 9, 0, 2, 10, 9, 6, 11, 7],
                    [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8],
                    [7, 2, 3, 6, 2, 7],
                    [7, 0, 8, 7, 6, 0, 6, 2, 0],
                    [2, 7, 6, 2, 3, 7, 0, 1, 9],
                    [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6],
                    [10, 7, 6, 10, 1, 7, 1, 3, 7],
                    [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8],
                    [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7],
                    [7, 6, 10, 7, 10, 8, 8, 10, 9],
                    [6, 8, 4, 11, 8, 6],
                    [3, 6, 11, 3, 0, 6, 0, 4, 6],
                    [8, 6, 11, 8, 4, 6, 9, 0, 1],
                    [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6],
                    [6, 8, 4, 6, 11, 8, 2, 10, 1],
                    [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6],
                    [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9],
                    [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3],
                    [8, 2, 3, 8, 4, 2, 4, 6, 2],
                    [0, 4, 2, 4, 6, 2],
                    [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8],
                    [1, 9, 4, 1, 4, 2, 2, 4, 6],
                    [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1],
                    [10, 1, 0, 10, 0, 6, 6, 0, 4],
                    [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3],
                    [10, 9, 4, 6, 10, 4],
                    [4, 9, 5, 7, 6, 11],
                    [0, 8, 3, 4, 9, 5, 11, 7, 6],
                    [5, 0, 1, 5, 4, 0, 7, 6, 11],
                    [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5],
                    [9, 5, 4, 10, 1, 2, 7, 6, 11],
                    [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5],
                    [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2],
                    [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6],
                    [7, 2, 3, 7, 6, 2, 5, 4, 9],
                    [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7],
                    [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0],
                    [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8],
                    [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7],
                    [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4],
                    [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10],
                    [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10],
                    [6, 9, 5, 6, 11, 9, 11, 8, 9],
                    [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5],
                    [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11],
                    [6, 11, 3, 6, 3, 5, 5, 3, 1],
                    [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6],
                    [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10],
                    [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5],
                    [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3],
                    [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2],
                    [9, 5, 6, 9, 6, 0, 0, 6, 2],
                    [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8],
                    [1, 5, 6, 2, 1, 6],
                    [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6],
                    [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0],
                    [0, 3, 8, 5, 6, 10],
                    [10, 5, 6],
                    [11, 5, 10, 7, 5, 11],
                    [11, 5, 10, 11, 7, 5, 8, 3, 0],
                    [5, 11, 7, 5, 10, 11, 1, 9, 0],
                    [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1],
                    [11, 1, 2, 11, 7, 1, 7, 5, 1],
                    [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11],
                    [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7],
                    [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2],
                    [2, 5, 10, 2, 3, 5, 3, 7, 5],
                    [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5],
                    [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2],
                    [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2],
                    [1, 3, 5, 3, 7, 5],
                    [0, 8, 7, 0, 7, 1, 1, 7, 5],
                    [9, 0, 3, 9, 3, 5, 5, 3, 7],
                    [9, 8, 7, 5, 9, 7],
                    [5, 8, 4, 5, 10, 8, 10, 11, 8],
                    [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0],
                    [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5],
                    [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4],
                    [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8],
                    [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11],
                    [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5],
                    [9, 4, 5, 2, 11, 3],
                    [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4],
                    [5, 10, 2, 5, 2, 4, 4, 2, 0],
                    [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9],
                    [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2],
                    [8, 4, 5, 8, 5, 3, 3, 5, 1],
                    [0, 4, 5, 1, 0, 5],
                    [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5],
                    [9, 4, 5],
                    [4, 11, 7, 4, 9, 11, 9, 10, 11],
                    [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11],
                    [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11],
                    [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4],
                    [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2],
                    [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3],
                    [11, 7, 4, 11, 4, 2, 2, 4, 0],
                    [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4],
                    [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9],
                    [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7],
                    [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10],
                    [1, 10, 2, 8, 7, 4],
                    [4, 9, 1, 4, 1, 7, 7, 1, 3],
                    [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1],
                    [4, 0, 3, 7, 4, 3],
                    [4, 8, 7],
                    [9, 10, 8, 10, 11, 8],
                    [3, 0, 9, 3, 9, 11, 11, 9, 10],
                    [0, 1, 10, 0, 10, 8, 8, 10, 11],
                    [3, 1, 10, 11, 3, 10],
                    [1, 2, 11, 1, 11, 9, 9, 11, 8],
                    [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9],
                    [0, 2, 11, 8, 0, 11],
                    [3, 2, 11],
                    [2, 3, 8, 2, 8, 10, 10, 8, 9],
                    [9, 10, 2, 0, 9, 2],
                    [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8],
                    [1, 10, 2],
                    [1, 3, 8, 9, 1, 8],
                    [0, 9, 1],
                    [0, 3, 8],
                    []
                ];
            })(MarchingCubes = Geometry.MarchingCubes || (Geometry.MarchingCubes = {}));
        })(Geometry = Core.Geometry || (Core.Geometry = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright(c) 2016 David Sehnal
   *
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
   *
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
   * limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Geometry;
        (function (Geometry) {
            var MolecularSurface;
            (function (MolecularSurface) {
                "use strict";
                var MolecularIsoSurfaceParameters = (function () {
                    function MolecularIsoSurfaceParameters(params) {
                        Core.Utils.extend(this, params, {
                            exactBoundary: false,
                            boundaryDelta: { dx: 1.5, dy: 1.5, dz: 1.5 },
                            probeRadius: 1.4,
                            atomRadii: function () { return 1.0; },
                            density: 1.1,
                            interactive: false,
                            smoothingIterations: 1
                        });
                        if (this.exactBoundary)
                            this.boundaryDelta = { dx: 0, dy: 0, dz: 0 };
                        if (this.density < 0.5)
                            this.density = 0.5;
                        //if (this.probeRadius < 0) this.probeRadius = 0;
                    }
                    return MolecularIsoSurfaceParameters;
                }());
                MolecularSurface.MolecularIsoSurfaceParameters = MolecularIsoSurfaceParameters;
                var MolecularIsoField = (function () {
                    function MolecularIsoField(parameters, positions, atomIndices) {
                        this.positions = positions;
                        this.atomIndices = atomIndices;
                        this.minX = Number.MAX_VALUE;
                        this.minY = Number.MAX_VALUE;
                        this.minZ = Number.MAX_VALUE;
                        this.maxX = -Number.MAX_VALUE;
                        this.maxY = -Number.MAX_VALUE;
                        this.maxZ = -Number.MAX_VALUE;
                        this.nX = 0;
                        this.nY = 0;
                        this.nZ = 0;
                        this.dX = 0.1;
                        this.dY = 0.1;
                        this.dZ = 0.1;
                        this.field = new Float32Array(0);
                        this.maxField = new Float32Array(0);
                        this.proximityMap = new Int32Array(0);
                        this.minIndex = { i: 0, j: 0, k: 0 };
                        this.maxIndex = { i: 0, j: 0, k: 0 };
                        this.parameters = new MolecularIsoSurfaceParameters(parameters);
                        this.x = this.positions.x;
                        this.y = this.positions.y;
                        this.z = this.positions.z;
                    }
                    MolecularIsoField.prototype.findBounds = function () {
                        for (var _i = 0, _a = this.atomIndices; _i < _a.length; _i++) {
                            var aI = _a[_i];
                            var r = this.parameters.exactBoundary ? 0 : this.parameters.atomRadius(aI) + this.parameters.probeRadius, xx = this.x[aI], yy = this.y[aI], zz = this.z[aI];
                            if (r < 0)
                                continue;
                            this.minX = Math.min(this.minX, xx - r);
                            this.minY = Math.min(this.minY, yy - r);
                            this.minZ = Math.min(this.minZ, zz - r);
                            this.maxX = Math.max(this.maxX, xx + r);
                            this.maxY = Math.max(this.maxY, yy + r);
                            this.maxZ = Math.max(this.maxZ, zz + r);
                        }
                        if (this.minX === Number.MAX_VALUE) {
                            this.minX = this.minY = this.minZ = -1;
                            this.maxX = this.maxY = this.maxZ = 1;
                        }
                        this.minX -= this.parameters.boundaryDelta.dx;
                        this.minY -= this.parameters.boundaryDelta.dy;
                        this.minZ -= this.parameters.boundaryDelta.dz;
                        this.maxX += this.parameters.boundaryDelta.dx;
                        this.maxY += this.parameters.boundaryDelta.dy;
                        this.maxZ += this.parameters.boundaryDelta.dz;
                        this.nX = Math.floor((this.maxX - this.minX) * this.parameters.density);
                        this.nY = Math.floor((this.maxY - this.minY) * this.parameters.density);
                        this.nZ = Math.floor((this.maxZ - this.minZ) * this.parameters.density);
                        this.nX = Math.min(this.nX, 333);
                        this.nY = Math.min(this.nY, 333);
                        this.nZ = Math.min(this.nZ, 333);
                        this.dX = (this.maxX - this.minX) / (this.nX - 1);
                        this.dY = (this.maxY - this.minY) / (this.nY - 1);
                        this.dZ = (this.maxZ - this.minZ) / (this.nZ - 1);
                    };
                    MolecularIsoField.prototype.initData = function () {
                        var len = this.nX * this.nY * this.nZ;
                        this.field = new Float32Array(len);
                        this.maxField = new Float32Array(len);
                        this.proximityMap = new Int32Array(len);
                        var mv = -Number.MAX_VALUE;
                        for (var j = 0, _b = this.proximityMap.length; j < _b; j++) {
                            this.maxField[j] = mv;
                            this.proximityMap[j] = -1;
                        }
                    };
                    MolecularIsoField.prototype.updateMinIndex = function (x, y, z) {
                        this.minIndex.i = Math.max((Math.floor((x - this.minX) / this.dX)) | 0, 0);
                        this.minIndex.j = Math.max((Math.floor((y - this.minY) / this.dY)) | 0, 0);
                        this.minIndex.k = Math.max((Math.floor((z - this.minZ) / this.dZ)) | 0, 0);
                    };
                    MolecularIsoField.prototype.updateMaxIndex = function (x, y, z) {
                        this.maxIndex.i = Math.min((Math.ceil((x - this.minX) / this.dX)) | 0, this.nX);
                        this.maxIndex.j = Math.min((Math.ceil((y - this.minY) / this.dY)) | 0, this.nY);
                        this.maxIndex.k = Math.min((Math.ceil((z - this.minZ) / this.dZ)) | 0, this.nZ);
                    };
                    MolecularIsoField.prototype.addBall = function (aI, strength) {
                        var strSq = strength * strength;
                        var cx = this.x[aI], cy = this.y[aI], cz = this.z[aI];
                        this.updateMinIndex(cx - strength, cy - strength, cz - strength);
                        this.updateMaxIndex(cx + strength, cy + strength, cz + strength);
                        var mini = this.minIndex.i, minj = this.minIndex.j, mink = this.minIndex.k;
                        var maxi = this.maxIndex.i, maxj = this.maxIndex.j, maxk = this.maxIndex.k;
                        cx = this.minX - cx;
                        cy = this.minY - cy;
                        cz = this.minZ - cz;
                        for (var k = mink; k < maxk; k++) {
                            var tZ = cz + k * this.dZ, zz = tZ * tZ, oZ = k * this.nY;
                            for (var j = minj; j < maxj; j++) {
                                var tY = cy + j * this.dY, yy = zz + tY * tY, oY = this.nX * (oZ + j);
                                for (var i = mini; i < maxi; i++) {
                                    var tX = cx + i * this.dX, xx = yy + tX * tX, offset = oY + i;
                                    var v = strSq / (0.000001 + xx) - 1;
                                    //let offset = nX * (k * nY + j) + i;
                                    if (v > this.maxField[offset]) {
                                        this.proximityMap[offset] = aI;
                                        this.maxField[offset] = v;
                                    }
                                    //if (xx >= maxRsq) continue;
                                    //let v = strength / Math.sqrt(0.000001 + zz) - 1;
                                    //v = Math.Exp(-((Dist/AtomRadius)*(Dist/AtomRadius)));
                                    if (v > 0) {
                                        this.field[offset] += v;
                                    }
                                }
                            }
                        }
                    };
                    MolecularIsoField.prototype.getData = function () {
                        this.findBounds();
                        this.initData();
                        for (var _i = 0, _a = this.atomIndices; _i < _a.length; _i++) {
                            var aI = _a[_i];
                            var r = this.parameters.atomRadius(aI) + this.parameters.probeRadius;
                            if (r < 0)
                                continue;
                            this.addBall(aI, r);
                        }
                        this.maxField = null;
                        var t = Geometry.LinearAlgebra.Matrix4.empty();
                        Geometry.LinearAlgebra.Matrix4.fromTranslation(t, [this.minX, this.minY, this.minZ]);
                        t[0] = this.dX;
                        t[5] = this.dY;
                        t[10] = this.dZ;
                        return {
                            data: {
                                dimenstions: [this.nX, this.nY, this.nZ],
                                scalarField: this.field,
                                annotationField: this.proximityMap,
                                isoLevel: 0.05
                            },
                            bottomLeft: { x: this.minX, y: this.minY, z: this.minZ },
                            topRight: { x: this.maxX, y: this.maxY, z: this.maxZ },
                            transform: t
                        };
                    };
                    return MolecularIsoField;
                }());
                MolecularSurface.MolecularIsoField = MolecularIsoField;
                var MolecularIsoSurfaceGeometryData = (function () {
                    function MolecularIsoSurfaceGeometryData(data, bottomLeft, topRight, transform, vertexAtomIdMap, parameters) {
                        this.data = data;
                        this.bottomLeft = bottomLeft;
                        this.topRight = topRight;
                        this.transform = transform;
                        this.vertexAtomIdMap = vertexAtomIdMap;
                        this.parameters = parameters;
                    }
                    MolecularIsoSurfaceGeometryData.fromField = function (field) {
                        var inputData = field.getData();
                        var parameters = field.parameters;
                        field = null; // allow some GC.
                        var data = Core.Geometry.MarchingCubes.computeCubes(inputData.data);
                        if (parameters.smoothingIterations > 0)
                            data.laplacianSmooth(parameters.smoothingIterations);
                        return new MolecularIsoSurfaceGeometryData(data, inputData.bottomLeft, inputData.topRight, inputData.transform, data.annotation, parameters);
                    };
                    MolecularIsoSurfaceGeometryData.create = function (positions, atomIndices, params) {
                        if (!atomIndices.length) {
                            return new MolecularIsoSurfaceGeometryData(new Core.Geometry.MarchingCubes.MarchingCubesResult([], [], []), { x: 0, y: 0, z: 0 }, { x: 0, y: 0, z: 0 }, Geometry.LinearAlgebra.Matrix4.identity(), [], new MolecularIsoSurfaceParameters(params));
                        }
                        return MolecularIsoSurfaceGeometryData.fromField(new MolecularIsoField(params, positions, atomIndices));
                    };
                    return MolecularIsoSurfaceGeometryData;
                }());
                MolecularSurface.MolecularIsoSurfaceGeometryData = MolecularIsoSurfaceGeometryData;
            })(MolecularSurface = Geometry.MolecularSurface || (Geometry.MolecularSurface = {}));
        })(Geometry = Core.Geometry || (Core.Geometry = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Structure;
        (function (Structure) {
            "use strict";
            var DataTableColumnDescriptor = (function () {
                function DataTableColumnDescriptor(name, creator) {
                    this.name = name;
                    this.creator = creator;
                }
                return DataTableColumnDescriptor;
            }());
            Structure.DataTableColumnDescriptor = DataTableColumnDescriptor;
            var DataTable = (function () {
                function DataTable(count, source) {
                    this.count = count;
                    this.indices = new Int32Array(count);
                    this.columns = [];
                    for (var i = 0; i < count; i++) {
                        this.indices[i] = i;
                    }
                    if (source) {
                        for (var _i = 0, _a = source.columns; _i < _a.length; _i++) {
                            var col = _a[_i];
                            var data = source[col.name];
                            if (data instanceof Core.Utils.ChunkedArrayBuilder) {
                                data = data.compact();
                            }
                            Object.defineProperty(this, col.name, { enumerable: true, configurable: false, writable: false, value: data });
                            this.columns[this.columns.length] = col;
                        }
                    }
                }
                DataTable.prototype.clone = function () {
                    var b = new DataTableBuilder(this.count), cols = [];
                    for (var _i = 0, _a = this.columns; _i < _a.length; _i++) {
                        var c = _a[_i];
                        cols[cols.length] = {
                            src: this[c.name],
                            trg: b.addColumn(c.name, c.creator)
                        };
                    }
                    for (var _b = 0, cols_1 = cols; _b < cols_1.length; _b++) {
                        var c = cols_1[_b];
                        var s = c.src, t = c.trg;
                        for (var i = 0, m = this.count; i < m; i++) {
                            t[i] = s[i];
                        }
                    }
                    return b.seal();
                };
                DataTable.prototype.getBuilder = function (count) {
                    var b = new DataTableBuilder(count);
                    for (var _i = 0, _a = this.columns; _i < _a.length; _i++) {
                        var c = _a[_i];
                        b.addColumn(c.name, c.creator);
                    }
                    return b;
                };
                DataTable.prototype.getRawData = function () {
                    var _this = this;
                    return this.columns.map(function (c) { return _this[c.name]; });
                };
                return DataTable;
            }());
            Structure.DataTable = DataTable;
            var DataTableBuilder = (function () {
                function DataTableBuilder(count) {
                    this.columns = [];
                    this.count = count;
                }
                DataTableBuilder.prototype.addColumn = function (name, creator) {
                    var c = creator(this.count);
                    Object.defineProperty(this, name, { enumerable: true, configurable: false, writable: false, value: c });
                    this.columns[this.columns.length] = new DataTableColumnDescriptor(name, creator);
                    return c;
                };
                DataTableBuilder.prototype.getRawData = function () {
                    var _this = this;
                    return this.columns.map(function (c) { return _this[c.name]; });
                };
                /**
                 * This functions clones the table and defines all its column inside the constructor, hopefully making the JS engine
                 * use internal class instead of dictionary representation.
                 */
                DataTableBuilder.prototype.seal = function () {
                    return new DataTable(this.count, this);
                };
                return DataTableBuilder;
            }());
            Structure.DataTableBuilder = DataTableBuilder;
            (function (EntityType) {
                EntityType[EntityType["Polymer"] = 0] = "Polymer";
                EntityType[EntityType["NonPolymer"] = 1] = "NonPolymer";
                EntityType[EntityType["Water"] = 2] = "Water";
                EntityType[EntityType["Unknown"] = 3] = "Unknown";
            })(Structure.EntityType || (Structure.EntityType = {}));
            var EntityType = Structure.EntityType;
            (function (BondOrder) {
                BondOrder[BondOrder["None"] = 0] = "None";
                BondOrder[BondOrder["Single"] = 1] = "Single";
                BondOrder[BondOrder["Double"] = 2] = "Double";
                BondOrder[BondOrder["Triple"] = 3] = "Triple";
                BondOrder[BondOrder["Quadruple"] = 4] = "Quadruple";
            })(Structure.BondOrder || (Structure.BondOrder = {}));
            var BondOrder = Structure.BondOrder;
            var ComponentBondInfoEntry = (function () {
                function ComponentBondInfoEntry(id) {
                    this.id = id;
                    this.map = new Map();
                }
                ComponentBondInfoEntry.prototype.add = function (a, b, order, swap) {
                    if (swap === void 0) { swap = true; }
                    var e = this.map.get(a);
                    if (e !== void 0) {
                        var f = e.get(b);
                        if (f === void 0) {
                            e.set(b, order);
                        }
                    }
                    else {
                        var map = new Map();
                        map.set(b, order);
                        this.map.set(a, map);
                    }
                    if (swap)
                        this.add(b, a, order, false);
                };
                return ComponentBondInfoEntry;
            }());
            Structure.ComponentBondInfoEntry = ComponentBondInfoEntry;
            var ComponentBondInfo = (function () {
                function ComponentBondInfo() {
                    this.entries = new Map();
                }
                ComponentBondInfo.prototype.newEntry = function (id) {
                    var e = new ComponentBondInfoEntry(id);
                    this.entries.set(id, e);
                    return e;
                };
                return ComponentBondInfo;
            }());
            Structure.ComponentBondInfo = ComponentBondInfo;
            /**
             * Identifier for a reside that is a part of the polymer.
             */
            var PolyResidueIdentifier = (function () {
                function PolyResidueIdentifier(asymId, seqNumber, insCode) {
                    this.asymId = asymId;
                    this.seqNumber = seqNumber;
                    this.insCode = insCode;
                }
                PolyResidueIdentifier.areEqual = function (a, index, bAsymId, bSeqNumber, bInsCode) {
                    return a.asymId === bAsymId[index]
                        && a.seqNumber === bSeqNumber[index]
                        && a.insCode === bInsCode[index];
                };
                PolyResidueIdentifier.compare = function (a, b) {
                    if (a.asymId === b.asymId) {
                        if (a.seqNumber === b.seqNumber) {
                            if (a.insCode === b.insCode)
                                return 0;
                            if (a.insCode === void 0)
                                return -1;
                            if (b.insCode === void 0)
                                return 1;
                            return a.insCode < b.insCode ? -1 : 1;
                        }
                        return a.seqNumber < b.seqNumber ? -1 : 1;
                    }
                    return a.asymId < b.asymId ? -1 : 1;
                };
                PolyResidueIdentifier.compareResidue = function (a, index, bAsymId, bSeqNumber, bInsCode) {
                    if (a.asymId === bAsymId[index]) {
                        if (a.seqNumber === bSeqNumber[index]) {
                            if (a.insCode === bInsCode[index])
                                return 0;
                            if (a.insCode === void 0)
                                return -1;
                            if (bInsCode[index] === void 0)
                                return 1;
                            return a.insCode < bInsCode[index] ? -1 : 1;
                        }
                        return a.seqNumber < bSeqNumber[index] ? -1 : 1;
                    }
                    return a.asymId < bAsymId[index] ? -1 : 1;
                };
                return PolyResidueIdentifier;
            }());
            Structure.PolyResidueIdentifier = PolyResidueIdentifier;
            (function (SecondaryStructureType) {
                SecondaryStructureType[SecondaryStructureType["None"] = 0] = "None";
                SecondaryStructureType[SecondaryStructureType["Helix"] = 1] = "Helix";
                SecondaryStructureType[SecondaryStructureType["Turn"] = 2] = "Turn";
                SecondaryStructureType[SecondaryStructureType["Sheet"] = 3] = "Sheet";
                SecondaryStructureType[SecondaryStructureType["AminoSeq"] = 4] = "AminoSeq";
                SecondaryStructureType[SecondaryStructureType["Strand"] = 5] = "Strand";
            })(Structure.SecondaryStructureType || (Structure.SecondaryStructureType = {}));
            var SecondaryStructureType = Structure.SecondaryStructureType;
            var SecondaryStructureElement = (function () {
                function SecondaryStructureElement(type, startResidueId, endResidueId, info) {
                    if (info === void 0) { info = {}; }
                    this.type = type;
                    this.startResidueId = startResidueId;
                    this.endResidueId = endResidueId;
                    this.info = info;
                    this.startResidueIndex = -1;
                    this.endResidueIndex = -1;
                }
                Object.defineProperty(SecondaryStructureElement.prototype, "length", {
                    get: function () {
                        return this.endResidueIndex - this.startResidueIndex;
                    },
                    enumerable: true,
                    configurable: true
                });
                return SecondaryStructureElement;
            }());
            Structure.SecondaryStructureElement = SecondaryStructureElement;
            var SymmetryInfo = (function () {
                function SymmetryInfo(spacegroupName, cellSize, cellAngles, toFracTransform, isNonStandardCrytalFrame) {
                    this.spacegroupName = spacegroupName;
                    this.cellSize = cellSize;
                    this.cellAngles = cellAngles;
                    this.toFracTransform = toFracTransform;
                    this.isNonStandardCrytalFrame = isNonStandardCrytalFrame;
                }
                return SymmetryInfo;
            }());
            Structure.SymmetryInfo = SymmetryInfo;
            /**
             * Wraps an assembly operator.
             */
            var AssemblyOperator = (function () {
                function AssemblyOperator(id, name, operator) {
                    this.id = id;
                    this.name = name;
                    this.operator = operator;
                }
                return AssemblyOperator;
            }());
            Structure.AssemblyOperator = AssemblyOperator;
            /**
             * Wraps an assembly generation template.
             */
            var AssemblyGen = (function () {
                function AssemblyGen(name, operators, asymIds) {
                    this.name = name;
                    this.operators = operators;
                    this.asymIds = asymIds;
                }
                return AssemblyGen;
            }());
            Structure.AssemblyGen = AssemblyGen;
            /**
             * Information about the assemblies.
             */
            var AssemblyInfo = (function () {
                function AssemblyInfo(operators, assemblies) {
                    this.operators = operators;
                    this.assemblies = assemblies;
                }
                return AssemblyInfo;
            }());
            Structure.AssemblyInfo = AssemblyInfo;
            (function (MoleculeModelSource) {
                MoleculeModelSource[MoleculeModelSource["File"] = 0] = "File";
                MoleculeModelSource[MoleculeModelSource["Computed"] = 1] = "Computed";
            })(Structure.MoleculeModelSource || (Structure.MoleculeModelSource = {}));
            var MoleculeModelSource = Structure.MoleculeModelSource;
            var MoleculeModel = (function () {
                function MoleculeModel(id, modelId, atoms, residues, chains, entities, componentBonds, secondaryStructure, symmetryInfo, assemblyInfo, parent, source) {
                    this.id = id;
                    this.modelId = modelId;
                    this.atoms = atoms;
                    this.residues = residues;
                    this.chains = chains;
                    this.entities = entities;
                    this.componentBonds = componentBonds;
                    this.secondaryStructure = secondaryStructure;
                    this.symmetryInfo = symmetryInfo;
                    this.assemblyInfo = assemblyInfo;
                    this.parent = parent;
                    this.source = source;
                }
                Object.defineProperty(MoleculeModel.prototype, "queryContext", {
                    get: function () {
                        if (this._queryContext)
                            return this._queryContext;
                        this._queryContext = Structure.Queries.QueryContext.ofStructure(this);
                        return this._queryContext;
                    },
                    enumerable: true,
                    configurable: true
                });
                MoleculeModel.prototype.query = function (q) {
                    return q(this.queryContext);
                };
                return MoleculeModel;
            }());
            Structure.MoleculeModel = MoleculeModel;
            var Molecule = (function () {
                function Molecule(id, models) {
                    this.id = id;
                    this.models = models;
                }
                return Molecule;
            }());
            Structure.Molecule = Molecule;
        })(Structure = Core.Structure || (Core.Structure = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Structure;
        (function (Structure) {
            "use strict";
            var Mat4 = Core.Geometry.LinearAlgebra.Matrix4;
            var Vec4 = Core.Geometry.LinearAlgebra.Vector4;
            var Spacegroup = (function () {
                function Spacegroup(info) {
                    this.info = info;
                    this.temp = Mat4.empty();
                    this.tempV = new Float64Array(4);
                    if (SpacegroupTables.Spacegroup[info.spacegroupName] === void 0) {
                        throw "'" + info.spacegroupName + "' is not a known spacegroup.";
                    }
                    this.space = this.getSpace();
                    this.operators = this.getOperators();
                }
                Object.defineProperty(Spacegroup.prototype, "operatorCount", {
                    get: function () {
                        return this.operators.length;
                    },
                    enumerable: true,
                    configurable: true
                });
                Spacegroup.prototype.getOperatorMatrix = function (index, i, j, k, target) {
                    this.tempV[0] = i;
                    this.tempV[1] = j;
                    this.tempV[2] = k;
                    Mat4.fromTranslation(this.temp, this.tempV);
                    Mat4.mul(target, Mat4.mul(target, Mat4.mul(target, this.space.fromFrac, this.temp), this.operators[index]), this.space.toFrac);
                    return target;
                    //this.temp.setPosition(this.tempV.set(i, j, k));
                    //return target.copy(this.space.fromFrac).multiply(this.temp).multiply(this.operators[index]).multiply(this.space.toFrac);
                };
                Spacegroup.prototype.getSpace = function () {
                    var toFrac = this.info.toFracTransform, fromFrac = Mat4.empty();
                    Mat4.invert(fromFrac, toFrac);
                    return {
                        toFrac: toFrac,
                        fromFrac: fromFrac,
                        baseX: Vec4.transform(Vec4.create(), Vec4.fromValues(1, 0, 0, 1), toFrac),
                        baseY: Vec4.transform(Vec4.create(), Vec4.fromValues(0, 1, 0, 1), toFrac),
                        baseZ: Vec4.transform(Vec4.create(), Vec4.fromValues(0, 0, 1, 1), toFrac)
                    };
                };
                Spacegroup.getOperator = function (ids) {
                    var r1 = SpacegroupTables.Transform[ids[0]], r2 = SpacegroupTables.Transform[ids[1]], r3 = SpacegroupTables.Transform[ids[2]];
                    return Mat4.ofRows([r1, r2, r3, [0, 0, 0, 1]]);
                };
                Spacegroup.prototype.getOperators = function () {
                    var group = SpacegroupTables.Group[SpacegroupTables.Spacegroup[this.info.spacegroupName]];
                    return group.map(function (i) { return Spacegroup.getOperator(SpacegroupTables.Operator[i]); });
                };
                return Spacegroup;
            }());
            Structure.Spacegroup = Spacegroup;
            var SpacegroupTables;
            (function (SpacegroupTables) {
                SpacegroupTables.Transform = [
                    [1.0, 0.0, 0.0, 0.0],
                    [0.0, 1.0, 0.0, 0.0],
                    [0.0, 0.0, 1.0, 0.0],
                    [-1.0, 0.0, 0.0, 0.0],
                    [0.0, -1.0, 0.0, 0.0],
                    [0.0, 0.0, -1.0, 0.0],
                    [0.0, 1.0, 0.0, 0.5],
                    [1.0, 0.0, 0.0, 0.5],
                    [-1.0, 0.0, 0.0, 0.5],
                    [0.0, 0.0, 1.0, 0.5],
                    [0.0, -1.0, 0.0, 0.5],
                    [0.0, 0.0, -1.0, 0.5],
                    [1.0, 0.0, 0.0, 0.25],
                    [0.0, -1.0, 0.0, 0.25],
                    [0.0, 0.0, 1.0, 0.25],
                    [-1.0, 0.0, 0.0, 0.25],
                    [0.0, 1.0, 0.0, 0.25],
                    [0.0, -1.0, 0.0, 0.75],
                    [0.0, 0.0, 1.0, 0.75],
                    [0.0, 1.0, 0.0, 0.75],
                    [1.0, 0.0, 0.0, 0.75],
                    [-1.0, 0.0, 0.0, 0.75],
                    [0.0, 0.0, -1.0, 0.25],
                    [0.0, 0.0, -1.0, 0.75],
                    [1.0, -1.0, 0.0, 0.0],
                    [-1.0, 1.0, 0.0, 0.0],
                    [0.0, 0.0, 1.0, 0.333333333333333],
                    [0.0, 0.0, 1.0, 0.666666666666667],
                    [1.0, 0.0, 0.0, 0.666666666666667],
                    [0.0, 1.0, 0.0, 0.333333333333333],
                    [0.0, -1.0, 0.0, 0.666666666666667],
                    [1.0, -1.0, 0.0, 0.333333333333333],
                    [-1.0, 1.0, 0.0, 0.666666666666667],
                    [-1.0, 0.0, 0.0, 0.333333333333333],
                    [1.0, 0.0, 0.0, 0.333333333333333],
                    [0.0, 1.0, 0.0, 0.666666666666667],
                    [0.0, -1.0, 0.0, 0.333333333333333],
                    [1.0, -1.0, 0.0, 0.666666666666667],
                    [-1.0, 1.0, 0.0, 0.333333333333333],
                    [-1.0, 0.0, 0.0, 0.666666666666667],
                    [0.0, 0.0, -1.0, 0.333333333333333],
                    [0.0, 0.0, -1.0, 0.666666666666667],
                    [0.0, 0.0, 1.0, 0.833333333333333],
                    [0.0, 0.0, 1.0, 0.166666666666667],
                    [0.0, 0.0, -1.0, 0.833333333333333],
                    [0.0, 0.0, -1.0, 0.166666666666667],
                ];
                SpacegroupTables.Operator = [
                    [0, 1, 2],
                    [3, 4, 5],
                    [3, 1, 5],
                    [3, 6, 5],
                    [7, 6, 2],
                    [8, 6, 5],
                    [0, 4, 2],
                    [0, 4, 9],
                    [7, 10, 2],
                    [7, 10, 9],
                    [0, 10, 2],
                    [8, 10, 5],
                    [3, 1, 11],
                    [3, 6, 11],
                    [0, 10, 9],
                    [8, 6, 11],
                    [3, 4, 2],
                    [0, 4, 5],
                    [3, 4, 9],
                    [7, 10, 5],
                    [8, 4, 9],
                    [8, 10, 9],
                    [8, 10, 2],
                    [0, 6, 9],
                    [3, 10, 9],
                    [0, 10, 11],
                    [7, 1, 9],
                    [8, 1, 11],
                    [7, 4, 11],
                    [7, 6, 9],
                    [7, 10, 11],
                    [3, 10, 2],
                    [8, 1, 5],
                    [0, 4, 11],
                    [3, 1, 2],
                    [3, 1, 9],
                    [7, 4, 2],
                    [8, 1, 2],
                    [8, 1, 9],
                    [3, 6, 9],
                    [7, 4, 9],
                    [8, 6, 2],
                    [8, 6, 9],
                    [3, 6, 2],
                    [12, 13, 14],
                    [15, 16, 14],
                    [12, 17, 18],
                    [15, 19, 18],
                    [20, 13, 18],
                    [21, 16, 18],
                    [20, 17, 14],
                    [21, 19, 14],
                    [0, 1, 5],
                    [8, 10, 11],
                    [7, 6, 11],
                    [7, 6, 5],
                    [8, 4, 2],
                    [7, 4, 5],
                    [7, 1, 5],
                    [7, 1, 11],
                    [0, 10, 5],
                    [0, 1, 11],
                    [0, 6, 11],
                    [0, 6, 5],
                    [3, 10, 11],
                    [8, 4, 11],
                    [15, 13, 22],
                    [12, 16, 22],
                    [15, 17, 23],
                    [12, 19, 23],
                    [21, 13, 23],
                    [20, 16, 23],
                    [21, 17, 22],
                    [20, 19, 22],
                    [4, 0, 2],
                    [1, 3, 2],
                    [4, 0, 14],
                    [1, 3, 18],
                    [4, 0, 9],
                    [1, 3, 9],
                    [4, 0, 18],
                    [1, 3, 14],
                    [10, 7, 9],
                    [6, 8, 9],
                    [4, 7, 14],
                    [6, 3, 18],
                    [10, 0, 18],
                    [1, 8, 14],
                    [1, 3, 5],
                    [4, 0, 5],
                    [6, 8, 11],
                    [10, 7, 11],
                    [1, 3, 11],
                    [4, 0, 11],
                    [10, 7, 2],
                    [6, 8, 2],
                    [3, 10, 22],
                    [7, 1, 23],
                    [8, 4, 23],
                    [0, 6, 22],
                    [1, 0, 5],
                    [4, 3, 5],
                    [1, 0, 23],
                    [4, 3, 22],
                    [10, 7, 14],
                    [6, 8, 18],
                    [8, 6, 22],
                    [7, 10, 23],
                    [4, 3, 11],
                    [1, 0, 11],
                    [1, 0, 22],
                    [4, 3, 23],
                    [10, 7, 18],
                    [6, 8, 14],
                    [8, 6, 23],
                    [7, 10, 22],
                    [6, 7, 11],
                    [10, 8, 11],
                    [8, 1, 23],
                    [0, 10, 22],
                    [3, 6, 22],
                    [7, 4, 23],
                    [4, 3, 2],
                    [1, 0, 2],
                    [10, 8, 2],
                    [6, 7, 2],
                    [4, 3, 9],
                    [1, 0, 9],
                    [10, 8, 9],
                    [6, 7, 9],
                    [4, 8, 14],
                    [6, 0, 18],
                    [10, 3, 18],
                    [1, 7, 14],
                    [4, 8, 18],
                    [6, 0, 14],
                    [10, 3, 14],
                    [1, 7, 18],
                    [6, 7, 5],
                    [10, 8, 5],
                    [6, 8, 5],
                    [10, 7, 5],
                    [8, 1, 22],
                    [0, 10, 23],
                    [3, 6, 23],
                    [7, 4, 22],
                    [4, 24, 2],
                    [25, 3, 2],
                    [4, 24, 26],
                    [25, 3, 27],
                    [4, 24, 27],
                    [25, 3, 26],
                    [28, 29, 26],
                    [30, 31, 26],
                    [32, 33, 26],
                    [34, 35, 27],
                    [36, 37, 27],
                    [38, 39, 27],
                    [2, 0, 1],
                    [1, 2, 0],
                    [1, 25, 5],
                    [24, 0, 5],
                    [39, 36, 40],
                    [35, 38, 40],
                    [37, 34, 40],
                    [33, 30, 41],
                    [29, 32, 41],
                    [31, 28, 41],
                    [5, 3, 4],
                    [4, 5, 3],
                    [25, 1, 5],
                    [0, 24, 5],
                    [24, 4, 5],
                    [3, 25, 5],
                    [4, 3, 41],
                    [25, 1, 40],
                    [24, 4, 41],
                    [3, 25, 40],
                    [4, 3, 40],
                    [25, 1, 41],
                    [24, 4, 40],
                    [3, 25, 41],
                    [35, 34, 40],
                    [37, 36, 40],
                    [39, 38, 40],
                    [29, 28, 41],
                    [31, 30, 41],
                    [33, 32, 41],
                    [3, 5, 4],
                    [5, 4, 3],
                    [25, 1, 2],
                    [0, 24, 2],
                    [24, 4, 2],
                    [3, 25, 2],
                    [25, 1, 9],
                    [0, 24, 9],
                    [24, 4, 9],
                    [3, 25, 9],
                    [30, 33, 26],
                    [32, 29, 26],
                    [28, 31, 26],
                    [36, 39, 27],
                    [38, 35, 27],
                    [34, 37, 27],
                    [0, 2, 1],
                    [2, 1, 0],
                    [30, 33, 42],
                    [32, 29, 42],
                    [28, 31, 42],
                    [36, 39, 43],
                    [38, 35, 43],
                    [34, 37, 43],
                    [7, 9, 6],
                    [9, 6, 7],
                    [25, 1, 11],
                    [0, 24, 11],
                    [24, 4, 11],
                    [3, 25, 11],
                    [35, 34, 44],
                    [37, 36, 44],
                    [39, 38, 44],
                    [29, 28, 45],
                    [31, 30, 45],
                    [33, 32, 45],
                    [8, 11, 10],
                    [11, 10, 8],
                    [1, 25, 2],
                    [24, 0, 2],
                    [1, 25, 42],
                    [24, 0, 43],
                    [1, 25, 43],
                    [24, 0, 42],
                    [1, 25, 27],
                    [24, 0, 26],
                    [1, 25, 26],
                    [24, 0, 27],
                    [1, 25, 9],
                    [24, 0, 9],
                    [4, 24, 5],
                    [25, 3, 5],
                    [4, 24, 11],
                    [25, 3, 11],
                    [1, 0, 40],
                    [4, 3, 44],
                    [0, 24, 45],
                    [1, 0, 41],
                    [4, 3, 45],
                    [0, 24, 44],
                    [0, 24, 40],
                    [0, 24, 41],
                    [2, 3, 4],
                    [5, 3, 1],
                    [5, 0, 4],
                    [4, 2, 3],
                    [1, 5, 3],
                    [4, 5, 0],
                    [2, 7, 6],
                    [2, 8, 10],
                    [5, 8, 6],
                    [5, 7, 10],
                    [1, 9, 7],
                    [4, 9, 8],
                    [1, 11, 8],
                    [4, 11, 7],
                    [9, 0, 6],
                    [9, 3, 10],
                    [11, 3, 6],
                    [11, 0, 10],
                    [6, 2, 7],
                    [10, 2, 8],
                    [6, 5, 8],
                    [10, 5, 7],
                    [9, 7, 1],
                    [9, 8, 4],
                    [11, 8, 1],
                    [11, 7, 4],
                    [6, 9, 0],
                    [10, 9, 3],
                    [6, 11, 3],
                    [10, 11, 0],
                    [9, 7, 6],
                    [9, 8, 10],
                    [11, 8, 6],
                    [11, 7, 10],
                    [6, 9, 7],
                    [10, 9, 8],
                    [6, 11, 8],
                    [10, 11, 7],
                    [2, 3, 10],
                    [5, 8, 1],
                    [11, 0, 4],
                    [10, 2, 3],
                    [1, 5, 8],
                    [4, 11, 0],
                    [5, 0, 1],
                    [2, 0, 4],
                    [2, 3, 1],
                    [1, 5, 0],
                    [4, 2, 0],
                    [1, 2, 3],
                    [11, 8, 10],
                    [11, 7, 6],
                    [9, 7, 10],
                    [9, 8, 6],
                    [10, 11, 8],
                    [6, 11, 7],
                    [10, 9, 7],
                    [6, 9, 8],
                    [5, 8, 10],
                    [5, 7, 6],
                    [2, 7, 10],
                    [2, 8, 6],
                    [4, 11, 8],
                    [1, 11, 7],
                    [4, 9, 7],
                    [1, 9, 8],
                    [11, 3, 10],
                    [11, 0, 6],
                    [9, 0, 10],
                    [9, 3, 6],
                    [10, 5, 8],
                    [6, 5, 7],
                    [10, 2, 7],
                    [6, 2, 8],
                    [11, 8, 4],
                    [11, 7, 1],
                    [9, 7, 4],
                    [9, 8, 1],
                    [10, 11, 3],
                    [6, 11, 0],
                    [10, 9, 0],
                    [6, 9, 3],
                    [22, 15, 13],
                    [22, 12, 16],
                    [14, 12, 13],
                    [14, 15, 16],
                    [13, 22, 15],
                    [16, 22, 12],
                    [13, 14, 12],
                    [16, 14, 15],
                    [22, 21, 17],
                    [22, 20, 19],
                    [14, 20, 17],
                    [14, 21, 19],
                    [13, 23, 21],
                    [16, 23, 20],
                    [13, 18, 20],
                    [16, 18, 21],
                    [23, 15, 17],
                    [23, 12, 19],
                    [18, 12, 17],
                    [18, 15, 19],
                    [17, 22, 21],
                    [19, 22, 20],
                    [17, 14, 20],
                    [19, 14, 21],
                    [23, 21, 13],
                    [23, 20, 16],
                    [18, 20, 13],
                    [18, 21, 16],
                    [17, 23, 15],
                    [19, 23, 12],
                    [17, 18, 12],
                    [19, 18, 15],
                    [5, 0, 6],
                    [2, 7, 4],
                    [9, 3, 1],
                    [6, 5, 0],
                    [4, 2, 7],
                    [1, 9, 3],
                    [0, 2, 4],
                    [3, 2, 1],
                    [0, 5, 1],
                    [2, 1, 3],
                    [2, 4, 0],
                    [5, 1, 0],
                    [7, 9, 10],
                    [8, 9, 6],
                    [7, 11, 6],
                    [9, 6, 8],
                    [9, 10, 7],
                    [11, 6, 7],
                    [1, 7, 11],
                    [4, 8, 11],
                    [1, 8, 9],
                    [4, 7, 9],
                    [0, 9, 10],
                    [3, 9, 6],
                    [3, 11, 10],
                    [0, 11, 6],
                    [2, 6, 8],
                    [2, 10, 7],
                    [5, 6, 7],
                    [5, 10, 8],
                    [6, 0, 11],
                    [10, 3, 11],
                    [6, 3, 9],
                    [10, 0, 9],
                    [7, 2, 10],
                    [8, 2, 6],
                    [8, 5, 10],
                    [7, 5, 6],
                    [9, 1, 8],
                    [9, 4, 7],
                    [11, 1, 7],
                    [11, 4, 8],
                    [7, 9, 4],
                    [8, 9, 1],
                    [8, 11, 4],
                    [7, 11, 1],
                    [9, 6, 3],
                    [9, 10, 0],
                    [11, 6, 0],
                    [11, 10, 3],
                    [19, 12, 23],
                    [13, 15, 22],
                    [16, 21, 18],
                    [17, 20, 14],
                    [20, 14, 17],
                    [21, 18, 16],
                    [15, 22, 13],
                    [12, 23, 19],
                    [18, 16, 21],
                    [14, 17, 20],
                    [23, 19, 12],
                    [22, 13, 15],
                    [19, 20, 22],
                    [13, 21, 23],
                    [16, 15, 14],
                    [17, 12, 18],
                    [20, 18, 13],
                    [21, 14, 19],
                    [15, 23, 17],
                    [12, 22, 16],
                    [18, 19, 15],
                    [14, 13, 12],
                    [23, 16, 20],
                    [22, 17, 21],
                    [16, 12, 22],
                    [17, 15, 23],
                    [19, 21, 14],
                    [13, 20, 18],
                    [12, 14, 13],
                    [15, 18, 19],
                    [21, 22, 17],
                    [20, 23, 16],
                    [14, 16, 15],
                    [18, 17, 12],
                    [22, 19, 20],
                    [23, 13, 21],
                    [16, 20, 23],
                    [17, 21, 22],
                    [19, 15, 18],
                    [13, 12, 14],
                    [12, 18, 17],
                    [15, 14, 16],
                    [21, 23, 13],
                    [20, 22, 19],
                    [14, 19, 21],
                    [18, 13, 20],
                    [22, 16, 12],
                    [23, 17, 15],
                    [19, 12, 22],
                    [17, 21, 23],
                    [16, 15, 18],
                    [13, 20, 14],
                    [20, 14, 13],
                    [15, 18, 16],
                    [21, 23, 17],
                    [12, 22, 19],
                    [18, 16, 15],
                    [14, 13, 20],
                    [22, 19, 12],
                    [23, 17, 21],
                    [3, 2, 4],
                    [3, 5, 1],
                    [0, 5, 4],
                    [2, 4, 3],
                    [5, 1, 3],
                    [5, 4, 0],
                    [1, 7, 9],
                    [4, 8, 9],
                    [1, 8, 11],
                    [4, 7, 11],
                    [0, 9, 6],
                    [3, 9, 10],
                    [3, 11, 6],
                    [0, 11, 10],
                    [2, 6, 7],
                    [2, 10, 8],
                    [5, 6, 8],
                    [5, 10, 7],
                    [6, 0, 9],
                    [10, 3, 9],
                    [6, 3, 11],
                    [10, 0, 11],
                    [7, 2, 6],
                    [8, 2, 10],
                    [8, 5, 6],
                    [7, 5, 10],
                    [9, 1, 7],
                    [9, 4, 8],
                    [11, 1, 8],
                    [11, 4, 7],
                    [7, 9, 1],
                    [8, 9, 4],
                    [8, 11, 1],
                    [7, 11, 4],
                    [9, 6, 0],
                    [9, 10, 3],
                    [11, 6, 3],
                    [11, 10, 0],
                    [8, 9, 10],
                    [8, 11, 6],
                    [7, 11, 10],
                    [9, 10, 8],
                    [11, 6, 8],
                    [11, 10, 7],
                    [6, 0, 2],
                    [10, 3, 2],
                    [6, 3, 5],
                    [10, 0, 5],
                    [7, 2, 1],
                    [8, 2, 4],
                    [8, 5, 1],
                    [7, 5, 4],
                    [9, 1, 0],
                    [9, 4, 3],
                    [11, 1, 3],
                    [11, 4, 0],
                    [1, 7, 2],
                    [4, 8, 2],
                    [1, 8, 5],
                    [4, 7, 5],
                    [0, 9, 1],
                    [3, 9, 4],
                    [3, 11, 1],
                    [0, 11, 4],
                    [2, 6, 0],
                    [2, 10, 3],
                    [5, 6, 3],
                    [5, 10, 0],
                    [0, 2, 6],
                    [3, 2, 10],
                    [3, 5, 6],
                    [0, 5, 10],
                    [2, 1, 7],
                    [2, 4, 8],
                    [5, 1, 8],
                    [5, 4, 7],
                    [16, 12, 14],
                    [13, 21, 18],
                    [19, 15, 23],
                    [17, 20, 22],
                    [12, 14, 16],
                    [21, 18, 13],
                    [15, 23, 19],
                    [20, 22, 17],
                    [14, 16, 12],
                    [18, 13, 21],
                    [23, 19, 15],
                    [22, 17, 20],
                    [19, 20, 18],
                    [17, 15, 14],
                    [16, 21, 22],
                    [13, 12, 23],
                    [20, 18, 19],
                    [15, 14, 17],
                    [21, 22, 16],
                    [12, 23, 13],
                    [18, 19, 20],
                    [14, 17, 15],
                    [22, 16, 21],
                    [23, 13, 12],
                    [6, 0, 5],
                    [10, 3, 5],
                    [6, 3, 2],
                    [10, 0, 2],
                    [7, 2, 4],
                    [8, 2, 1],
                    [8, 5, 4],
                    [7, 5, 1],
                    [9, 1, 3],
                    [9, 4, 0],
                    [11, 1, 0],
                    [11, 4, 3],
                    [1, 7, 5],
                    [4, 8, 5],
                    [1, 8, 2],
                    [4, 7, 2],
                    [0, 9, 4],
                    [3, 9, 1],
                    [3, 11, 4],
                    [0, 11, 1],
                    [2, 6, 3],
                    [2, 10, 0],
                    [5, 6, 0],
                    [5, 10, 3],
                    [0, 2, 10],
                    [3, 2, 6],
                    [3, 5, 10],
                    [0, 5, 6],
                    [2, 1, 8],
                    [2, 4, 7],
                    [5, 1, 7],
                    [5, 4, 8],
                    [21, 17, 23],
                    [20, 16, 22],
                    [12, 13, 18],
                    [15, 19, 14],
                    [23, 21, 17],
                    [22, 20, 16],
                    [18, 12, 13],
                    [14, 15, 19],
                    [17, 23, 21],
                    [16, 22, 20],
                    [13, 18, 12],
                    [19, 14, 15],
                    [21, 13, 22],
                    [20, 19, 23],
                    [12, 17, 14],
                    [15, 16, 18],
                    [23, 15, 13],
                    [22, 12, 19],
                    [18, 20, 17],
                    [14, 21, 16],
                    [17, 22, 15],
                    [16, 23, 12],
                    [13, 14, 20],
                    [19, 18, 21],
                    [15, 17, 22],
                    [12, 16, 23],
                    [20, 13, 14],
                    [21, 19, 18],
                    [22, 21, 13],
                    [23, 20, 19],
                    [14, 12, 17],
                    [18, 15, 16],
                    [13, 23, 15],
                    [19, 22, 12],
                    [17, 18, 20],
                    [16, 14, 21],
                    [15, 13, 23],
                    [12, 19, 22],
                    [20, 17, 18],
                    [21, 16, 14],
                    [22, 15, 17],
                    [23, 12, 16],
                    [14, 20, 13],
                    [18, 21, 19],
                    [13, 22, 21],
                    [19, 23, 20],
                    [17, 14, 12],
                    [16, 18, 15],
                    [6, 5, 3],
                    [4, 9, 3],
                    [9, 3, 4],
                    [5, 7, 4],
                    [4, 5, 7],
                    [5, 3, 6],
                ];
                SpacegroupTables.Group = [
                    [0],
                    [0, 1],
                    [0, 2],
                    [0, 3],
                    [0, 2, 4, 5],
                    [0, 6],
                    [0, 7],
                    [0, 6, 4, 8],
                    [0, 7, 4, 9],
                    [0, 6, 2, 1],
                    [0, 3, 1, 10],
                    [0, 6, 2, 1, 4, 8, 5, 11],
                    [0, 12, 1, 7],
                    [0, 1, 13, 14],
                    [0, 12, 1, 7, 4, 15, 11, 9],
                    [0, 16, 2, 17],
                    [0, 18, 12, 17],
                    [0, 16, 5, 19],
                    [0, 20, 13, 19],
                    [0, 18, 12, 17, 4, 21, 15, 19],
                    [0, 16, 2, 17, 4, 22, 5, 19],
                    [0, 16, 2, 17, 23, 24, 13, 25, 26, 20, 27, 28, 4, 22, 5, 19],
                    [0, 16, 17, 2, 29, 21, 30, 15],
                    [0, 20, 13, 19, 29, 31, 32, 33],
                    [0, 16, 6, 34],
                    [0, 18, 7, 34],
                    [0, 16, 7, 35],
                    [0, 16, 36, 37],
                    [0, 18, 36, 38],
                    [0, 16, 14, 39],
                    [0, 20, 40, 34],
                    [0, 16, 8, 41],
                    [0, 18, 8, 42],
                    [0, 16, 9, 42],
                    [0, 16, 6, 34, 4, 22, 8, 41],
                    [0, 18, 7, 34, 4, 21, 9, 41],
                    [0, 16, 7, 35, 4, 22, 9, 42],
                    [0, 16, 6, 34, 23, 24, 14, 39],
                    [0, 16, 10, 43, 23, 24, 7, 35],
                    [0, 16, 36, 37, 23, 24, 9, 42],
                    [0, 16, 8, 41, 23, 24, 40, 38],
                    [0, 16, 6, 34, 23, 24, 14, 39, 26, 20, 40, 38, 4, 22, 8, 41],
                    [0, 16, 44, 45, 23, 24, 46, 47, 26, 20, 48, 49, 4, 22, 50, 51],
                    [0, 16, 6, 34, 29, 21, 9, 42],
                    [0, 16, 8, 41, 29, 21, 7, 35],
                    [0, 16, 36, 37, 29, 21, 14, 39],
                    [0, 16, 2, 17, 1, 52, 6, 34],
                    [0, 16, 2, 17, 53, 54, 9, 42],
                    [0, 16, 12, 33, 1, 52, 7, 35],
                    [0, 16, 2, 17, 11, 55, 8, 41],
                    [0, 56, 2, 57, 1, 58, 6, 37],
                    [0, 56, 15, 25, 1, 58, 9, 39],
                    [0, 20, 27, 17, 1, 59, 40, 34],
                    [0, 56, 12, 28, 1, 58, 7, 38],
                    [0, 16, 5, 19, 1, 52, 8, 41],
                    [0, 22, 13, 28, 1, 55, 14, 38],
                    [0, 18, 13, 60, 1, 61, 14, 43],
                    [0, 16, 15, 30, 1, 52, 9, 42],
                    [0, 16, 5, 19, 11, 55, 6, 34],
                    [0, 21, 12, 19, 1, 54, 7, 41],
                    [0, 20, 13, 19, 1, 59, 14, 41],
                    [0, 20, 3, 30, 1, 59, 10, 42],
                    [0, 18, 12, 17, 1, 61, 7, 34, 4, 21, 15, 19, 11, 54, 9, 41],
                    [0, 24, 13, 17, 1, 62, 14, 34, 4, 20, 27, 19, 11, 59, 40, 41],
                    [0, 16, 2, 17, 1, 52, 6, 34, 4, 22, 5, 19, 11, 55, 8, 41],
                    [0, 16, 12, 33, 1, 52, 7, 35, 4, 22, 15, 30, 11, 55, 9, 42],
                    [0, 31, 3, 17, 1, 63, 10, 34, 4, 56, 32, 19, 11, 58, 36, 41],
                    [0, 22, 2, 19, 64, 59, 14, 38, 4, 16, 5, 17, 65, 62, 40, 39],
                    [0, 16, 2, 17, 1, 52, 6, 34, 23, 24, 13, 25, 64, 62, 14, 39, 26, 20, 27, 28, 65, 59, 40, 38, 4, 22, 5, 19, 11, 55, 8, 41],
                    [0, 16, 2, 17, 66, 67, 44, 45, 23, 24, 13, 25, 68, 69, 46, 47, 26, 20, 27, 28, 70, 71, 48, 49, 4, 22, 5, 19, 72, 73, 50, 51],
                    [0, 16, 2, 17, 1, 52, 6, 34, 29, 21, 15, 30, 53, 54, 9, 42],
                    [0, 16, 5, 19, 1, 52, 8, 41, 29, 21, 12, 33, 53, 54, 7, 35],
                    [0, 20, 13, 19, 1, 59, 14, 41, 29, 31, 32, 33, 53, 63, 36, 35],
                    [0, 31, 3, 17, 1, 63, 10, 34, 29, 20, 27, 30, 53, 59, 40, 42],
                    [0, 16, 74, 75],
                    [0, 18, 76, 77],
                    [0, 16, 78, 79],
                    [0, 18, 80, 81],
                    [0, 16, 74, 75, 29, 21, 82, 83],
                    [0, 21, 84, 85, 29, 16, 86, 87],
                    [0, 16, 88, 89],
                    [0, 16, 88, 89, 29, 21, 90, 91],
                    [0, 16, 74, 75, 1, 52, 88, 89],
                    [0, 16, 78, 79, 1, 52, 92, 93],
                    [0, 16, 94, 95, 11, 55, 88, 89],
                    [0, 16, 82, 83, 53, 54, 88, 89],
                    [0, 16, 74, 75, 1, 52, 88, 89, 29, 21, 82, 83, 53, 54, 90, 91],
                    [0, 21, 84, 85, 96, 97, 88, 91, 29, 16, 86, 87, 98, 99, 90, 89],
                    [0, 16, 74, 75, 2, 17, 100, 101],
                    [0, 16, 94, 95, 5, 19, 100, 101],
                    [0, 18, 76, 77, 2, 33, 102, 103],
                    [0, 18, 104, 105, 106, 107, 100, 108],
                    [0, 16, 78, 79, 2, 17, 109, 108],
                    [0, 16, 82, 83, 15, 30, 100, 101],
                    [0, 18, 80, 81, 2, 33, 110, 111],
                    [0, 18, 112, 113, 114, 115, 100, 108],
                    [0, 16, 74, 75, 2, 17, 100, 101, 29, 21, 82, 83, 15, 30, 116, 117],
                    [0, 21, 84, 85, 118, 119, 116, 101, 29, 16, 86, 87, 120, 121, 100, 117],
                    [0, 16, 74, 75, 6, 34, 122, 123],
                    [0, 16, 74, 75, 8, 41, 124, 125],
                    [0, 16, 78, 79, 7, 35, 122, 123],
                    [0, 16, 82, 83, 9, 42, 122, 123],
                    [0, 16, 74, 75, 7, 35, 126, 127],
                    [0, 16, 74, 75, 9, 42, 128, 129],
                    [0, 16, 78, 79, 6, 34, 126, 127],
                    [0, 16, 78, 79, 8, 41, 128, 129],
                    [0, 16, 74, 75, 6, 34, 122, 123, 29, 21, 82, 83, 9, 42, 128, 129],
                    [0, 16, 74, 75, 7, 35, 126, 127, 29, 21, 82, 83, 8, 41, 124, 125],
                    [0, 21, 84, 85, 6, 42, 130, 131, 29, 16, 86, 87, 9, 34, 132, 133],
                    [0, 21, 84, 85, 7, 41, 134, 135, 29, 16, 86, 87, 8, 35, 136, 137],
                    [0, 16, 89, 88, 2, 17, 122, 123],
                    [0, 16, 89, 88, 12, 33, 126, 127],
                    [0, 16, 89, 88, 5, 19, 124, 125],
                    [0, 16, 89, 88, 15, 30, 128, 129],
                    [0, 16, 88, 89, 6, 34, 100, 101],
                    [0, 16, 89, 88, 7, 35, 109, 108],
                    [0, 16, 89, 88, 8, 41, 138, 139],
                    [0, 16, 89, 88, 9, 42, 116, 117],
                    [0, 16, 89, 88, 6, 34, 100, 101, 29, 21, 91, 90, 9, 42, 116, 117],
                    [0, 16, 89, 88, 7, 35, 109, 108, 29, 21, 91, 90, 8, 41, 138, 139],
                    [0, 16, 89, 88, 2, 17, 122, 123, 29, 21, 91, 90, 15, 30, 128, 129],
                    [0, 16, 89, 88, 118, 121, 132, 131, 29, 21, 91, 90, 120, 119, 130, 133],
                    [0, 16, 74, 75, 2, 17, 100, 101, 1, 52, 88, 89, 6, 34, 122, 123],
                    [0, 16, 74, 75, 12, 33, 109, 108, 1, 52, 88, 89, 7, 35, 126, 127],
                    [0, 16, 74, 75, 2, 17, 100, 101, 11, 55, 140, 141, 8, 41, 124, 125],
                    [0, 16, 74, 75, 2, 17, 100, 101, 53, 54, 90, 91, 9, 42, 128, 129],
                    [0, 16, 74, 75, 5, 19, 138, 139, 1, 52, 88, 89, 8, 41, 124, 125],
                    [0, 16, 74, 75, 15, 30, 116, 117, 1, 52, 88, 89, 9, 42, 128, 129],
                    [0, 16, 94, 95, 5, 19, 100, 101, 11, 55, 88, 89, 6, 34, 124, 125],
                    [0, 16, 94, 95, 15, 30, 109, 108, 11, 55, 88, 89, 7, 35, 128, 129],
                    [0, 16, 78, 79, 2, 17, 109, 108, 1, 52, 92, 93, 6, 34, 126, 127],
                    [0, 16, 78, 79, 12, 33, 100, 101, 1, 52, 92, 93, 7, 35, 122, 123],
                    [0, 16, 82, 83, 12, 33, 138, 139, 53, 54, 88, 89, 8, 41, 126, 127],
                    [0, 16, 82, 83, 2, 17, 116, 117, 53, 54, 88, 89, 9, 42, 122, 123],
                    [0, 16, 78, 79, 5, 19, 116, 117, 1, 52, 92, 93, 8, 41, 128, 129],
                    [0, 16, 82, 83, 15, 30, 100, 101, 1, 52, 90, 91, 9, 42, 122, 123],
                    [0, 16, 82, 83, 15, 30, 100, 101, 53, 54, 88, 89, 6, 34, 128, 129],
                    [0, 16, 82, 83, 5, 19, 109, 108, 53, 54, 88, 89, 7, 35, 124, 125],
                    [0, 16, 74, 75, 2, 17, 100, 101, 1, 52, 88, 89, 6, 34, 122, 123, 29, 21, 82, 83, 15, 30, 116, 117, 53, 54, 90, 91, 9, 42, 128, 129],
                    [0, 16, 74, 75, 12, 33, 109, 108, 1, 52, 88, 89, 7, 35, 126, 127, 29, 21, 82, 83, 5, 19, 138, 139, 53, 54, 90, 91, 8, 41, 124, 125],
                    [0, 21, 84, 85, 118, 119, 116, 101, 96, 97, 88, 91, 9, 34, 132, 133, 29, 16, 86, 87, 120, 121, 100, 117, 98, 99, 90, 89, 6, 42, 130, 131],
                    [0, 21, 84, 85, 142, 143, 138, 108, 96, 97, 88, 91, 8, 35, 136, 137, 29, 16, 86, 87, 144, 145, 109, 139, 98, 99, 90, 89, 7, 41, 134, 135],
                    [0, 146, 147],
                    [0, 148, 149],
                    [0, 150, 151],
                    [0, 146, 147, 152, 153, 154, 155, 156, 157],
                    [0, 158, 159],
                    [0, 146, 147, 1, 160, 161],
                    [0, 146, 147, 1, 160, 161, 152, 153, 154, 162, 163, 164, 155, 156, 157, 165, 166, 167],
                    [0, 158, 159, 1, 168, 169],
                    [0, 146, 147, 101, 170, 171],
                    [0, 146, 147, 100, 172, 173],
                    [0, 148, 149, 174, 175, 171],
                    [0, 148, 149, 100, 176, 177],
                    [0, 150, 151, 178, 179, 171],
                    [0, 150, 151, 100, 180, 181],
                    [0, 146, 147, 100, 172, 173, 152, 153, 154, 182, 183, 184, 155, 156, 157, 185, 186, 187],
                    [0, 158, 159, 101, 188, 189],
                    [0, 146, 147, 122, 190, 191],
                    [0, 146, 147, 123, 192, 193],
                    [0, 146, 147, 126, 194, 195],
                    [0, 146, 147, 127, 196, 197],
                    [0, 146, 147, 122, 190, 191, 152, 153, 154, 198, 199, 200, 155, 156, 157, 201, 202, 203],
                    [0, 158, 159, 123, 204, 205],
                    [0, 146, 147, 126, 194, 195, 152, 153, 154, 206, 207, 208, 155, 156, 157, 209, 210, 211],
                    [0, 158, 159, 129, 212, 213],
                    [0, 146, 147, 101, 170, 171, 1, 160, 161, 123, 192, 193],
                    [0, 146, 147, 108, 214, 215, 1, 160, 161, 127, 196, 197],
                    [0, 146, 147, 100, 172, 173, 1, 160, 161, 122, 190, 191],
                    [0, 146, 147, 109, 216, 217, 1, 160, 161, 126, 194, 195],
                    [0, 146, 147, 100, 172, 173, 1, 160, 161, 122, 190, 191, 152, 153, 154, 182, 183, 184, 162, 163, 164, 198, 199, 200, 155, 156, 157, 185, 186, 187, 165, 166, 167, 201, 202, 203],
                    [0, 158, 159, 101, 188, 189, 1, 168, 169, 123, 204, 205],
                    [0, 146, 147, 109, 216, 217, 1, 160, 161, 126, 194, 195, 152, 153, 154, 218, 219, 220, 162, 163, 164, 206, 207, 208, 155, 156, 157, 221, 222, 223, 165, 166, 167, 209, 210, 211],
                    [0, 158, 159, 117, 224, 225, 1, 168, 169, 129, 212, 213],
                    [0, 146, 147, 16, 226, 227],
                    [0, 148, 149, 18, 228, 229],
                    [0, 150, 151, 18, 230, 231],
                    [0, 150, 151, 16, 232, 233],
                    [0, 148, 149, 16, 234, 235],
                    [0, 146, 147, 18, 236, 237],
                    [0, 146, 147, 52, 238, 239],
                    [0, 146, 147, 16, 226, 227, 1, 160, 161, 52, 238, 239],
                    [0, 146, 147, 18, 236, 237, 1, 160, 161, 61, 240, 241],
                    [0, 146, 147, 16, 226, 227, 100, 172, 173, 101, 170, 171],
                    [0, 148, 149, 18, 228, 229, 242, 172, 181, 243, 214, 244],
                    [0, 150, 151, 18, 230, 231, 245, 172, 177, 246, 214, 247],
                    [0, 150, 151, 16, 232, 233, 245, 172, 177, 174, 170, 248],
                    [0, 148, 149, 16, 234, 235, 242, 172, 181, 178, 170, 249],
                    [0, 146, 147, 18, 236, 237, 100, 172, 173, 108, 214, 215],
                    [0, 146, 147, 16, 226, 227, 122, 190, 191, 123, 192, 193],
                    [0, 146, 147, 16, 226, 227, 126, 194, 195, 127, 196, 197],
                    [0, 146, 147, 18, 236, 237, 126, 194, 195, 123, 192, 193],
                    [0, 146, 147, 18, 236, 237, 122, 190, 191, 127, 196, 197],
                    [0, 146, 147, 52, 238, 239, 122, 190, 191, 101, 170, 171],
                    [0, 146, 147, 61, 240, 241, 126, 194, 195, 101, 170, 171],
                    [0, 146, 147, 52, 238, 239, 100, 172, 173, 123, 192, 193],
                    [0, 146, 147, 61, 240, 241, 100, 172, 173, 127, 196, 197],
                    [0, 146, 147, 16, 226, 227, 100, 172, 173, 101, 170, 171, 1, 160, 161, 52, 239, 238, 122, 190, 191, 123, 192, 193],
                    [0, 146, 147, 16, 226, 227, 109, 216, 217, 108, 214, 215, 1, 160, 161, 52, 239, 238, 126, 194, 195, 127, 196, 197],
                    [0, 146, 147, 18, 236, 237, 109, 216, 217, 101, 170, 171, 1, 160, 161, 61, 241, 240, 126, 194, 195, 123, 192, 193],
                    [0, 146, 147, 18, 236, 237, 100, 172, 173, 108, 214, 215, 1, 160, 161, 61, 241, 240, 122, 190, 191, 127, 196, 197],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 23, 24, 13, 25, 256, 257, 258, 259, 260, 261, 262, 263, 26, 20, 27, 28, 264, 265, 266, 267, 268, 269, 270, 271, 4, 22, 5, 19, 272, 273, 274, 275, 276, 277, 278, 279],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 29, 21, 15, 30, 280, 281, 282, 283, 284, 285, 286, 287],
                    [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271],
                    [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271, 29, 31, 32, 33, 280, 288, 289, 290, 284, 291, 292, 293],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 1, 52, 6, 34, 168, 294, 295, 296, 169, 297, 298, 299],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 53, 54, 9, 42, 300, 301, 302, 303, 304, 305, 306, 307],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 1, 52, 6, 34, 168, 294, 295, 296, 169, 297, 298, 299, 23, 24, 13, 25, 256, 257, 258, 259, 260, 261, 262, 263, 64, 62, 14, 39, 308, 309, 310, 311, 312, 313, 314, 315, 26, 20, 27, 28, 264, 265, 266, 267, 268, 269, 270, 271, 65, 59, 40, 38, 316, 317, 318, 319, 320, 321, 322, 323, 4, 22, 5, 19, 272, 273, 274, 275, 276, 277, 278, 279, 11, 55, 8, 41, 324, 325, 326, 327, 328, 329, 330, 331],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 66, 67, 44, 45, 332, 333, 334, 335, 336, 337, 338, 339, 23, 24, 13, 25, 256, 257, 258, 259, 260, 261, 262, 263, 68, 69, 46, 47, 340, 341, 342, 343, 344, 345, 346, 347, 26, 20, 27, 28, 264, 265, 266, 267, 268, 269, 270, 271, 70, 71, 48, 49, 348, 349, 350, 351, 352, 353, 354, 355, 4, 22, 5, 19, 272, 273, 274, 275, 276, 277, 278, 279, 72, 73, 50, 51, 356, 357, 358, 359, 360, 361, 362, 363],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 1, 52, 6, 34, 168, 294, 295, 296, 169, 297, 298, 299, 29, 21, 15, 30, 280, 281, 282, 283, 284, 285, 286, 287, 53, 54, 9, 42, 300, 301, 302, 303, 304, 305, 306, 307],
                    [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271, 1, 59, 14, 41, 168, 325, 318, 311, 169, 313, 330, 323],
                    [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271, 1, 59, 14, 41, 168, 325, 318, 311, 169, 313, 330, 323, 29, 31, 32, 33, 280, 288, 289, 290, 284, 291, 292, 293, 53, 63, 36, 35, 300, 364, 365, 366, 304, 367, 368, 369],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 100, 101, 75, 74, 370, 371, 188, 372, 373, 374, 375, 189],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 116, 117, 83, 82, 376, 377, 224, 378, 379, 380, 381, 225],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 100, 101, 75, 74, 370, 371, 188, 372, 373, 374, 375, 189, 23, 24, 13, 25, 256, 257, 258, 259, 260, 261, 262, 263, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 26, 20, 27, 28, 264, 265, 266, 267, 268, 269, 270, 271, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 4, 22, 5, 19, 272, 273, 274, 275, 276, 277, 278, 279, 138, 139, 95, 94, 406, 407, 408, 409, 410, 411, 412, 413],
                    [0, 24, 5, 28, 158, 265, 258, 275, 159, 277, 270, 263, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 23, 16, 27, 19, 256, 273, 251, 267, 260, 269, 278, 255, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 26, 22, 13, 17, 264, 250, 274, 259, 268, 261, 254, 279, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 4, 20, 2, 25, 272, 257, 266, 252, 276, 253, 262, 271, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 100, 101, 75, 74, 370, 371, 188, 372, 373, 374, 375, 189, 29, 21, 15, 30, 280, 281, 282, 283, 284, 285, 286, 287, 116, 117, 83, 82, 376, 377, 224, 378, 379, 380, 381, 225],
                    [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271, 450, 415, 440, 429, 454, 431, 420, 445, 458, 447, 436, 425],
                    [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473],
                    [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 29, 31, 32, 33, 280, 288, 289, 290, 284, 291, 292, 293, 450, 415, 440, 429, 454, 431, 420, 445, 458, 447, 436, 425],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 123, 122, 88, 89, 204, 474, 475, 476, 205, 477, 478, 479],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 123, 122, 88, 89, 204, 474, 475, 476, 205, 477, 478, 479, 23, 24, 13, 25, 256, 257, 258, 259, 260, 261, 262, 263, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 26, 20, 27, 28, 264, 265, 266, 267, 268, 269, 270, 271, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 4, 22, 5, 19, 272, 273, 274, 275, 276, 277, 278, 279, 125, 124, 140, 141, 504, 505, 506, 507, 508, 509, 510, 511],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 123, 122, 88, 89, 204, 474, 475, 476, 205, 477, 478, 479, 29, 21, 15, 30, 280, 281, 282, 283, 284, 285, 286, 287, 129, 128, 90, 91, 212, 512, 513, 514, 213, 515, 516, 517],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 129, 128, 90, 91, 212, 512, 513, 514, 213, 515, 516, 517],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 129, 128, 90, 91, 212, 512, 513, 514, 213, 515, 516, 517, 23, 24, 13, 25, 256, 257, 258, 259, 260, 261, 262, 263, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 26, 20, 27, 28, 264, 265, 266, 267, 268, 269, 270, 271, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 4, 22, 5, 19, 272, 273, 274, 275, 276, 277, 278, 279, 127, 126, 92, 93, 542, 543, 544, 545, 546, 547, 548, 549],
                    [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 29, 31, 32, 33, 280, 288, 289, 290, 284, 291, 292, 293, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 100, 101, 75, 74, 370, 371, 188, 372, 373, 374, 375, 189, 1, 52, 6, 34, 168, 294, 295, 296, 169, 297, 298, 299, 122, 123, 89, 88, 475, 476, 204, 474, 479, 478, 477, 205],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 100, 101, 75, 74, 370, 371, 188, 372, 373, 374, 375, 189, 53, 54, 9, 42, 300, 301, 302, 303, 304, 305, 306, 307, 128, 129, 91, 90, 513, 514, 212, 512, 517, 516, 515, 213],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 116, 117, 83, 82, 376, 377, 224, 378, 379, 380, 381, 225, 1, 52, 6, 34, 168, 294, 295, 296, 169, 297, 298, 299, 128, 129, 91, 90, 513, 514, 212, 512, 517, 516, 515, 213],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 116, 117, 83, 82, 376, 377, 224, 378, 379, 380, 381, 225, 53, 54, 9, 42, 300, 301, 302, 303, 304, 305, 306, 307, 122, 123, 89, 88, 475, 476, 204, 474, 479, 478, 477, 205],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 100, 101, 75, 74, 370, 371, 188, 372, 373, 374, 375, 189, 1, 52, 6, 34, 168, 294, 295, 296, 169, 297, 298, 299, 122, 123, 89, 88, 475, 476, 204, 474, 479, 478, 477, 205, 23, 24, 13, 25, 256, 257, 258, 259, 260, 261, 262, 263, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 64, 62, 14, 39, 308, 309, 310, 311, 312, 313, 314, 315, 481, 480, 483, 482, 486, 487, 484, 485, 491, 490, 489, 488, 26, 20, 27, 28, 264, 265, 266, 267, 268, 269, 270, 271, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 65, 59, 40, 38, 316, 317, 318, 319, 320, 321, 322, 323, 493, 492, 495, 494, 498, 499, 496, 497, 503, 502, 501, 500, 4, 22, 5, 19, 272, 273, 274, 275, 276, 277, 278, 279, 138, 139, 95, 94, 406, 407, 408, 409, 410, 411, 412, 413, 11, 55, 8, 41, 324, 325, 326, 327, 328, 329, 330, 331, 124, 125, 141, 140, 506, 507, 504, 505, 511, 510, 509, 508],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 116, 117, 83, 82, 376, 377, 224, 378, 379, 380, 381, 225, 1, 52, 6, 34, 168, 294, 295, 296, 169, 297, 298, 299, 128, 129, 91, 90, 513, 514, 212, 512, 517, 516, 515, 213, 23, 24, 13, 25, 256, 257, 258, 259, 260, 261, 262, 263, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 64, 62, 14, 39, 308, 309, 310, 311, 312, 313, 314, 315, 519, 518, 521, 520, 524, 525, 522, 523, 529, 528, 527, 526, 26, 20, 27, 28, 264, 265, 266, 267, 268, 269, 270, 271, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 65, 59, 40, 38, 316, 317, 318, 319, 320, 321, 322, 323, 531, 530, 533, 532, 536, 537, 534, 535, 541, 540, 539, 538, 4, 22, 5, 19, 272, 273, 274, 275, 276, 277, 278, 279, 109, 108, 79, 78, 598, 599, 600, 601, 602, 603, 604, 605, 11, 55, 8, 41, 324, 325, 326, 327, 328, 329, 330, 331, 126, 127, 93, 92, 544, 545, 542, 543, 549, 548, 547, 546],
                    [0, 24, 5, 28, 158, 265, 258, 275, 159, 277, 270, 263, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 66, 69, 50, 49, 332, 349, 342, 359, 336, 361, 354, 347, 493, 123, 483, 140, 498, 507, 204, 485, 503, 490, 509, 205, 23, 16, 27, 19, 256, 273, 251, 267, 260, 269, 278, 255, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 68, 67, 48, 51, 340, 357, 334, 351, 344, 353, 362, 339, 124, 480, 89, 494, 506, 499, 484, 474, 511, 478, 501, 488, 26, 22, 13, 17, 264, 250, 274, 259, 268, 261, 254, 279, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 70, 73, 46, 45, 348, 333, 358, 343, 352, 345, 338, 363, 122, 492, 141, 482, 475, 487, 496, 505, 479, 510, 489, 500, 4, 20, 2, 25, 272, 257, 266, 252, 276, 253, 262, 271, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 72, 71, 44, 47, 356, 341, 350, 335, 360, 337, 346, 355, 481, 125, 495, 88, 486, 476, 504, 497, 491, 502, 477, 508],
                    [0, 24, 5, 28, 158, 265, 258, 275, 159, 277, 270, 263, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 531, 129, 521, 92, 536, 545, 212, 523, 541, 528, 547, 213, 23, 16, 27, 19, 256, 273, 251, 267, 260, 269, 278, 255, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 126, 518, 91, 532, 544, 537, 522, 512, 549, 516, 539, 526, 26, 22, 13, 17, 264, 250, 274, 259, 268, 261, 254, 279, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 128, 530, 93, 520, 513, 525, 534, 543, 517, 548, 527, 538, 4, 20, 2, 25, 272, 257, 266, 252, 276, 253, 262, 271, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 519, 127, 533, 90, 524, 514, 542, 535, 529, 540, 515, 546],
                    [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 100, 101, 75, 74, 370, 371, 188, 372, 373, 374, 375, 189, 1, 52, 6, 34, 168, 294, 295, 296, 169, 297, 298, 299, 122, 123, 89, 88, 475, 476, 204, 474, 479, 478, 477, 205, 29, 21, 15, 30, 280, 281, 282, 283, 284, 285, 286, 287, 116, 117, 83, 82, 376, 377, 224, 378, 379, 380, 381, 225, 53, 54, 9, 42, 300, 301, 302, 303, 304, 305, 306, 307, 128, 129, 91, 90, 513, 514, 212, 512, 517, 516, 515, 213],
                    [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 1, 59, 14, 41, 168, 325, 318, 311, 169, 313, 330, 323, 551, 550, 553, 552, 556, 557, 554, 555, 561, 560, 559, 558, 29, 31, 32, 33, 280, 288, 289, 290, 284, 291, 292, 293, 450, 415, 440, 429, 454, 431, 420, 445, 458, 447, 436, 425, 53, 63, 36, 35, 300, 364, 365, 366, 304, 367, 368, 369, 563, 562, 565, 564, 568, 569, 566, 567, 573, 572, 571, 570],
                    [0, 16],
                    [0, 18],
                    [0, 16, 26, 20],
                    [0, 2, 23, 13],
                    [0, 3, 4, 32],
                    [0, 2, 29, 15],
                    [0, 3, 29, 27],
                    [0, 52],
                    [0, 63],
                    [0, 52, 26, 59],
                    [0, 63, 26, 54],
                    [0, 52, 16, 1],
                    [0, 18, 1, 61],
                    [0, 52, 16, 1, 26, 59, 20, 65],
                    [0, 31, 1, 63],
                    [0, 1, 24, 62],
                    [0, 31, 1, 63, 26, 21, 65, 54],
                    [0, 2, 57, 56],
                    [0, 60, 3, 16],
                    [0, 22, 57, 3],
                    [0, 2, 28, 20],
                    [0, 17, 13, 24],
                    [0, 20, 19, 13, 4, 24, 17, 27],
                    [0, 22, 57, 3, 4, 16, 60, 32],
                    [0, 22, 57, 3, 23, 20, 30, 12, 26, 24, 33, 15, 4, 16, 60, 32],
                    [0, 22, 57, 3, 29, 18, 27, 25],
                    [0, 22, 3, 57, 1, 55, 10, 37],
                    [0, 22, 385, 396, 3, 57, 109, 117],
                    [0, 22, 57, 3, 159, 279, 654, 655, 158, 274, 656, 657, 29, 18, 25, 27, 284, 658, 262, 269, 280, 659, 257, 267],
                ];
                SpacegroupTables.Spacegroup = {
                    "P 1": 0,
                    "P -1": 1,
                    "P 1 2 1": 2,
                    "P 1 21 1": 3,
                    "C 1 2 1": 4,
                    "P 1 m 1": 5,
                    "P 1 c 1": 6,
                    "C 1 m 1": 7,
                    "C 1 c 1": 8,
                    "P 1 2/m 1": 9,
                    "P 1 21/m 1": 10,
                    "C 1 2/m 1": 11,
                    "P 1 2/c 1": 12,
                    "P 1 21/c 1": 13,
                    "C 1 2/c 1": 14,
                    "P 2 2 2": 15,
                    "P 2 2 21": 16,
                    "P 21 21 2": 17,
                    "P 21 21 21": 18,
                    "C 2 2 21": 19,
                    "C 2 2 2": 20,
                    "F 2 2 2": 21,
                    "I 2 2 2": 22,
                    "I 21 21 21": 23,
                    "P m m 2": 24,
                    "P m c 21": 25,
                    "P c c 2": 26,
                    "P m a 2": 27,
                    "P c a 21": 28,
                    "P n c 2": 29,
                    "P m n 21": 30,
                    "P b a 2": 31,
                    "P n a 21": 32,
                    "P n n 2": 33,
                    "C m m 2": 34,
                    "C m c 21": 35,
                    "C c c 2": 36,
                    "A m m 2": 37,
                    "A b m 2": 38,
                    "A m a 2": 39,
                    "A b a 2": 40,
                    "F m m 2": 41,
                    "F d d 2": 42,
                    "I m m 2": 43,
                    "I b a 2": 44,
                    "I m a 2": 45,
                    "P 2/m 2/m 2/m": 46,
                    "P m m m": 46,
                    "P 2/n 2/n 2/n": 47,
                    "P n n n": 47,
                    "P 2/c 2/c 2/m": 48,
                    "P c c m": 48,
                    "P 2/b 2/a 2/n": 49,
                    "P b a n": 49,
                    "P 21/m 2/m 2/a": 50,
                    "P m m a": 50,
                    "P 2/n 21/n 2/a": 51,
                    "P n n a": 51,
                    "P 2/m 2/n 21/a": 52,
                    "P m n a": 52,
                    "P 21/c 2/c 2/a": 53,
                    "P c c a": 53,
                    "P 21/b 21/a 2/m": 54,
                    "P b a m": 54,
                    "P 21/c 21/c 2/n": 55,
                    "P c c n": 55,
                    "P 2/b 21/c 21/m": 56,
                    "P b c m": 56,
                    "P 21/n 21/n 2/m": 57,
                    "P n n m": 57,
                    "P 21/m 21/m 2/n": 58,
                    "P m m n": 58,
                    "P 21/b 2/c 21/n": 59,
                    "P b c n": 59,
                    "P 21/b 21/c 21/a": 60,
                    "P b c a": 60,
                    "P 21/n 21/m 21/a": 61,
                    "P n m a": 61,
                    "C 2/m 2/c 21/m": 62,
                    "C m c m": 62,
                    "C 2/m 2/c 21/a": 63,
                    "C m c a": 63,
                    "C 2/m 2/m 2/m": 64,
                    "C m m m": 64,
                    "C 2/c 2/c 2/m": 65,
                    "C c c m": 65,
                    "C 2/m 2/m 2/a": 66,
                    "C m m a": 66,
                    "C 2/c 2/c 2/a": 67,
                    "C c c a": 67,
                    "F 2/m 2/m 2/m": 68,
                    "F m m m": 68,
                    "F 2/d 2/d 2/d": 69,
                    "F d d d": 69,
                    "I 2/m 2/m 2/m": 70,
                    "I m m m": 70,
                    "I 2/b 2/a 2/m": 71,
                    "I b a m": 71,
                    "I 21/b 21/c 21/a": 72,
                    "I b c a": 72,
                    "I 21/m 21/m 21/a": 73,
                    "I m m a": 73,
                    "P 4": 74,
                    "P 41": 75,
                    "P 42": 76,
                    "P 43": 77,
                    "I 4": 78,
                    "I 41": 79,
                    "P -4": 80,
                    "I -4": 81,
                    "P 4/m": 82,
                    "P 42/m": 83,
                    "P 4/n": 84,
                    "P 42/n": 85,
                    "I 4/m": 86,
                    "I 41/a": 87,
                    "P 4 2 2": 88,
                    "P 4 21 2": 89,
                    "P 41 2 2": 90,
                    "P 41 21 2": 91,
                    "P 42 2 2": 92,
                    "P 42 21 2": 93,
                    "P 43 2 2": 94,
                    "P 43 21 2": 95,
                    "I 4 2 2": 96,
                    "I 41 2 2": 97,
                    "P 4 m m": 98,
                    "P 4 b m": 99,
                    "P 42 c m": 100,
                    "P 42 n m": 101,
                    "P 4 c c": 102,
                    "P 4 n c": 103,
                    "P 42 m c": 104,
                    "P 42 b c": 105,
                    "I 4 m m": 106,
                    "I 4 c m": 107,
                    "I 41 m d": 108,
                    "I 41 c d": 109,
                    "P -4 2 m": 110,
                    "P -4 2 c": 111,
                    "P -4 21 m": 112,
                    "P -4 21 c": 113,
                    "P -4 m 2": 114,
                    "P -4 c 2": 115,
                    "P -4 b 2": 116,
                    "P -4 n 2": 117,
                    "I -4 m 2": 118,
                    "I -4 c 2": 119,
                    "I -4 2 m": 120,
                    "I -4 2 d": 121,
                    "P 4/m 2/m 2/m": 122,
                    "P4/m m m": 122,
                    "P 4/m 2/c 2/c": 123,
                    "P4/m c c": 123,
                    "P 4/n 2/b 2/m": 124,
                    "P4/n b m": 124,
                    "P 4/n 2/n 2/c": 125,
                    "P4/n n c": 125,
                    "P 4/m 21/b 2/m": 126,
                    "P4/m b m": 126,
                    "P 4/m 21/n 2/c": 127,
                    "P4/m n c": 127,
                    "P 4/n 21/m 2/m": 128,
                    "P4/n m m": 128,
                    "P 4/n 2/c 2/c": 129,
                    "P4/n c c": 129,
                    "P 42/m 2/m 2/c": 130,
                    "P42/m m c": 130,
                    "P 42/m 2/c 2/m": 131,
                    "P42/m c m": 131,
                    "P 42/n 2/b 2/c": 132,
                    "P42/n b c": 132,
                    "P 42/n 2/n 2/m": 133,
                    "P42/n n m": 133,
                    "P 42/m 21/b 2/c": 134,
                    "P42/m b c": 134,
                    "P 42/m 21/n 2/m": 135,
                    "P42/m n m": 135,
                    "P 42/n 21/m 2/c": 136,
                    "P42/n m c": 136,
                    "P 42/n 21/c 2/m": 137,
                    "P42/n c m": 137,
                    "I 4/m 2/m 2/m": 138,
                    "I4/m m m": 138,
                    "I 4/m 2/c 2/m": 139,
                    "I4/m c m": 139,
                    "I 41/a 2/m 2/d": 140,
                    "I41/a m d": 140,
                    "I 41/a 2/c 2/d": 141,
                    "I41/a c d": 141,
                    "P 3": 142,
                    "P 31": 143,
                    "P 32": 144,
                    "H 3": 145,
                    "R 3": 146,
                    "P -3": 147,
                    "H -3": 148,
                    "R -3": 149,
                    "P 3 1 2": 150,
                    "P 3 2 1": 151,
                    "P 31 1 2": 152,
                    "P 31 2 1": 153,
                    "P 32 1 2": 154,
                    "P 32 2 1": 155,
                    "H 3 2": 156,
                    "R 3 2": 157,
                    "P 3 m 1": 158,
                    "P 3 1 m": 159,
                    "P 3 c 1": 160,
                    "P 3 1 c": 161,
                    "H 3 m": 162,
                    "R 3 m": 163,
                    "H 3 c": 164,
                    "R 3 c": 165,
                    "P -3 1 2/m": 166,
                    "P -3 1 m": 166,
                    "P -3 1 2/c": 167,
                    "P -3 1 c": 167,
                    "P -3 2/m 1": 168,
                    "P -3 m 1": 168,
                    "P -3 2/c 1": 169,
                    "P -3 c 1": 169,
                    "H -3 2/m": 170,
                    "H -3 m": 170,
                    "R -3 2/m": 171,
                    "R -3 m": 171,
                    "H -3 2/c": 172,
                    "H -3 c": 172,
                    "R -3 2/c": 173,
                    "R -3 c": 173,
                    "P 6": 174,
                    "P 61": 175,
                    "P 65": 176,
                    "P 62": 177,
                    "P 64": 178,
                    "P 63": 179,
                    "P -6": 180,
                    "P 6/m": 181,
                    "P 63/m": 182,
                    "P 6 2 2": 183,
                    "P 61 2 2": 184,
                    "P 65 2 2": 185,
                    "P 62 2 2": 186,
                    "P 64 2 2": 187,
                    "P 63 2 2": 188,
                    "P 6 m m": 189,
                    "P 6 c c": 190,
                    "P 63 c m": 191,
                    "P 63 m c": 192,
                    "P -6 m 2": 193,
                    "P -6 c 2": 194,
                    "P -6 2 m": 195,
                    "P -6 2 c": 196,
                    "P 6/m 2/m 2/m": 197,
                    "P 6/m m m": 197,
                    "P 6/m 2/c 2/c": 198,
                    "P 6/m c c": 198,
                    "P 63/m 2/c 2/m": 199,
                    "P 63/m c m": 199,
                    "P 63/m 2/m 2/c": 200,
                    "P 63/m m c": 200,
                    "P 2 3": 201,
                    "F 2 3": 202,
                    "I 2 3": 203,
                    "P 21 3": 204,
                    "I 21 3": 205,
                    "P 2/m -3": 206,
                    "P m -3": 206,
                    "P 2/n -3": 207,
                    "P n -3": 207,
                    "F 2/m -3": 208,
                    "F m -3": 208,
                    "F 2/d -3": 209,
                    "F d -3": 209,
                    "I 2/m -3": 210,
                    "I m -3": 210,
                    "P 21/a -3": 211,
                    "P a -3": 211,
                    "I 21/a -3": 212,
                    "I a -3": 212,
                    "P 4 3 2": 213,
                    "P 42 3 2": 214,
                    "F 4 3 2": 215,
                    "F 41 3 2": 216,
                    "I 4 3 2": 217,
                    "P 43 3 2": 218,
                    "P 41 3 2": 219,
                    "I 41 3 2": 220,
                    "P -4 3 m": 221,
                    "F -4 3 m": 222,
                    "I -4 3 m": 223,
                    "P -4 3 n": 224,
                    "F -4 3 c": 225,
                    "I -4 3 d": 226,
                    "P 4/m -3 2/m": 227,
                    "P m -3 m": 227,
                    "P 4/n -3 2/n": 228,
                    "P n -3 n": 228,
                    "P 42/m -3 2/n": 229,
                    "P m -3 n": 229,
                    "P 42/n -3 2/m": 230,
                    "P n -3 m": 230,
                    "F 4/m -3 2/m": 231,
                    "F m -3 m": 231,
                    "F 4/m -3 2/c": 232,
                    "F m -3 c": 232,
                    "F 41/d -3 2/m": 233,
                    "F d -3 m": 233,
                    "F 41/d -3 2/c": 234,
                    "F d -3 c": 234,
                    "I 4/m -3 2/m": 235,
                    "I m -3 m": 235,
                    "I 41/a -3 2/d": 236,
                    "I a -3 d": 236,
                    "P 1 1 2": 237,
                    "P 1 1 21": 238,
                    "B 1 1 2": 239,
                    "B 2": 239,
                    "A 1 2 1": 240,
                    "C 1 21 1": 241,
                    "I 1 2 1": 242,
                    "I 2": 242,
                    "I 1 21 1": 243,
                    "P 1 1 m": 244,
                    "P 1 1 b": 245,
                    "B 1 1 m": 246,
                    "B 1 1 b": 247,
                    "P 1 1 2/m": 248,
                    "P 1 1 21/m": 249,
                    "B 1 1 2/m": 250,
                    "P 1 1 2/b": 251,
                    "P 1 1 21/b": 252,
                    "B 1 1 2/b": 253,
                    "P 21 2 2": 254,
                    "P 2 21 2": 255,
                    "P 21 21 2 (a)": 256,
                    "P 21 2 21": 257,
                    "P 2 21 21": 258,
                    "C 2 2 21a)": 259,
                    "C 2 2 2a": 260,
                    "F 2 2 2a": 261,
                    "I 2 2 2a": 262,
                    "P 21/m 21/m 2/n a": 263,
                    "P 42 21 2a": 264,
                    "I 2 3a": 265,
                };
            })(SpacegroupTables = Structure.SpacegroupTables || (Structure.SpacegroupTables = {}));
        })(Structure = Core.Structure || (Core.Structure = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Structure;
        (function (Structure) {
            "use strict";
            var SymmetryHelpers;
            (function (SymmetryHelpers) {
                var Mat4 = Core.Geometry.LinearAlgebra.Matrix4;
                var Sphere3 = (function () {
                    function Sphere3(center, radius) {
                        this.center = center;
                        this.radius = radius;
                    }
                    return Sphere3;
                }());
                function getBoudingSphere(arrays, indices) {
                    var x = arrays.x, y = arrays.y, z = arrays.z;
                    var center = { x: 0, y: 0, z: 0 };
                    for (var _i = 0, indices_1 = indices; _i < indices_1.length; _i++) {
                        var aI = indices_1[_i];
                        center.x += x[aI];
                        center.y += y[aI];
                        center.z += z[aI];
                    }
                    var count = indices.length > 0 ? indices.length : 1;
                    center.x /= count;
                    center.y /= count;
                    center.z /= count;
                    var r = 0;
                    for (var _a = 0, indices_2 = indices; _a < indices_2.length; _a++) {
                        var aI = indices_2[_a];
                        r = Math.max(indexedVectorDistSq(aI, center, arrays), r);
                    }
                    return new Sphere3(center, Math.sqrt(r));
                }
                function newVec() { return { x: 0, y: 0, z: 0 }; }
                ;
                function getSphereDist(c, r, q) {
                    var dx = c.x - q.center.x, dy = c.y - q.center.y, dz = c.z - q.center.z;
                    return Math.sqrt(dx * dx + dy * dy + dz * dz) - (r + q.radius);
                }
                function isWithinRadius(bounds, i, data, t, r, v) {
                    v.x = data.x[i];
                    v.y = data.y[i];
                    v.z = data.z[i];
                    Mat4.transformVector3(v, v, t);
                    return getSphereDist(v, data.r[i], bounds) <= r;
                }
                function indexedDistSq(aI, cI, arrays) {
                    var dx = arrays.x[aI] - arrays.cX[cI], dy = arrays.y[aI] - arrays.cY[cI], dz = arrays.z[aI] - arrays.cZ[cI];
                    return dx * dx + dy * dy + dz * dz;
                }
                function indexedVectorDistSq(aI, v, arrays) {
                    var dx = arrays.x[aI] - v.x, dy = arrays.y[aI] - v.y, dz = arrays.z[aI] - v.z;
                    return dx * dx + dy * dy + dz * dz;
                }
                var BoundingInfo = (function () {
                    function BoundingInfo(entities, chains, residues, allAtoms, target) {
                        this.entities = entities;
                        this.chains = chains;
                        this.residues = residues;
                        this.allAtoms = allAtoms;
                        this.target = target;
                    }
                    return BoundingInfo;
                }());
                var SymmetryContext = (function () {
                    function SymmetryContext(model, boundingInfo, spacegroup, radius) {
                        this.model = model;
                        this.boundingInfo = boundingInfo;
                        this.spacegroup = spacegroup;
                        this.radius = radius;
                        this.transform = Mat4.empty();
                        this.transformed = { x: 0, y: 0, z: 0 };
                        //posBufferB: Vector3 = { x: 0, y: 0, z: 0 };
                        this.i = 0;
                        this.j = 0;
                        this.k = 0;
                        this.op = 0;
                    }
                    SymmetryContext.prototype.map = function (p) {
                        return Mat4.transformVector3(this.transformed, p, this.transform);
                    };
                    SymmetryContext.prototype.getTransform = function () {
                        return new SymmetryTransform(this.i, this.j, this.k, this.op, Mat4.clone(this.transform));
                    };
                    return SymmetryContext;
                }());
                var SymmetryTransform = (function () {
                    function SymmetryTransform(i, j, k, opIndex, transform) {
                        this.i = i;
                        this.j = j;
                        this.k = k;
                        this.opIndex = opIndex;
                        this.transform = transform;
                        this._id = null;
                        this.isIdentity = !i && !j && !k && !opIndex;
                    }
                    Object.defineProperty(SymmetryTransform.prototype, "id", {
                        get: function () {
                            if (this._id)
                                return this._id;
                            this._id = (this.opIndex + 1) + "_" + (5 + this.i) + (5 + this.j) + (5 + this.k);
                            return this._id;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return SymmetryTransform;
                }());
                var AssemblyTransform = (function () {
                    function AssemblyTransform(i, transform) {
                        this.i = i;
                        this.transform = transform;
                        this.isIdentity = this._isIdentity();
                        this.id = i.toString();
                    }
                    AssemblyTransform.prototype._isIdentity = function () {
                        for (var i = 0; i < 4; i++) {
                            for (var j = 0; j < 4; j++) {
                                var v = this.transform[4 * j + i];
                                if (i === j) {
                                    if (Math.abs(v - 1) > 0.0000001)
                                        return false;
                                }
                                else if (Math.abs(v) > 0.0000001)
                                    return false;
                            }
                        }
                        return true;
                    };
                    return AssemblyTransform;
                }());
                function getBoundingInfo(model, pivotIndices) {
                    var atoms = model.atoms, residues = model.residues, chains = model.chains, entities = model.entities, x = atoms.x, y = atoms.y, z = atoms.z;
                    var entityTable = new Structure.DataTableBuilder(entities.count), eX = entityTable.addColumn("x", function (s) { return new Float64Array(s); }), eY = entityTable.addColumn("y", function (s) { return new Float64Array(s); }), eZ = entityTable.addColumn("z", function (s) { return new Float64Array(s); }), eR = entityTable.addColumn("r", function (s) { return new Float64Array(s); }), chainTable = new Structure.DataTableBuilder(chains.count), cX = chainTable.addColumn("x", function (s) { return new Float64Array(s); }), cY = chainTable.addColumn("y", function (s) { return new Float64Array(s); }), cZ = chainTable.addColumn("z", function (s) { return new Float64Array(s); }), cR = chainTable.addColumn("r", function (s) { return new Float64Array(s); }), residueTable = new Structure.DataTableBuilder(residues.count), rX = residueTable.addColumn("x", function (s) { return new Float64Array(s); }), rY = residueTable.addColumn("y", function (s) { return new Float64Array(s); }), rZ = residueTable.addColumn("z", function (s) { return new Float64Array(s); }), rR = residueTable.addColumn("r", function (s) { return new Float64Array(s); });
                    var allCenter = newVec(), allRadius = 0, pivotCenter = newVec(), pivotRadius = 0, n = 0, eCenter = newVec(), eRadius = 0, cCenter = newVec(), cRadius = 0, rCenter = newVec(), rRadius = 0;
                    for (var eI = 0, _eC = entities.count; eI < _eC; eI++) {
                        eCenter.x = 0;
                        eCenter.y = 0;
                        eCenter.z = 0;
                        for (var cI = entities.chainStartIndex[eI], _cC = entities.chainEndIndex[eI]; cI < _cC; cI++) {
                            cCenter.x = 0;
                            cCenter.y = 0;
                            cCenter.z = 0;
                            for (var rI = chains.residueStartIndex[cI], _rC = chains.residueEndIndex[cI]; rI < _rC; rI++) {
                                rCenter.x = 0;
                                rCenter.y = 0;
                                rCenter.z = 0;
                                for (var aI = residues.atomStartIndex[rI], _aC = residues.atomEndIndex[rI]; aI < _aC; aI++) {
                                    rCenter.x += x[aI];
                                    rCenter.y += y[aI];
                                    rCenter.z += z[aI];
                                }
                                allCenter.x += rCenter.x;
                                allCenter.y += rCenter.y;
                                allCenter.z += rCenter.z;
                                n = residues.atomEndIndex[rI] - residues.atomStartIndex[rI];
                                cCenter.x += rCenter.x;
                                cCenter.y += rCenter.y;
                                cCenter.z += rCenter.z;
                                rX[rI] = rCenter.x / n;
                                rY[rI] = rCenter.y / n;
                                rZ[rI] = rCenter.z / n;
                            }
                            eCenter.x += cCenter.x;
                            eCenter.y += cCenter.y;
                            eCenter.z += cCenter.z;
                            n = chains.atomEndIndex[cI] - chains.atomStartIndex[cI];
                            cX[cI] = cCenter.x / n;
                            cY[cI] = cCenter.y / n;
                            cZ[cI] = cCenter.z / n;
                        }
                        n = entities.atomEndIndex[eI] - entities.atomStartIndex[eI];
                        eX[eI] = eCenter.x / n;
                        eY[eI] = eCenter.y / n;
                        eZ[eI] = eCenter.z / n;
                    }
                    allCenter.x /= atoms.count;
                    allCenter.y /= atoms.count;
                    allCenter.z /= atoms.count;
                    for (var _i = 0, pivotIndices_1 = pivotIndices; _i < pivotIndices_1.length; _i++) {
                        var aI = pivotIndices_1[_i];
                        pivotCenter.x += x[aI];
                        pivotCenter.y += y[aI];
                        pivotCenter.z += z[aI];
                    }
                    var pivotCount = pivotIndices.length > 0 ? pivotIndices.length : 1;
                    pivotCenter.x /= pivotCount;
                    pivotCenter.y /= pivotCount;
                    pivotCenter.z /= pivotCount;
                    var eDA = { x: x, y: y, z: z, cX: eX, cY: eY, cZ: eZ }, cDA = { x: x, y: y, z: z, cX: cX, cY: cY, cZ: cZ }, rDA = { x: x, y: y, z: z, cX: rX, cY: rY, cZ: rZ };
                    for (var eI = 0, _eC = entities.count; eI < _eC; eI++) {
                        eRadius = 0;
                        for (var cI = entities.chainStartIndex[eI], _cC = entities.chainEndIndex[eI]; cI < _cC; cI++) {
                            cRadius = 0;
                            for (var rI = chains.residueStartIndex[cI], _rC = chains.residueEndIndex[cI]; rI < _rC; rI++) {
                                rRadius = 0;
                                for (var aI = residues.atomStartIndex[rI], _aC = residues.atomEndIndex[rI]; aI < _aC; aI++) {
                                    rRadius = Math.max(rRadius, indexedDistSq(aI, rI, rDA));
                                    cRadius = Math.max(cRadius, indexedDistSq(aI, cI, cDA));
                                    eRadius = Math.max(eRadius, indexedDistSq(aI, eI, eDA));
                                    allRadius = Math.max(allRadius, indexedVectorDistSq(aI, allCenter, rDA));
                                }
                                rRadius = Math.sqrt(rRadius);
                                rR[rI] = rRadius;
                            }
                            cRadius = Math.sqrt(cRadius);
                            cR[cI] = cRadius;
                        }
                        eRadius = Math.sqrt(eRadius);
                        eR[eI] = eRadius;
                    }
                    allRadius = Math.sqrt(allRadius);
                    for (var _a = 0, pivotIndices_2 = pivotIndices; _a < pivotIndices_2.length; _a++) {
                        var aI = pivotIndices_2[_a];
                        pivotRadius = Math.max(pivotRadius, indexedVectorDistSq(aI, pivotCenter, rDA));
                    }
                    pivotRadius = Math.sqrt(pivotRadius);
                    return new BoundingInfo(entityTable.seal(), chainTable.seal(), residueTable.seal(), new Sphere3(allCenter, allRadius), new Sphere3(pivotCenter, pivotRadius));
                }
                function findSuitableTransforms(ctx) {
                    var bounds = ctx.boundingInfo, sg = ctx.spacegroup;
                    var ret = [];
                    ctx.transform = Mat4.identity();
                    ret[0] = ctx.getTransform();
                    for (var i = -3; i <= 3; i++) {
                        for (var j = -3; j <= 3; j++) {
                            for (var k = -3; k <= 3; k++) {
                                for (var l = (i === 0 && j === 0 && k === 0 ? 1 : 0), lm = sg.operatorCount; l < lm; l++) {
                                    //for (let l = 0, lm = sg.operatorCount; l < lm; l++) {                            
                                    sg.getOperatorMatrix(l, i, j, k, ctx.transform);
                                    ctx.i = i;
                                    ctx.k = k;
                                    ctx.j = j;
                                    ctx.op = l;
                                    var t = ctx.map(bounds.allAtoms.center), d = getSphereDist(t, bounds.allAtoms.radius, bounds.target);
                                    if (d < ctx.radius) {
                                        ret[ret.length] = ctx.getTransform();
                                    }
                                }
                            }
                        }
                    }
                    return ret;
                }
                function getSymmetryResidues(ctx, transforms) {
                    var bounds = ctx.boundingInfo, radius = ctx.radius, targetBounds = bounds.target;
                    var model = ctx.model, atoms = model.atoms, residues = model.residues, chains = model.chains, entities = model.entities;
                    var residueIndices = new Core.Utils.ChunkedArrayBuilder(function (s) { return new Int32Array(s); }, ctx.model.residues.count, 1), operatorIndices = new Core.Utils.ChunkedArrayBuilder(function (s) { return new Int32Array(s); }, ctx.model.residues.count, 1);
                    var v = { x: 0, y: 0, z: 0 }, opIndex = 0;
                    var atomCount = 0, chainCount = 0;
                    for (var eI = 0, _eC = entities.count; eI < _eC; eI++) {
                        //if (!isWithinRadius(hetBounds, eI, bounds.entities, t.transform, radius, v)) continue;
                        opIndex = 0;
                        for (var _i = 0, transforms_1 = transforms; _i < transforms_1.length; _i++) {
                            var t = transforms_1[_i];
                            for (var cI = entities.chainStartIndex[eI], _cC = entities.chainEndIndex[eI]; cI < _cC; cI++) {
                                if (!isWithinRadius(targetBounds, cI, bounds.chains, t.transform, radius, v))
                                    continue;
                                var added = false;
                                for (var rI = chains.residueStartIndex[cI], _rC = chains.residueEndIndex[cI]; rI < _rC; rI++) {
                                    if (!isWithinRadius(targetBounds, rI, bounds.residues, t.transform, radius, v))
                                        continue;
                                    residueIndices.add(rI);
                                    operatorIndices.add(opIndex);
                                    atomCount += residues.atomEndIndex[rI] - residues.atomStartIndex[rI];
                                    added = true;
                                }
                                if (added)
                                    chainCount += 1;
                            }
                            opIndex++;
                        }
                    }
                    return {
                        residues: residueIndices.compact(),
                        operators: operatorIndices.compact(),
                        atomCount: atomCount,
                        chainCount: chainCount
                    };
                }
                function cloneRow(src, sI, target, tI, c) {
                    for (var i = 0; i < c; i++) {
                        target[i][tI] = src[i][sI];
                    }
                }
                function assemble(model, parts, transforms) {
                    var residues = model.residues, residueChainIndex = residues.chainIndex, residueEntityIndex = residues.entityIndex, residueAtomStartIndex = residues.atomStartIndex, residueAtomEndIndex = residues.atomEndIndex, atoms = model.atoms, x = atoms.x, y = atoms.y, z = atoms.z;
                    var atomTable = new Structure.DataTableBuilder(parts.atomCount), atomX, atomY, atomZ, atomId, atomResidue, atomChain, cols = [];
                    var entityTable = model.entities.clone(), entityChainStart = entityTable.chainStartIndex, entityChainEnd = entityTable.chainEndIndex, entityResidueStart = entityTable.residueStartIndex, entityResidueEnd = entityTable.residueEndIndex, entityAtomStart = entityTable.atomStartIndex, entityAtomEnd = entityTable.atomEndIndex, entityOffset = 0;
                    var chainTableBuilder = model.chains.getBuilder(parts.chainCount), chainTable = chainTableBuilder, srcChainData = model.chains.getRawData(), chainData = chainTable.getRawData(), chainResidueStart = chainTable.residueStartIndex, chainResidueEnd = chainTable.residueEndIndex, chainAtomStart = chainTable.atomStartIndex, chainAtomEnd = chainTable.atomEndIndex, chainId = chainTable.asymId, chainAuthId = chainTable.authAsymId, chainSourceChainIndex = chainTableBuilder.addColumn('sourceChainIndex', function (s) { return new Int32Array(s); }), chainOffset = 0;
                    var residueTable = model.residues.getBuilder(parts.residues.length), srcResidueData = model.residues.getRawData(), residueData = residueTable.getRawData(), residueAtomStart = residueTable.atomStartIndex, residueAtomEnd = residueTable.atomEndIndex, residueAsymId = residueTable.asymId, residueAuthAsymId = residueTable.authAsymId, residueChain = residueTable.chainIndex;
                    for (var _i = 0, _a = model.atoms.columns; _i < _a.length; _i++) {
                        var col = _a[_i];
                        var c = atomTable.addColumn(col.name, col.creator);
                        if (col.name === "x")
                            atomX = c;
                        else if (col.name === "y")
                            atomY = c;
                        else if (col.name === "z")
                            atomZ = c;
                        else if (col.name === "residueIndex")
                            atomResidue = c;
                        else if (col.name === "chainIndex")
                            atomChain = c;
                        else if (col.name === "id")
                            atomId = c;
                        else {
                            cols[cols.length] = {
                                src: atoms[col.name],
                                target: c
                            };
                        }
                    }
                    var residueParts = parts.residues, opParts = parts.operators, temp = { x: 0, y: 0, z: 0 }, atomOffset = 0;
                    var rI = residueParts[0], currentChain = residueChainIndex[rI], currentEntity = residueEntityIndex[rI], currentOp = opParts[0], currentAsymId, currentAuthAsymId;
                    // setup entity table
                    entityChainStart[0] = 0;
                    entityResidueStart[0] = 0;
                    entityAtomStart[0] = 0;
                    //setup chain table
                    cloneRow(srcChainData, residueChainIndex[rI], chainData, 0, srcChainData.length);
                    chainResidueStart[0] = 0;
                    chainAtomStart[0] = 0;
                    currentAsymId = model.chains.asymId[residueChainIndex[rI]];
                    currentAuthAsymId = model.chains.authAsymId[residueChainIndex[rI]];
                    var transform = transforms[opParts[0]];
                    if (transform && !transform.isIdentity) {
                        chainId[chainOffset] = model.chains.asymId[residueChainIndex[rI]] + '-' + transform.id;
                        chainAuthId[chainOffset] = model.chains.authAsymId[residueChainIndex[rI]] + '-' + transform.id;
                        chainSourceChainIndex[chainOffset] = residueChainIndex[rI];
                    }
                    for (var residueOffset = 0, _mi = residueParts.length; residueOffset < _mi; residueOffset++) {
                        rI = residueParts[residueOffset];
                        var opI = opParts[residueOffset];
                        transform = transforms[opI];
                        cloneRow(srcResidueData, rI, residueData, residueOffset, residueData.length);
                        var cE = residueEntityIndex[rI], cC = residueChainIndex[rI];
                        if (cE !== currentEntity) {
                            // update chain
                            chainResidueEnd[chainOffset] = residueOffset;
                            chainAtomEnd[chainOffset] = atomOffset;
                            chainOffset += 1;
                            // update entity
                            entityChainEnd[entityOffset] = chainOffset;
                            entityResidueEnd[entityOffset] = residueOffset;
                            entityAtomEnd[entityOffset] = atomOffset;
                            // new entity
                            entityOffset += 1;
                            entityChainStart[entityOffset] = chainOffset;
                            entityResidueStart[entityOffset] = residueOffset;
                            entityAtomStart[entityOffset] = atomOffset;
                            // new chain
                            cloneRow(srcChainData, cC, chainData, chainOffset, srcChainData.length);
                            chainResidueStart[chainOffset] = residueOffset;
                            chainAtomStart[chainOffset] = atomOffset;
                            // update the chain identifier if needed
                            if (!transform.isIdentity) {
                                chainId[chainOffset] = model.chains.asymId[cC] + '-' + transform.id;
                                chainAuthId[chainOffset] = model.chains.authAsymId[cC] + '-' + transform.id;
                            }
                            chainSourceChainIndex[chainOffset] = cC;
                            currentAsymId = model.chains.asymId[cC];
                            currentAuthAsymId = model.chains.authAsymId[cC];
                        }
                        else if (cC !== currentChain) {
                            // update chain
                            chainResidueEnd[chainOffset] = residueOffset;
                            chainAtomEnd[chainOffset] = atomOffset;
                            chainOffset += 1;
                            // new chain
                            cloneRow(srcChainData, cC, chainData, chainOffset, srcChainData.length);
                            chainResidueStart[chainOffset] = residueOffset;
                            chainAtomStart[chainOffset] = atomOffset;
                            // update the chain identifier if needed
                            if (!transform.isIdentity) {
                                chainId[chainOffset] = model.chains.asymId[cC] + '-' + transform.id;
                                chainAuthId[chainOffset] = model.chains.authAsymId[cC] + '-' + transform.id;
                            }
                            chainSourceChainIndex[chainOffset] = cC;
                            currentAsymId = model.chains.asymId[cC];
                            currentAuthAsymId = model.chains.authAsymId[cC];
                        }
                        else if (opI !== currentOp) {
                            // update chain
                            chainResidueEnd[chainOffset] = residueOffset;
                            chainAtomEnd[chainOffset] = atomOffset;
                            chainOffset += 1;
                            // new chain
                            cloneRow(srcChainData, cC, chainData, chainOffset, srcChainData.length);
                            chainResidueStart[chainOffset] = residueOffset;
                            chainAtomStart[chainOffset] = atomOffset;
                            // update the residue identifier if needed
                            if (!transform.isIdentity) {
                                chainId[chainOffset] = model.chains.asymId[cC] + '-' + transform.id;
                                chainAuthId[chainOffset] = model.chains.authAsymId[cC] + '-' + transform.id;
                            }
                            chainSourceChainIndex[chainOffset] = cC;
                            currentAsymId = chainId[chainOffset];
                            currentAuthAsymId = chainAuthId[chainOffset];
                        }
                        currentChain = cC;
                        currentEntity = cE;
                        currentOp = opI;
                        residueChain[residueOffset] = chainOffset;
                        residueAtomStart[residueOffset] = atomOffset;
                        residueAsymId[residueOffset] = currentAsymId;
                        residueAuthAsymId[residueOffset] = currentAuthAsymId;
                        for (var aI = residueAtomStartIndex[rI], _mAI = residueAtomEndIndex[rI]; aI < _mAI; aI++) {
                            temp.x = x[aI];
                            temp.y = y[aI];
                            temp.z = z[aI];
                            Mat4.transformVector3(temp, temp, transform.transform);
                            atomX[atomOffset] = temp.x;
                            atomY[atomOffset] = temp.y;
                            atomZ[atomOffset] = temp.z;
                            atomId[atomOffset] = atomOffset + 1;
                            atomResidue[atomOffset] = residueOffset;
                            atomChain[atomOffset] = chainOffset;
                            for (var _b = 0, cols_2 = cols; _b < cols_2.length; _b++) {
                                var c = cols_2[_b];
                                c.target[atomOffset] = c.src[aI];
                            }
                            atomOffset++;
                        }
                        residueAtomEnd[residueOffset] = atomOffset;
                    }
                    // finalize entity
                    entityChainEnd[entityOffset] = chainOffset + 1;
                    entityResidueEnd[entityOffset] = residueParts.length;
                    entityAtomEnd[entityOffset] = atomOffset;
                    // finalize chain
                    chainResidueEnd[chainOffset] = residueParts.length;
                    chainAtomEnd[chainOffset] = atomOffset;
                    var finalAtoms = atomTable.seal(), finalResidues = residueTable.seal(), finalChains = chainTable.seal(), finalEntities = entityTable;
                    ////let ss = new SecondaryStructureElement(
                    ////    SecondaryStructureType.None,
                    ////    new PolyResidueIdentifier('', 0, null),
                    ////    new PolyResidueIdentifier('', 0, null));
                    ////ss.startResidueIndex = 0;
                    ////ss.endResidueIndex = finalResidues.count;
                    var ss = buildSS(model, parts, finalResidues);
                    return new Structure.MoleculeModel(model.id, model.modelId, finalAtoms, finalResidues, finalChains, finalEntities, model.componentBonds, ss, undefined, undefined, model, Structure.MoleculeModelSource.Computed);
                }
                function createSecondaryStructureIndex(model) {
                    var ssIndex = new Int32Array(model.residues.count);
                    var ss = model.secondaryStructure;
                    var index = 0;
                    for (var _i = 0, ss_1 = ss; _i < ss_1.length; _i++) {
                        var s = ss_1[_i];
                        for (var i = s.startResidueIndex; i < s.endResidueIndex; i++) {
                            ssIndex[i] = index;
                        }
                        index++;
                    }
                    return ssIndex;
                }
                function buildSS(parent, parts, newResidues) {
                    var index = createSecondaryStructureIndex(parent);
                    var ss = parent.secondaryStructure;
                    var asymId = newResidues.asymId, seqNumber = newResidues.seqNumber, insCode = newResidues.insCode;
                    var residues = parts.residues, operators = parts.operators;
                    var count = residues.length;
                    var ret = [];
                    var start = 0;
                    while (start < count) {
                        var end = start;
                        var ssI = index[residues[start]], op = operators[start];
                        while (end < count && operators[end] == op && index[residues[end]] == ssI)
                            end++;
                        var s = ss[ssI];
                        var e = new Structure.SecondaryStructureElement(s.type, new Structure.PolyResidueIdentifier(asymId[start], seqNumber[start], insCode[start]), new Structure.PolyResidueIdentifier(asymId[end - 1], seqNumber[end - 1], insCode[end - 1]), s.info);
                        e.startResidueIndex = start;
                        e.endResidueIndex = end;
                        ret[ret.length] = e;
                        start = end;
                    }
                    return ret;
                }
                function buildPivotGroupSymmetry(model, radius, pivotsQuery) {
                    var info = model.symmetryInfo;
                    if (!info
                        || info.spacegroupName === "P 1"
                        || (info.cellSize[0] < 1.1 && info.cellSize[1] < 1.1 && info.cellSize[2] < 1.1)) {
                        return model;
                    }
                    var pivotIndices;
                    if (!pivotsQuery)
                        pivotIndices = model.atoms.indices;
                    else
                        pivotIndices = pivotsQuery(model.queryContext).unionAtomIndices();
                    var bounds = getBoundingInfo(model, pivotIndices), spacegroup = new Structure.Spacegroup(model.symmetryInfo), ctx = new SymmetryContext(model, bounds, spacegroup, radius);
                    var transforms = findSuitableTransforms(ctx), residues = getSymmetryResidues(ctx, transforms);
                    return assemble(model, residues, transforms);
                }
                SymmetryHelpers.buildPivotGroupSymmetry = buildPivotGroupSymmetry;
                function findMates(model, radius) {
                    var bounds = getBoudingSphere(model.atoms, model.atoms.indices);
                    var spacegroup = new Structure.Spacegroup(model.symmetryInfo);
                    var t = Mat4.empty();
                    var v = { x: 0, y: 0, z: 0 };
                    var transforms = [];
                    for (var i = -3; i <= 3; i++) {
                        for (var j = -3; j <= 3; j++) {
                            for (var k = -3; k <= 3; k++) {
                                for (var op = 0; op < spacegroup.operatorCount; op++) {
                                    spacegroup.getOperatorMatrix(op, i, j, k, t);
                                    Mat4.transformVector3(v, bounds.center, t);
                                    if (getSphereDist(v, bounds.radius, bounds) > radius)
                                        continue;
                                    var copy = Mat4.empty();
                                    Mat4.copy(copy, t);
                                    transforms.push(new SymmetryTransform(i, j, k, op, copy));
                                }
                            }
                        }
                    }
                    return transforms;
                }
                function findMateParts(model, transforms) {
                    var atoms = model.atoms, residues = model.residues, chains = model.chains, entities = model.entities;
                    var residueIndices = new Core.Utils.ArrayBuilder(function (s) { return new Int32Array(s); }, model.residues.count * transforms.length, 1), operatorIndices = new Core.Utils.ArrayBuilder(function (s) { return new Int32Array(s); }, model.residues.count * transforms.length, 1);
                    var v = { x: 0, y: 0, z: 0 }, opIndex = 0;
                    var atomCount = transforms.length * atoms.count;
                    var chainCount = transforms.length * chains.count;
                    for (var eI = 0, _eC = entities.count; eI < _eC; eI++) {
                        opIndex = 0;
                        for (var _i = 0, transforms_2 = transforms; _i < transforms_2.length; _i++) {
                            var t = transforms_2[_i];
                            for (var cI = entities.chainStartIndex[eI], _cC = entities.chainEndIndex[eI]; cI < _cC; cI++) {
                                for (var rI = chains.residueStartIndex[cI], _rC = chains.residueEndIndex[cI]; rI < _rC; rI++) {
                                    residueIndices.add(rI);
                                    operatorIndices.add(opIndex);
                                }
                            }
                            opIndex++;
                        }
                    }
                    return {
                        residues: residueIndices.array,
                        operators: operatorIndices.array,
                        atomCount: atomCount,
                        chainCount: chainCount
                    };
                }
                function buildMates(model, radius) {
                    var info = model.symmetryInfo;
                    if (!info
                        || info.spacegroupName === "P 1"
                        || (info.cellSize[0] < 1.1 && info.cellSize[1] < 1.1 && info.cellSize[2] < 1.1)) {
                        return model;
                    }
                    var transforms = findMates(model, radius);
                    var parts = findMateParts(model, transforms);
                    return assemble(model, parts, transforms);
                }
                SymmetryHelpers.buildMates = buildMates;
                function createOperators(operators, list, i, current) {
                    if (i < 0) {
                        list[list.length] = current.slice(0);
                        return;
                    }
                    var ops = operators[i], len = ops.length;
                    for (var j = 0; j < len; j++) {
                        current[i] = ops[j];
                        createOperators(operators, list, i - 1, current);
                    }
                }
                function getAssemblyTransforms(model, operators) {
                    var info = model.assemblyInfo;
                    var trasnforms = [];
                    var t = Mat4.empty();
                    var index = 0;
                    for (var _i = 0, operators_1 = operators; _i < operators_1.length; _i++) {
                        var op = operators_1[_i];
                        var m = Mat4.identity();
                        //Mat4.copy(m, info.operators[op[0]].operator);
                        for (var i = 0; i < op.length; i++) {
                            Mat4.mul(m, m, info.operators[op[i]].operator);
                        }
                        index++;
                        trasnforms[trasnforms.length] = new AssemblyTransform(index, m);
                    }
                    return trasnforms;
                }
                function getAssemblyParts(model, residueMask, transforms) {
                    var atoms = model.atoms, residues = model.residues, chains = model.chains, entities = model.entities;
                    var residueIndices = new Core.Utils.ChunkedArrayBuilder(function (s) { return new Int32Array(s); }, model.residues.count, 1), operatorIndices = new Core.Utils.ChunkedArrayBuilder(function (s) { return new Int32Array(s); }, model.residues.count, 1);
                    var v = { x: 0, y: 0, z: 0 }, opIndex = 0;
                    var atomCount = 0, chainCount = 0;
                    for (var eI = 0, _eC = entities.count; eI < _eC; eI++) {
                        opIndex = 0;
                        for (var _i = 0, transforms_3 = transforms; _i < transforms_3.length; _i++) {
                            var t = transforms_3[_i];
                            for (var cI = entities.chainStartIndex[eI], _cC = entities.chainEndIndex[eI]; cI < _cC; cI++) {
                                var added = false;
                                for (var rI = chains.residueStartIndex[cI], _rC = chains.residueEndIndex[cI]; rI < _rC; rI++) {
                                    if (!residueMask[rI])
                                        continue;
                                    residueIndices.add(rI);
                                    operatorIndices.add(opIndex);
                                    atomCount += residues.atomEndIndex[rI] - residues.atomStartIndex[rI];
                                    added = true;
                                }
                                if (added)
                                    chainCount += 1;
                            }
                            opIndex++;
                        }
                    }
                    return {
                        residues: residueIndices.compact(),
                        operators: operatorIndices.compact(),
                        atomCount: atomCount,
                        chainCount: chainCount
                    };
                }
                function buildAssembly(model, assembly) {
                    var ops = [], currentOp = [];
                    for (var i_1 = 0; i_1 < assembly.operators.length; i_1++)
                        currentOp[i_1] = "";
                    createOperators(assembly.operators, ops, assembly.operators.length - 1, currentOp);
                    var transforms = getAssemblyTransforms(model, ops);
                    var asymIds = new Set();
                    assembly.asymIds.forEach(function (id) { return asymIds.add(id); });
                    var residueAsymIds = model.residues.asymId;
                    var residueCount = model.residues.count;
                    var mask = new Int8Array(residueCount);
                    for (var i = 0; i < residueCount; i++) {
                        mask[i] = asymIds.has(residueAsymIds[i]);
                    }
                    var parts = getAssemblyParts(model, mask, transforms);
                    return assemble(model, parts, transforms);
                }
                SymmetryHelpers.buildAssembly = buildAssembly;
            })(SymmetryHelpers || (SymmetryHelpers = {}));
            function buildPivotGroupSymmetry(model, radius, pivotsQuery) {
                return SymmetryHelpers.buildPivotGroupSymmetry(model, radius, pivotsQuery);
            }
            Structure.buildPivotGroupSymmetry = buildPivotGroupSymmetry;
            function buildSymmetryMates(model, radius) {
                return SymmetryHelpers.buildMates(model, radius);
            }
            Structure.buildSymmetryMates = buildSymmetryMates;
            function buildAssembly(model, assembly) {
                return SymmetryHelpers.buildAssembly(model, assembly);
            }
            Structure.buildAssembly = buildAssembly;
        })(Structure = Core.Structure || (Core.Structure = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Structure;
        (function (Structure) {
            var Queries;
            (function (Queries) {
                /**
                 * The context of a query.
                 *
                 * Stores:
                 * - the mask of "active" atoms.
                 * - kd-tree for fast geometry queries.
                 * - the molecule itself.
                 *
                 */
                var QueryContext = (function () {
                    function QueryContext(structure, mask, count) {
                        this.structure = structure;
                        this._mask = mask;
                        this._count = count;
                    }
                    Object.defineProperty(QueryContext.prototype, "atomCount", {
                        /**
                         * Number of atoms in the current context.
                         */
                        get: function () {
                            return this._count;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(QueryContext.prototype, "isComplete", {
                        /**
                         * Determine if the context contains all atoms of the input model.
                         */
                        get: function () {
                            return this._count === this._mask.length;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(QueryContext.prototype, "tree", {
                        /**
                         * Get a kd-tree for the atoms in the current context.
                         */
                        get: function () {
                            if (!this.lazyTree)
                                this.makeTree();
                            return this.lazyTree;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /**
                     * Checks if an atom is included in the current context.
                     */
                    QueryContext.prototype.hasAtom = function (index) {
                        return this._mask[index] !== 0;
                    };
                    /**
                     * Checks if an atom from the range is included in the current context.
                     */
                    QueryContext.prototype.hasRange = function (start, end) {
                        for (var i = start; i < end; i++) {
                            if (this._mask[i])
                                return true;
                        }
                        return false;
                    };
                    /**
                     * Create a new context based on the provide structure.
                     */
                    QueryContext.ofStructure = function (structure) {
                        var len = structure.atoms.count, mask = new Int8Array(len);
                        for (var i = 0; i < len; i++)
                            mask[i] = 1;
                        return new QueryContext(structure, mask, len);
                    };
                    /**
                     * Create a new context from a sequence of fragments.
                     */
                    QueryContext.ofFragments = function (seq) {
                        var len = seq.context.structure.atoms.count, mask = new Int8Array(len), count = 0;
                        seq.fragments.forEach(function (f) {
                            for (var _i = 0, _a = f.atomIndices; _i < _a.length; _i++) {
                                var i = _a[_i];
                                this[i] = 1;
                            }
                        }, mask);
                        for (var i = 0; i < len; i++) {
                            if (mask[i] !== 0)
                                count++;
                        }
                        return new QueryContext(seq.context.structure, mask, count);
                    };
                    QueryContext.prototype.makeTree = function () {
                        var data = new Int32Array(this._count), atoms = this.structure.atoms, dataCount = 0, cX = atoms.x, cY = atoms.y, cZ = atoms.z;
                        for (var i = 0; i < this._mask.length; i++) {
                            if (this._mask[i])
                                data[dataCount++] = i;
                        }
                        this.lazyTree = new Core.Geometry.SubdivisionTree3D(data, function (i, b) { return b.add(cX[i], cY[i], cZ[i]); });
                    };
                    return QueryContext;
                }());
                Queries.QueryContext = QueryContext;
                /**
                 * The basic element of the query language.
                 * Everything is represented as a fragment.
                 */
                var Fragment = (function () {
                    /**
                     * Create a fragment from an integer set.
                     */
                    function Fragment(context, tag, atomIndices) {
                        this._hashCode = 0;
                        this._hashComputed = false;
                        this.context = context;
                        this.tag = tag;
                        this.atomIndices = atomIndices;
                    }
                    Object.defineProperty(Fragment.prototype, "hashCode", {
                        /**
                         * The hash code of the fragment.
                         */
                        get: function () {
                            if (this._hashComputed)
                                return this._hashCode;
                            var code = 23;
                            for (var _i = 0, _a = this.atomIndices; _i < _a.length; _i++) {
                                var i = _a[_i];
                                code = (31 * code + i) | 0;
                            }
                            this._hashCode = code;
                            this._hashComputed = true;
                            return code;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Fragment.prototype, "id", {
                        /**
                         * Id composed of <moleculeid>_<tag>.
                         */
                        get: function () {
                            return this.context.structure.id + "_" + this.tag;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Fragment.prototype, "atomCount", {
                        /**
                         * Number of atoms.
                         */
                        get: function () {
                            return this.atomIndices.length;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Fragment.prototype, "isHet", {
                        /**
                         * Determines if a fragment is HET based on the tag.
                         */
                        get: function () {
                            var residue = this.context.structure.atoms.residueIndex[this.tag];
                            return this.context.structure.residues.isHet[residue];
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Fragment.prototype, "fingerprint", {
                        /**
                         * A sorted list of residue identifiers.
                         */
                        get: function () {
                            if (this._fingerprint)
                                return this._fingerprint;
                            var indexList = this.residueIndices, struct = this.context.structure, residues = this.context.structure.residues, cName = residues.name, cAsym = residues.asymId, cSeq = residues.seqNumber, insCode = residues.insCode, names = [];
                            indexList.forEach(function (i) {
                                var name = cName[i] + " " + cAsym[i] + " " + cSeq[i];
                                if (insCode[i])
                                    name += " i:" + insCode[i];
                                names[names.length] = name;
                            });
                            return names.join("-");
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Fragment.prototype, "authFingerprint", {
                        /**
                         * A sorted list of residue identifiers.
                         */
                        get: function () {
                            if (this._authFingerprint)
                                return this._authFingerprint;
                            var indexList = this.residueIndices, struct = this.context.structure, residues = this.context.structure.residues, cName = residues.authName, cAsym = residues.authAsymId, cSeq = residues.authSeqNumber, insCode = residues.insCode, names = [];
                            indexList.forEach(function (i) {
                                var name = cName[i] + " " + cAsym[i] + " " + cSeq[i];
                                if (insCode[i])
                                    name += " i:" + insCode[i];
                                names[names.length] = name;
                            });
                            return names.join("-");
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Fragment.prototype.computeIndices = function () {
                        if (this._residueIndices)
                            return;
                        var residueIndices = new Set(), chainIndices = new Set(), entityIndices = new Set(), rIndices = this.context.structure.atoms.residueIndex, cIndices = this.context.structure.residues.chainIndex, eIndices = this.context.structure.chains.entityIndex, names = [];
                        this._residueIndices = [];
                        this._chainIndices = [];
                        this._entityIndices = [];
                        for (var _i = 0, _a = this.atomIndices; _i < _a.length; _i++) {
                            var i = _a[_i];
                            residueIndices.add(rIndices[i]);
                        }
                        residueIndices.forEach(function (i) { this[this.length] = i; }, this._residueIndices);
                        this._residueIndices.sort(function (a, b) { return a - b; });
                        for (var _b = 0, _c = this._residueIndices; _b < _c.length; _b++) {
                            var i = _c[_b];
                            chainIndices.add(cIndices[i]);
                        }
                        chainIndices.forEach(function (i) { this[this.length] = i; }, this._chainIndices);
                        this._chainIndices.sort(function (a, b) { return a - b; });
                        for (var _d = 0, _e = this._chainIndices; _d < _e.length; _d++) {
                            var i = _e[_d];
                            entityIndices.add(eIndices[i]);
                        }
                        entityIndices.forEach(function (i) { this[this.length] = i; }, this._entityIndices);
                        this._entityIndices.sort(function (a, b) { return a - b; });
                    };
                    Object.defineProperty(Fragment.prototype, "residueIndices", {
                        /**
                         * A sorted list of residue indices.
                         */
                        get: function () {
                            this.computeIndices();
                            return this._residueIndices;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Fragment.prototype, "chainIndices", {
                        /**
                         * A sorted list of chain indices.
                         */
                        get: function () {
                            this.computeIndices();
                            return this._chainIndices;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(Fragment.prototype, "entityIndices", {
                        /**
                         * A sorted list of entity indices.
                         */
                        get: function () {
                            this.computeIndices();
                            return this._entityIndices;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Fragment.areEqual = function (a, b) {
                        if (a.atomCount !== b.atomCount)
                            return false;
                        var xs = a.atomIndices, ys = b.atomIndices;
                        for (var i = 0; i < xs.length; i++) {
                            if (xs[i] !== ys[i])
                                return false;
                        }
                        return a.tag === b.tag;
                    };
                    /**
                     * Create a fragment from an integer set.
                     * Assumes the set is in the given context's mask.
                     */
                    Fragment.ofSet = function (context, atomIndices) {
                        var array = new Int32Array(atomIndices.size), index = 0;
                        atomIndices.forEach(function (i) { this.array[this.index++] = i; }, { array: array, index: 0 });
                        Array.prototype.sort.call(array, function (a, b) { return a - b; });
                        return new Fragment(context, array[0], array);
                    };
                    /**
                     * Create a fragment from an integer array.
                     * Assumes the set is in the given context's mask.
                     * Assumes the array is sorted.
                     */
                    Fragment.ofArray = function (context, tag, atomIndices) {
                        return new Fragment(context, tag, atomIndices);
                    };
                    /**
                     * Create a fragment from a single index.
                     * Assumes the index is in the given context's mask.
                     */
                    Fragment.ofIndex = function (context, index) {
                        var indices = new Int32Array(1);
                        indices[0] = index;
                        return new Fragment(context, index, indices);
                    };
                    /**
                     * Create a fragment from a <start,end) range.
                     * Assumes the fragment is non-empty in the given context's mask.
                     */
                    Fragment.ofIndexRange = function (context, start, endExclusive) {
                        var count = 0;
                        for (var i = start; i < endExclusive; i++) {
                            if (context.hasAtom(i))
                                count++;
                        }
                        var atoms = new Int32Array(count), offset = 0;
                        for (var i = start; i < endExclusive; i++) {
                            if (context.hasAtom(i))
                                atoms[offset++] = i;
                        }
                        return new Fragment(context, start, atoms);
                    };
                    return Fragment;
                }());
                Queries.Fragment = Fragment;
                /**
                 * A sequence of fragments the queries operate on.
                 */
                var FragmentSeq = (function () {
                    function FragmentSeq(context, fragments) {
                        this.context = context;
                        this.fragments = fragments;
                    }
                    FragmentSeq.empty = function (ctx) {
                        return new FragmentSeq(ctx, []);
                    };
                    Object.defineProperty(FragmentSeq.prototype, "length", {
                        get: function () {
                            return this.fragments.length;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /**
                     * Merges atom indices from all fragments.
                     */
                    FragmentSeq.prototype.unionAtomIndices = function () {
                        if (!this.length)
                            return [];
                        if (this.length === 1)
                            return this.fragments[0].atomIndices;
                        var map = new Int8Array(this.context.structure.atoms.count), atomCount = 0;
                        for (var _i = 0, _a = this.fragments; _i < _a.length; _i++) {
                            var f = _a[_i];
                            for (var _b = 0, _c = f.atomIndices; _b < _c.length; _b++) {
                                var i = _c[_b];
                                map[i] = 1;
                            }
                        }
                        for (var _d = 0, map_1 = map; _d < map_1.length; _d++) {
                            var i = map_1[_d];
                            atomCount += i;
                        }
                        var ret = new Int32Array(atomCount), offset = 0;
                        for (var i = 0, _l = map.length; i < _l; i++) {
                            if (map[i])
                                ret[offset++] = i;
                        }
                        return ret;
                    };
                    /**
                     * Merges atom indices from all fragments into a single fragment.
                     */
                    FragmentSeq.prototype.unionFragment = function () {
                        if (!this.length)
                            return new Fragment(this.context, 0, new Int32Array(0));
                        if (this.length === 1)
                            return this.fragments[0];
                        var union = this.unionAtomIndices();
                        return new Fragment(this.context, union[0], union);
                    };
                    return FragmentSeq;
                }());
                Queries.FragmentSeq = FragmentSeq;
                /**
                 * A builder that includes all fragments.
                 */
                var FragmentSeqBuilder = (function () {
                    function FragmentSeqBuilder(ctx) {
                        this.ctx = ctx;
                        this.fragments = [];
                    }
                    FragmentSeqBuilder.prototype.add = function (f) {
                        this.fragments[this.fragments.length] = f;
                    };
                    FragmentSeqBuilder.prototype.getSeq = function () {
                        return new FragmentSeq(this.ctx, this.fragments);
                    };
                    return FragmentSeqBuilder;
                }());
                Queries.FragmentSeqBuilder = FragmentSeqBuilder;
                /**
                 * A builder that includes only unique fragments.
                 */
                var HashFragmentSeqBuilder = (function () {
                    function HashFragmentSeqBuilder(ctx) {
                        this.ctx = ctx;
                        this.fragments = [];
                        this.byHash = new Map();
                    }
                    HashFragmentSeqBuilder.prototype.add = function (f) {
                        var hash = f.hashCode;
                        if (this.byHash.has(hash)) {
                            var fs = this.byHash.get(hash);
                            for (var _i = 0, fs_1 = fs; _i < fs_1.length; _i++) {
                                var q = fs_1[_i];
                                if (Fragment.areEqual(f, q))
                                    return this;
                            }
                            this.fragments[this.fragments.length] = f;
                            fs[fs.length] = f;
                        }
                        else {
                            this.fragments[this.fragments.length] = f;
                            this.byHash.set(hash, [f]);
                        }
                        return this;
                    };
                    HashFragmentSeqBuilder.prototype.getSeq = function () {
                        return new FragmentSeq(this.ctx, this.fragments);
                    };
                    return HashFragmentSeqBuilder;
                }());
                Queries.HashFragmentSeqBuilder = HashFragmentSeqBuilder;
            })(Queries = Structure.Queries || (Structure.Queries = {}));
        })(Structure = Core.Structure || (Core.Structure = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Structure;
        (function (Structure) {
            var Queries;
            (function (Queries) {
                var QueryBuilder = (function () {
                    function QueryBuilder(compiler) {
                        this.compiler = compiler;
                    }
                    //ambientAtoms(radius: number) {
                    //    return new QueryBuilder(QueryType.AmbientAtoms, [], [this, radius]);
                    //}
                    QueryBuilder.prototype.ambientResidues = function (radius) {
                        var _this = this;
                        return new QueryBuilder(function () { return Compiler.compileAmbientResidues(_this.compile(), radius); });
                    };
                    QueryBuilder.prototype.wholeResidues = function () {
                        var _this = this;
                        return new QueryBuilder(function () { return Compiler.compileWholeResidues(_this.compile()); });
                    };
                    //filter(fn: (f: Fragment) => boolean) {
                    //    return new QueryBuilder(QueryType.Filter, [], [this, fn]);
                    //}
                    //inside(where: QueryBuilder) {
                    //    return new QueryBuilder(QueryType.Inside, [], [this, where]);
                    //}
                    QueryBuilder.prototype.union = function () {
                        var _this = this;
                        return new QueryBuilder(function () { return Compiler.compileUnion(_this.compile()); });
                    };
                    QueryBuilder.prototype.inside = function (where) {
                        var _this = this;
                        return new QueryBuilder(function () { return Compiler.compileInside(_this.compile(), where.compile()); });
                    };
                    QueryBuilder.prototype.compile = function () {
                        return this.compiler();
                    };
                    QueryBuilder.extend = function (name, compilerProvider) {
                        QueryBuilder.prototype[name] = function () {
                            return new QueryBuilder(compilerProvider(this));
                        };
                    };
                    QueryBuilder.build = function (compiler) {
                        return new QueryBuilder(compiler);
                    };
                    return QueryBuilder;
                }());
                Queries.QueryBuilder = QueryBuilder;
                /**
                 * Generator queries such as atoms* or residues*
                 */
                var Generators;
                (function (Generators) {
                    function residues() {
                        var ids = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            ids[_i - 0] = arguments[_i];
                        }
                        return QueryBuilder.build(function () { return Compiler.compileAtomRanges(false, ids, function (m) { return m.residues; }); });
                    }
                    Generators.residues = residues;
                    function chains() {
                        var ids = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            ids[_i - 0] = arguments[_i];
                        }
                        return QueryBuilder.build(function () { return Compiler.compileAtomRanges(false, ids, function (m) { return m.chains; }); });
                    }
                    Generators.chains = chains;
                    function entities() {
                        var ids = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            ids[_i - 0] = arguments[_i];
                        }
                        return QueryBuilder.build(function () { return Compiler.compileAtomRanges(false, ids, function (m) { return m.entities; }); });
                    }
                    Generators.entities = entities;
                    function notEntities() {
                        var ids = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            ids[_i - 0] = arguments[_i];
                        }
                        return QueryBuilder.build(function () { return Compiler.compileAtomRanges(true, ids, function (m) { return m.entities; }); });
                    }
                    Generators.notEntities = notEntities;
                    function everything() { return new QueryBuilder(function () { return Compiler.compileEverything(); }); }
                    Generators.everything = everything;
                    function chainsFromIndices() {
                        var indices = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            indices[_i - 0] = arguments[_i];
                        }
                        return QueryBuilder.build(function () { return Compiler.compileFromIndices(false, indices, function (m) { return m.chains; }); });
                    }
                    Generators.chainsFromIndices = chainsFromIndices;
                    function entitiesFromIndices() {
                        var indices = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            indices[_i - 0] = arguments[_i];
                        }
                        return QueryBuilder.build(function () { return Compiler.compileFromIndices(false, indices, function (m) { return m.entities; }); });
                    }
                    Generators.entitiesFromIndices = entitiesFromIndices;
                    function residuesFromIndices() {
                        var indices = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            indices[_i - 0] = arguments[_i];
                        }
                        return QueryBuilder.build(function () { return Compiler.compileFromIndices(false, indices, function (m) { return m.residues; }); });
                    }
                    Generators.residuesFromIndices = residuesFromIndices;
                    function sequence(entityId, asymId, startId, endId) { return QueryBuilder.build(function () { return Compiler.compileSequence(entityId, asymId, startId, endId); }); }
                    Generators.sequence = sequence;
                    function hetGroups() { return QueryBuilder.build(function () { return Compiler.compileHetGroups(); }); }
                    Generators.hetGroups = hetGroups;
                    function cartoons() { return QueryBuilder.build(function () { return Compiler.compilePolymerNames(["CA", "O", "O5'", "C3'", "N3"], false); }); }
                    Generators.cartoons = cartoons;
                    function backbone() { return QueryBuilder.build(function () { return Compiler.compilePolymerNames(["N", "CA", "C", "O", "P", "OP1", "OP2", "O3'", "O5'", "C3'", "C5'"], false); }); }
                    Generators.backbone = backbone;
                    function sidechain() { return QueryBuilder.build(function () { return Compiler.compilePolymerNames(["N", "CA", "C", "O", "P", "OP1", "OP2", "O3'", "O5'", "C3'", "C5'"], true); }); }
                    Generators.sidechain = sidechain;
                    function atomsInBox(min, max) { return QueryBuilder.build(function () { return Compiler.compileAtomsInBox(min, max); }); }
                    Generators.atomsInBox = atomsInBox;
                    function or() {
                        var elements = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            elements[_i - 0] = arguments[_i];
                        }
                        return QueryBuilder.build(function () { return Compiler.compileOr(elements.map(function (e) { return e.compile(); })); });
                    }
                    Generators.or = or;
                })(Generators = Queries.Generators || (Queries.Generators = {}));
                /**
                 * Query compilation wrapper.
                 */
                var Compiler;
                (function (Compiler) {
                    var OptimizedId = (function () {
                        function OptimizedId(id, arrays) {
                            this.columns = [];
                            for (var _i = 0, _a = Object.keys(id); _i < _a.length; _i++) {
                                var key = _a[_i];
                                if (id[key] !== void 0 && !!arrays[key]) {
                                    this.columns.push({ value: id[key], array: arrays[key] });
                                }
                            }
                        }
                        OptimizedId.prototype.isSatisfied = function (i) {
                            for (var _i = 0, _a = this.columns; _i < _a.length; _i++) {
                                var c = _a[_i];
                                if (c.value !== c.array[i])
                                    return false;
                            }
                            return true;
                        };
                        return OptimizedId;
                    }());
                    function compileEverything() {
                        return function (ctx) {
                            if (ctx.isComplete) {
                                var atoms = ctx.structure.atoms.indices;
                                return new Queries.FragmentSeq(ctx, [new Queries.Fragment(ctx, atoms[0], atoms)]);
                            }
                            var indices = new Int32Array(ctx.atomCount);
                            var offset = 0;
                            for (var _i = 0, _a = ctx.structure.atoms.indices; _i < _a.length; _i++) {
                                var i = _a[_i];
                                if (ctx.hasAtom(i))
                                    indices[offset++] = i;
                            }
                            return new Queries.FragmentSeq(ctx, [Queries.Fragment.ofArray(ctx, indices[0], indices)]);
                        };
                    }
                    Compiler.compileEverything = compileEverything;
                    function compileFromIndices(complement, indices, tableProvider) {
                        return function (ctx) {
                            var table = tableProvider(ctx.structure), atomStartIndex = table.atomStartIndex, atomEndIndex = table.atomEndIndex, fragments = new Queries.FragmentSeqBuilder(ctx), include = false;
                            if (complement) {
                                var exclude = new Set(indices);
                                var count = table.count;
                                for (var i = 0; i < count; i++) {
                                    if (exclude.has(i))
                                        continue;
                                    if (!ctx.hasRange(atomStartIndex[i], atomEndIndex[i]))
                                        continue;
                                    fragments.add(Queries.Fragment.ofIndexRange(ctx, atomStartIndex[i], atomEndIndex[i]));
                                }
                            }
                            else {
                                for (var _i = 0, indices_3 = indices; _i < indices_3.length; _i++) {
                                    var i = indices_3[_i];
                                    if (!ctx.hasRange(atomStartIndex[i], atomEndIndex[i]))
                                        continue;
                                    fragments.add(Queries.Fragment.ofIndexRange(ctx, atomStartIndex[i], atomEndIndex[i]));
                                }
                            }
                            return fragments.getSeq();
                        };
                    }
                    Compiler.compileFromIndices = compileFromIndices;
                    function compileAtomRanges(complement, ids, tableProvider) {
                        return function (ctx) {
                            var table = tableProvider(ctx.structure), atomIndexStart = table.atomStartIndex, atomIndexEnd = table.atomEndIndex, fragments = new Queries.FragmentSeqBuilder(ctx), count = table.count, include = false;
                            var optimized = ids.map(function (id) { return new OptimizedId(id, table); });
                            var isEmptyIds = optimized.length === 0;
                            for (var i = 0; i < count; i++) {
                                if (!ctx.hasRange(atomIndexStart[i], atomIndexEnd[i]))
                                    continue;
                                include = isEmptyIds;
                                for (var _i = 0, optimized_1 = optimized; _i < optimized_1.length; _i++) {
                                    var id = optimized_1[_i];
                                    if (id.isSatisfied(i)) {
                                        include = true;
                                        break;
                                    }
                                }
                                if (complement)
                                    include = !include;
                                if (include) {
                                    fragments.add(Queries.Fragment.ofIndexRange(ctx, atomIndexStart[i], atomIndexEnd[i]));
                                }
                            }
                            return fragments.getSeq();
                        };
                    }
                    Compiler.compileAtomRanges = compileAtomRanges;
                    function compileSequence(entityId, asymId, start, end) {
                        return function (ctx) {
                            var residues = ctx.structure.residues, atomIndexStart = residues.atomStartIndex, atomIndexEnd = residues.atomEndIndex, entityIdCol = residues.entityId, asymIdCol = residues.asymId, seqNumber = residues.seqNumber, count = residues.count, include = false, i = 0, startIndex = -1, endIndex = -1;
                            for (i = 0; i < count; i++) {
                                if (entityIdCol[i] !== entityId || asymIdCol[i] !== asymId)
                                    continue;
                                if (seqNumber[i] >= start.seqNumber) {
                                    startIndex = i;
                                    break;
                                }
                            }
                            if (i === count)
                                return Queries.FragmentSeq.empty(ctx);
                            for (i = 0; i < count; i++) {
                                if (entityIdCol[i] !== entityId || asymIdCol[i] !== asymId) {
                                    i--;
                                    break;
                                }
                                if (seqNumber[i] === end.seqNumber)
                                    break;
                            }
                            endIndex = i;
                            if (!ctx.hasRange(atomIndexStart[startIndex], atomIndexEnd[endIndex])) {
                                return Queries.FragmentSeq.empty(ctx);
                            }
                            return new Queries.FragmentSeq(ctx, [Queries.Fragment.ofIndexRange(ctx, atomIndexStart[startIndex], atomIndexEnd[endIndex])]);
                        };
                    }
                    Compiler.compileSequence = compileSequence;
                    function compileHetGroups() {
                        return function (ctx) {
                            var residues = ctx.structure.residues, atomIndexStart = residues.atomStartIndex, atomIndexEnd = residues.atomEndIndex, isHet = residues.isHet, entityIndex = residues.entityIndex, entityType = ctx.structure.entities.entityType, water = Structure.EntityType.Water, fragments = new Queries.FragmentSeqBuilder(ctx), count = residues.count, include = false;
                            for (var i = 0; i < count; i++) {
                                if (!ctx.hasRange(atomIndexStart[i], atomIndexEnd[i]))
                                    continue;
                                if (entityType[entityIndex[i]] === water)
                                    continue;
                                if (isHet[i]) {
                                    fragments.add(Queries.Fragment.ofIndexRange(ctx, atomIndexStart[i], atomIndexEnd[i]));
                                }
                            }
                            return fragments.getSeq();
                        };
                    }
                    Compiler.compileHetGroups = compileHetGroups;
                    function compileAtomsInBox(min, max) {
                        return function (ctx) {
                            var atoms = ctx.structure.atoms, xs = atoms.x, ys = atoms.y, zs = atoms.z, count = atoms.count, fragment = [];
                            for (var i = 0; i < count; i++) {
                                if (!ctx.hasAtom(i))
                                    continue;
                                var x = xs[i], y = ys[i], z = zs[i];
                                if (x >= min.x && x <= max.x
                                    && y >= min.y && y <= max.y
                                    && z >= min.z && z <= max.z) {
                                    fragment[fragment.length] = i;
                                }
                            }
                            if (!fragment.length)
                                return Queries.FragmentSeq.empty(ctx);
                            return new Queries.FragmentSeq(ctx, [new Queries.Fragment(ctx, fragment[0], fragment)]);
                        };
                    }
                    Compiler.compileAtomsInBox = compileAtomsInBox;
                    ////function updateBox(f: Fragment,
                    ////    arrays: { x: number[]; y: number[]; z: number[] },
                    ////    deltas: { dx: number; dy: number; dz: number },
                    ////    min: { x: number; y: number; z: number }, max: { x: number; y: number; z: number }) {
                    ////    min.x = min.y = min.z = Number.MAX_VALUE;
                    ////    max.x = max.y = max.z = -Number.MAX_VALUE;
                    ////    for (let i of f.atomIndices) {
                    ////        let x = arrays.x[i], y = arrays.y[i], z = arrays.z[i];
                    ////        if (x > max.x) max.x = x;
                    ////        if (y > max.y) max.y = y;
                    ////        if (z > max.z) max.z = z;
                    ////        if (x > min.x) min.x = x;
                    ////        if (y > min.y) min.y = y;
                    ////        if (z > min.z) min.z = z;
                    ////    }
                    ////    min.x -= deltas.dx;
                    ////    min.y -= deltas.dy;
                    ////    min.z -= deltas.dz;
                    ////    max.x += deltas.dx;
                    ////    max.y += deltas.dy;
                    ////    max.z += deltas.dz;
                    ////}
                    ////export function compileExtendBox(what: Query, deltas: { dx: number; dy: number; dz: number }) {
                    ////    return (ctx: QueryContext) => {
                    ////        let ret = new HashFragmentSeqBuilder(ctx);
                    ////        let min = { x: 0.1, y: 0.1, z: 0.1 },
                    ////            max = { x: 0.1, y: 0.1, z: 0.1 },
                    ////            atoms = { x: ctx.structure.atoms.x, y: ctx.structure.atoms.y, z: ctx.structure.atoms.z },
                    ////            xs = atoms.x, ys = atoms.y, zs = atoms.z,
                    ////        for (let f of what(ctx).fragments) {
                    ////            updateBox(f, atoms, deltas, min, max);
                    ////            let fragment: number[] = [];
                    ////            for (let i of f.atomIndices) {
                    ////                if (!ctx.hasAtom(i)) continue;
                    ////                var x = xs[i], y = ys[i], z = zs[i];
                    ////                if (x >= min.x && x <= max.x
                    ////                    && y >= min.y && y <= max.y
                    ////                    && z >= min.z && z <= max.z) {
                    ////                    fragment[fragment.length] = i;
                    ////                }
                    ////            }
                    ////            if (fragment.length > 0) {
                    ////                //ret.add(Fragment.of)
                    ////            }
                    ////        }
                    ////        return ret.getSeq();
                    ////    };
                    ////}
                    function compileInside(what, where) {
                        return function (ctx) {
                            return new Queries.FragmentSeq(ctx, what(Queries.QueryContext.ofFragments(where(ctx))).fragments);
                        };
                    }
                    Compiler.compileInside = compileInside;
                    function compileFilter(what, filter) {
                        return function (ctx) {
                            var src = what(ctx).fragments, result = new Queries.FragmentSeqBuilder(ctx), f;
                            for (var i = 0; i < src.length; i++) {
                                f = src[i];
                                if (filter(f))
                                    result.add(f);
                            }
                            return result.getSeq();
                        };
                    }
                    Compiler.compileFilter = compileFilter;
                    function compileOr(queries) {
                        return function (ctx) {
                            var fragments = new Queries.HashFragmentSeqBuilder(ctx);
                            for (var _i = 0, queries_1 = queries; _i < queries_1.length; _i++) {
                                var q = queries_1[_i];
                                var r = q(ctx);
                                for (var _a = 0, _b = r.fragments; _a < _b.length; _a++) {
                                    var f = _b[_a];
                                    fragments.add(f);
                                }
                            }
                            return fragments.getSeq();
                        };
                    }
                    Compiler.compileOr = compileOr;
                    function compileUnion(what) {
                        return function (ctx) {
                            var src = what(ctx).fragments, indices = new Set(), j = 0, atoms;
                            for (var i = 0; i < src.length; i++) {
                                atoms = src[i].atomIndices;
                                for (j = 0; j < atoms.length; j++)
                                    indices.add(atoms[j]);
                            }
                            if (indices.size === 0)
                                return Queries.FragmentSeq.empty(ctx);
                            return new Queries.FragmentSeq(ctx, [Queries.Fragment.ofSet(ctx, indices)]);
                        };
                    }
                    Compiler.compileUnion = compileUnion;
                    function compilePolymerNames(names, complement) {
                        return function (ctx) {
                            var structure = ctx.structure, atomNames = structure.atoms.name, indices = [], indexCount = 0;
                            var allowedNames = new Set(names);
                            if (complement) {
                                for (var ei = 0; ei < structure.entities.count; ei++) {
                                    if (structure.entities.entityType[ei] !== Structure.EntityType.Polymer)
                                        continue;
                                    var start = structure.entities.atomStartIndex[ei], end = structure.entities.atomEndIndex[ei];
                                    for (var i = start; i < end; i++) {
                                        if (ctx.hasAtom(i) && !allowedNames.has(atomNames[i]))
                                            indices[indexCount++] = i;
                                    }
                                }
                            }
                            else {
                                for (var ei = 0; ei < structure.entities.count; ei++) {
                                    if (structure.entities.entityType[ei] !== Structure.EntityType.Polymer)
                                        continue;
                                    var start = structure.entities.atomStartIndex[ei], end = structure.entities.atomEndIndex[ei];
                                    for (var i = start; i < end; i++) {
                                        if (ctx.hasAtom(i) && allowedNames.has(atomNames[i]))
                                            indices[indexCount++] = i;
                                    }
                                }
                            }
                            if (!indices.length)
                                return Queries.FragmentSeq.empty(ctx);
                            return new Queries.FragmentSeq(ctx, [Queries.Fragment.ofArray(ctx, indices[0], new Int32Array(indices))]);
                        };
                    }
                    Compiler.compilePolymerNames = compilePolymerNames;
                    function compileAmbientResidues(where, radius) {
                        return function (ctx) {
                            var src = where(ctx), tree = ctx.tree, radiusCtx = tree.createContextRadius(radius, false), buffer = radiusCtx.buffer, ret = new Queries.HashFragmentSeqBuilder(ctx), x = ctx.structure.atoms.x, y = ctx.structure.atoms.y, z = ctx.structure.atoms.z, residueIndex = ctx.structure.atoms.residueIndex, atomStart = ctx.structure.residues.atomStartIndex, atomEnd = ctx.structure.residues.atomEndIndex, residues = new Set();
                            for (var _i = 0, _a = src.fragments; _i < _a.length; _i++) {
                                var f = _a[_i];
                                residues.clear();
                                for (var _b = 0, _c = f.atomIndices; _b < _c.length; _b++) {
                                    var i = _c[_b];
                                    residues.add(residueIndex[i]);
                                    radiusCtx.nearest(x[i], y[i], z[i], radius);
                                    for (var j = 0, _l = buffer.count; j < _l; j++) {
                                        residues.add(residueIndex[buffer.indices[j]]);
                                    }
                                }
                                var atomCount = { count: 0, start: atomStart, end: atomEnd };
                                residues.forEach(function (r) { this.count += this.end[r] - this.start[r]; }, atomCount);
                                var indices = new Int32Array(atomCount.count), atomIndices = { indices: indices, offset: 0, start: atomStart, end: atomEnd };
                                residues.forEach(function (r) {
                                    for (var i = this.start[r], _l = this.end[r]; i < _l; i++) {
                                        this.indices[this.offset++] = i;
                                    }
                                }, atomIndices);
                                Array.prototype.sort.call(indices, function (a, b) { return a - b; });
                                ret.add(Queries.Fragment.ofArray(ctx, indices[0], indices));
                            }
                            return ret.getSeq();
                        };
                    }
                    Compiler.compileAmbientResidues = compileAmbientResidues;
                    function compileWholeResidues(where) {
                        return function (ctx) {
                            var src = where(ctx), ret = new Queries.HashFragmentSeqBuilder(ctx), residueIndex = ctx.structure.atoms.residueIndex, atomStart = ctx.structure.residues.atomStartIndex, atomEnd = ctx.structure.residues.atomEndIndex, residues = new Set();
                            for (var _i = 0, _a = src.fragments; _i < _a.length; _i++) {
                                var f = _a[_i];
                                residues.clear();
                                for (var _b = 0, _c = f.atomIndices; _b < _c.length; _b++) {
                                    var i = _c[_b];
                                    residues.add(residueIndex[i]);
                                }
                                var atomCount = { count: 0, start: atomStart, end: atomEnd };
                                residues.forEach(function (r) { this.count += this.end[r] - this.start[r]; }, atomCount);
                                var indices = new Int32Array(atomCount.count), atomIndices = { indices: indices, offset: 0, start: atomStart, end: atomEnd };
                                residues.forEach(function (r) {
                                    for (var i = this.start[r], _l = this.end[r]; i < _l; i++) {
                                        this.indices[this.offset++] = i;
                                    }
                                }, atomIndices);
                                Array.prototype.sort.call(indices, function (a, b) { return a - b; });
                                ret.add(Queries.Fragment.ofArray(ctx, indices[0], indices));
                            }
                            return ret.getSeq();
                        };
                    }
                    Compiler.compileWholeResidues = compileWholeResidues;
                })(Compiler = Queries.Compiler || (Queries.Compiler = {}));
            })(Queries = Structure.Queries || (Structure.Queries = {}));
        })(Structure = Core.Structure || (Core.Structure = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Utils;
        (function (Utils) {
            function extend(object, source, guard) {
                var v;
                var s = source;
                var o = object;
                var g = guard;
                for (var _i = 0, _a = Object.keys(source); _i < _a.length; _i++) {
                    var k = _a[_i];
                    v = s[k];
                    if (v !== void 0)
                        o[k] = v;
                    else if (guard)
                        o[k] = g[k];
                }
                if (guard) {
                    for (var _b = 0, _c = Object.keys(guard); _b < _c.length; _b++) {
                        var k = _c[_b];
                        v = o[k];
                        if (v === void 0)
                            o[k] = g[k];
                    }
                }
                return object;
            }
            Utils.extend = extend;
            ;
            function updateClone(object, source) {
                var s = source;
                var o = object;
                var ret = {};
                for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {
                    var k = _a[_i];
                    ret[k] = s[k];
                }
                return ret;
            }
            Utils.updateClone = updateClone;
            ;
            function shallowEqual(a, b) {
                var x = a;
                var y = b;
                for (var _i = 0, _a = Object.keys(a); _i < _a.length; _i++) {
                    var k = _a[_i];
                    if (x[k] !== y[k])
                        return false;
                }
                return true;
            }
            Utils.shallowEqual = shallowEqual;
            function shallowClone(o) {
                return extend({}, o);
            }
            Utils.shallowClone = shallowClone;
            function debounce(func, wait) {
                var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = 0, trailing = true, leading = false;
                wait = Math.max(0, wait) || 0;
                var delayed = function () {
                    var remaining = wait - (performance.now() - stamp);
                    if (remaining <= 0) {
                        if (maxTimeoutId) {
                            clearTimeout(maxTimeoutId);
                        }
                        var isCalled = trailingCall;
                        maxTimeoutId = timeoutId = trailingCall = undefined;
                        if (isCalled) {
                            lastCalled = performance.now();
                            result = func.apply(thisArg, args);
                            if (!timeoutId && !maxTimeoutId) {
                                args = thisArg = null;
                            }
                        }
                    }
                    else {
                        timeoutId = setTimeout(delayed, remaining);
                    }
                };
                var maxDelayed = function () {
                    if (timeoutId) {
                        clearTimeout(timeoutId);
                    }
                    maxTimeoutId = timeoutId = trailingCall = undefined;
                    if (trailing || (maxWait !== wait)) {
                        lastCalled = performance.now();
                        result = func.apply(thisArg, args);
                        if (!timeoutId && !maxTimeoutId) {
                            args = thisArg = null;
                        }
                    }
                };
                return function () {
                    args = arguments;
                    stamp = performance.now();
                    thisArg = this;
                    trailingCall = trailing && (timeoutId || !leading);
                    var isCalled = false;
                    var leadingCall = false;
                    if (maxWait === 0) {
                        var leadingCall_1 = leading && !timeoutId;
                    }
                    else {
                        if (!maxTimeoutId && !leading) {
                            lastCalled = stamp;
                        }
                        var remaining = maxWait - (stamp - lastCalled), isCalled_1 = remaining <= 0;
                        if (isCalled_1) {
                            if (maxTimeoutId) {
                                maxTimeoutId = clearTimeout(maxTimeoutId);
                            }
                            lastCalled = stamp;
                            result = func.apply(thisArg, args);
                        }
                        else if (!maxTimeoutId) {
                            maxTimeoutId = setTimeout(maxDelayed, remaining);
                        }
                    }
                    if (isCalled && timeoutId) {
                        timeoutId = clearTimeout(timeoutId);
                    }
                    else if (!timeoutId && wait !== maxWait) {
                        timeoutId = setTimeout(delayed, wait);
                    }
                    if (leadingCall) {
                        isCalled = true;
                        result = func.apply(thisArg, args);
                    }
                    if (isCalled && !timeoutId && !maxTimeoutId) {
                        args = thisArg = null;
                    }
                    return result;
                };
            }
            Utils.debounce = debounce;
        })(Utils = Core.Utils || (Core.Utils = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Utils;
        (function (Utils) {
            /**
             * A a JS native array with the given size.
             */
            function makeNativeIntArray(size) {
                var arr = [];
                for (var i = 0; i < size; i++)
                    arr[i] = 0;
                return arr;
            }
            Utils.makeNativeIntArray = makeNativeIntArray;
            /**
             * A a JS native array with the given size.
             */
            function makeNativeFloatArray(size) {
                var arr = [];
                if (!size)
                    return arr;
                arr[0] = 0.1;
                for (var i = 0; i < size; i++)
                    arr[i] = 0;
                return arr;
            }
            Utils.makeNativeFloatArray = makeNativeFloatArray;
            /**
             * A generic chunked array builder.
             */
            var ChunkedArrayBuilder = (function () {
                function ChunkedArrayBuilder(creator, chunkElementCount, elementSize) {
                    chunkElementCount = chunkElementCount | 0;
                    if (chunkElementCount <= 0)
                        chunkElementCount = 1;
                    this.elementSize = elementSize;
                    this.chunkSize = chunkElementCount * elementSize;
                    this.creator = creator;
                    this.current = creator(this.chunkSize);
                    this.parts = [this.current];
                    this.currentIndex = 0;
                    this.elementCount = 0;
                }
                ChunkedArrayBuilder.prototype.add4 = function (x, y, z, w) {
                    if (this.currentIndex >= this.chunkSize) {
                        this.currentIndex = 0;
                        this.current = this.creator(this.chunkSize);
                        this.parts[this.parts.length] = this.current;
                    }
                    this.current[this.currentIndex++] = x;
                    this.current[this.currentIndex++] = y;
                    this.current[this.currentIndex++] = z;
                    this.current[this.currentIndex++] = w;
                    return this.elementCount++;
                };
                ChunkedArrayBuilder.prototype.add3 = function (x, y, z) {
                    if (this.currentIndex >= this.chunkSize) {
                        this.currentIndex = 0;
                        this.current = this.creator(this.chunkSize);
                        this.parts[this.parts.length] = this.current;
                    }
                    this.current[this.currentIndex++] = x;
                    this.current[this.currentIndex++] = y;
                    this.current[this.currentIndex++] = z;
                    return this.elementCount++;
                };
                ChunkedArrayBuilder.prototype.add2 = function (x, y) {
                    if (this.currentIndex >= this.chunkSize) {
                        this.currentIndex = 0;
                        this.current = this.creator(this.chunkSize);
                        this.parts[this.parts.length] = this.current;
                    }
                    this.current[this.currentIndex++] = x;
                    this.current[this.currentIndex++] = y;
                    return this.elementCount++;
                };
                ChunkedArrayBuilder.prototype.add = function (x) {
                    if (this.currentIndex >= this.chunkSize) {
                        this.currentIndex = 0;
                        this.current = this.creator(this.chunkSize);
                        this.parts[this.parts.length] = this.current;
                    }
                    this.current[this.currentIndex++] = x;
                    return this.elementCount++;
                };
                ChunkedArrayBuilder.prototype.compact = function () {
                    var ret = this.creator(this.elementSize * this.elementCount), i, j, offset = (this.parts.length - 1) * this.chunkSize, offsetInner = 0, part;
                    if (this.parts.length > 1) {
                        if (this.parts[0].buffer) {
                            for (i = 0; i < this.parts.length - 1; i++) {
                                ret.set(this.parts[i], this.chunkSize * i);
                            }
                        }
                        else {
                            for (i = 0; i < this.parts.length - 1; i++) {
                                offsetInner = this.chunkSize * i;
                                part = this.parts[i];
                                for (j = 0; j < this.chunkSize; j++) {
                                    ret[offsetInner + j] = part[j];
                                }
                            }
                        }
                    }
                    if (this.current.buffer && this.currentIndex >= this.chunkSize) {
                        ret.set(this.current, this.chunkSize * (this.parts.length - 1));
                    }
                    else {
                        for (i = 0; i < this.currentIndex; i++) {
                            ret[offset + i] = this.current[i];
                        }
                    }
                    return ret;
                };
                ChunkedArrayBuilder.forVertex3D = function (chunkVertexCount) {
                    if (chunkVertexCount === void 0) { chunkVertexCount = 262144; }
                    return new ChunkedArrayBuilder(function (size) { return new Float32Array(size); }, chunkVertexCount, 3);
                };
                ChunkedArrayBuilder.forIndexBuffer = function (chunkIndexCount) {
                    if (chunkIndexCount === void 0) { chunkIndexCount = 262144; }
                    return new ChunkedArrayBuilder(function (size) { return new Uint32Array(size); }, chunkIndexCount, 3);
                };
                ChunkedArrayBuilder.forTokenIndices = function (chunkTokenCount) {
                    if (chunkTokenCount === void 0) { chunkTokenCount = 131072; }
                    return new ChunkedArrayBuilder(function (size) { return new Int32Array(size); }, chunkTokenCount, 2);
                };
                ChunkedArrayBuilder.forIndices = function (chunkTokenCount) {
                    if (chunkTokenCount === void 0) { chunkTokenCount = 131072; }
                    return new ChunkedArrayBuilder(function (size) { return new Int32Array(size); }, chunkTokenCount, 1);
                };
                ChunkedArrayBuilder.forInt32 = function (chunkSize) {
                    if (chunkSize === void 0) { chunkSize = 131072; }
                    return new ChunkedArrayBuilder(function (size) { return new Int32Array(size); }, chunkSize, 1);
                };
                ChunkedArrayBuilder.forFloat32 = function (chunkSize) {
                    if (chunkSize === void 0) { chunkSize = 131072; }
                    return new ChunkedArrayBuilder(function (size) { return new Float32Array(size); }, chunkSize, 1);
                };
                ChunkedArrayBuilder.forArray = function (chunkSize) {
                    if (chunkSize === void 0) { chunkSize = 131072; }
                    return new ChunkedArrayBuilder(function (size) { return []; }, chunkSize, 1);
                };
                return ChunkedArrayBuilder;
            }());
            Utils.ChunkedArrayBuilder = ChunkedArrayBuilder;
            /**
             * Static size array builder.
             */
            var ArrayBuilder = (function () {
                function ArrayBuilder(creator, chunkElementCount, elementSize) {
                    chunkElementCount = chunkElementCount | 0;
                    this.array = creator(chunkElementCount * elementSize);
                    this.currentIndex = 0;
                    this.elementCount = 0;
                }
                ArrayBuilder.prototype.add3 = function (x, y, z) {
                    this.array[this.currentIndex++] = x;
                    this.array[this.currentIndex++] = y;
                    this.array[this.currentIndex++] = z;
                    this.elementCount++;
                };
                ArrayBuilder.prototype.add2 = function (x, y) {
                    this.array[this.currentIndex++] = x;
                    this.array[this.currentIndex++] = y;
                    this.elementCount++;
                };
                ArrayBuilder.prototype.add = function (x) {
                    this.array[this.currentIndex++] = x;
                    this.elementCount++;
                };
                ArrayBuilder.forVertex3D = function (count) {
                    return new ArrayBuilder(function (size) { return new Float32Array(size); }, count, 3);
                };
                ArrayBuilder.forIndexBuffer = function (count) {
                    return new ArrayBuilder(function (size) { return new Int32Array(size); }, count, 3);
                };
                ArrayBuilder.forTokenIndices = function (count) {
                    return new ArrayBuilder(function (size) { return new Int32Array(size); }, count, 2);
                };
                ArrayBuilder.forIndices = function (count) {
                    return new ArrayBuilder(function (size) { return new Int32Array(size); }, count, 1);
                };
                ArrayBuilder.forInt32 = function (count) {
                    return new ArrayBuilder(function (size) { return new Int32Array(size); }, count, 1);
                };
                ArrayBuilder.forFloat32 = function (count) {
                    return new ArrayBuilder(function (size) { return new Float32Array(size); }, count, 1);
                };
                ArrayBuilder.forArray = function (count) {
                    return new ArrayBuilder(function (size) { return []; }, count, 1);
                };
                return ArrayBuilder;
            }());
            Utils.ArrayBuilder = ArrayBuilder;
        })(Utils = Core.Utils || (Core.Utils = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Utils;
        (function (Utils) {
            "use strict";
            /**
             * Efficient integer and float parsers.
             *
             * For the purposes of parsing numbers from the mmCIF data representations,
             * up to 4 times faster than JS parseInt/parseFloat.
             */
            var FastNumberParsers = (function () {
                function FastNumberParsers() {
                }
                FastNumberParsers.parseInt = function (str, start, end) {
                    var ret = 0, neg = 1;
                    if (str.charCodeAt(start) === 45 /* - */) {
                        neg = -1;
                        start++;
                    }
                    for (; start < end; start++) {
                        var c = str.charCodeAt(start) - 48;
                        if (c > 9 || c < 0)
                            return (neg * ret) | 0;
                        else
                            ret = (10 * ret + c) | 0;
                    }
                    return neg * ret;
                };
                FastNumberParsers.parseScientific = function (main, str, start, end) {
                    return main * Math.pow(10.0, FastNumberParsers.parseInt(str, start, end));
                };
                FastNumberParsers.parseFloat = function (str, start, end) {
                    var neg = 1.0, ret = 0.0, point = 0.0, div = 1.0;
                    if (str.charCodeAt(start) === 45) {
                        neg = -1.0;
                        ++start;
                    }
                    while (start < end) {
                        var c = str.charCodeAt(start) - 48;
                        if (c >= 0 && c < 10) {
                            ret = ret * 10 + c;
                            ++start;
                        }
                        else if (c === -2) {
                            ++start;
                            while (start < end) {
                                c = str.charCodeAt(start) - 48;
                                if (c >= 0 && c < 10) {
                                    point = 10.0 * point + c;
                                    div = 10.0 * div;
                                    ++start;
                                }
                                else if (c === 53 || c === 21) {
                                    return FastNumberParsers.parseScientific(neg * (ret + point / div), str, start + 1, end);
                                }
                                else {
                                    return neg * (ret + point / div);
                                }
                            }
                            return neg * (ret + point / div);
                        }
                        else if (c === 53 || c === 21) {
                            return FastNumberParsers.parseScientific(neg * ret, str, start + 1, end);
                        }
                        else
                            break;
                    }
                    return neg * ret;
                };
                return FastNumberParsers;
            }());
            Utils.FastNumberParsers = FastNumberParsers;
        })(Utils = Core.Utils || (Core.Utils = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
/*
* Copyright (c) 2016 David Sehnal
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var LiteMol;
(function (LiteMol) {
    var Core;
    (function (Core) {
        var Utils;
        (function (Utils) {
            "use strict";
            var PerformanceHelper;
            (function (PerformanceHelper) {
                PerformanceHelper.perfGetTime = (function () {
                    if (typeof window !== 'undefined' && window.performance) {
                        return function () { return window.performance.now(); };
                    }
                    else if (typeof process !== 'undefined' && process.hrtime !== 'undefined') {
                        return function () {
                            var t = process.hrtime();
                            return t[0] * 1000 + t[1] / 1000000;
                        };
                    }
                    else {
                        return function () { return +new Date(); };
                    }
                })();
            })(PerformanceHelper || (PerformanceHelper = {}));
            var PerformanceMonitor = (function () {
                function PerformanceMonitor() {
                    this.starts = new Map();
                    this.ends = new Map();
                }
                PerformanceMonitor.prototype.start = function (name) {
                    this.starts.set(name, PerformanceHelper.perfGetTime());
                };
                PerformanceMonitor.prototype.end = function (name) {
                    this.ends.set(name, PerformanceHelper.perfGetTime());
                };
                PerformanceMonitor.prototype.format = function (t) {
                    if (isNaN(t))
                        return 'n/a';
                    var h = Math.floor(t / (60 * 60 * 1000)), m = Math.floor(t / (60 * 1000) % 60), s = Math.floor(t / 1000 % 3600), ms = Math.floor(t % 1000).toString();
                    while (ms.length < 3)
                        ms = "0" + ms;
                    if (h > 0)
                        return h + "h" + m + "m" + s + "." + ms + "s";
                    if (m > 0)
                        return m + "m" + s + "." + ms + "s";
                    if (s > 0)
                        return s + "." + ms + "s";
                    return t.toFixed(0) + "ms";
                };
                PerformanceMonitor.prototype.measure = function (name) {
                    var start = this.starts.get(name), end = this.ends.get(name);
                    this.starts.delete(name);
                    this.ends.delete(name);
                    return this.format(end - start);
                };
                PerformanceMonitor.prototype.sum = function () {
                    var _this = this;
                    var names = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        names[_i - 0] = arguments[_i];
                    }
                    var t = 0;
                    for (var _a = 0, _b = names.map(function (n) { return _this.ends.get(n) - _this.starts.get(n); }); _a < _b.length; _a++) {
                        var m = _b[_a];
                        t += m;
                    }
                    return this.format(t);
                };
                return PerformanceMonitor;
            }());
            Utils.PerformanceMonitor = PerformanceMonitor;
        })(Utils = Core.Utils || (Core.Utils = {}));
    })(Core = LiteMol.Core || (LiteMol.Core = {}));
})(LiteMol || (LiteMol = {}));
﻿
    return LiteMol.Core;
})();

if (typeof module === 'object' && typeof module.exports === 'object') {
  module.exports = __liteMolCore;
}  else if (typeof define === 'function' && define.amd) {
  define([], function() { return __liteMolCore; });
} else {
  var __target = !!window ? window : this;
  if (__target.LiteMol) __target.LiteMol.Core = __liteMolCore;
  else __target.LiteMol = { Core: __liteMolCore };
}
